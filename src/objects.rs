use std::num::NonZeroU32;

macro_rules! gl_objects {
    ($( $ident:ident ) +) => {
        $(
            #[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
            pub struct $ident(NonZeroU32);

            impl $ident {
                /// Returns [Self] if inner isn't zero, panics otherwise.
                /// # Safety
                /// The caller has to ensure the inner value has been generated by the appropriate function
                pub const unsafe fn new(inner: u32) -> Self {
                    if inner != 0 {
                        Self::new_unchecked(inner)
                    } else {
                        panic!(stringify!(A $ident object id cannot be zero.)) // TODO: Should this panic? Maybe returing a Result is better?.
                    }
                }

                /// # Safety
                ///
                /// This struct is just wrapper around a NonZeroU32 so the same safety requirements as [NonZeroU32::new_unchecked] apply.
                pub const unsafe fn new_unchecked(inner: u32) -> Self {
                    Self(NonZeroU32::new_unchecked(inner))
                }

                /// Returns the underlying raw value. Usefull for interacting with other libraries, extensions, or yet to be exported features.
                pub const fn inner(&self) -> u32 {
                    self.0.get()
                }
            }
        )*
    };
}

gl_objects!(Buffer Shader Program VertexArray LinkedProgram PipeLine);

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UniformLocation(u32);

impl UniformLocation {
    pub const unsafe fn new_unchecked(inner: u32) -> Self {
        Self(inner)
    }

    /// Returns the underlying raw value. Usefull for interacting with other libraries or yet to be exported features.
    pub const fn inner(&self) -> u32 {
        self.0
    }
}
