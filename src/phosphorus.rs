#[cfg(feature = "trace-calls")]
use tracing::{error, trace};

use std::{
    mem::transmute,
    os::raw::*,
    ptr::null_mut,
    sync::atomic::{AtomicPtr, Ordering},
};
const RELAX: Ordering = Ordering::Relaxed;
type APcv = AtomicPtr<c_void>;

pub use types::*;
#[allow(missing_docs)]
pub mod types {
    use std::os::raw::*;
    pub type GLvoid = c_void;
    pub type GLbyte = c_char;
    pub type GLubyte = c_uchar;
    pub type GLchar = c_char;
    pub type GLboolean = c_uchar;
    pub type GLshort = c_short;
    pub type GLushort = c_ushort;
    pub type GLint = c_int;
    pub type GLuint = c_uint;
    pub type GLint64 = i64;
    pub type GLuint64 = u64;
    pub type GLintptr = isize;
    pub type GLsizeiptr = isize;
    pub type GLintptrARB = isize;
    pub type GLsizeiptrARB = isize;
    pub type GLint64EXT = i64;
    pub type GLuint64EXT = u64;
    pub type GLsizei = GLint;
    pub type GLclampx = c_int;
    pub type GLfixed = GLint;
    pub type GLhalf = c_ushort;
    pub type GLhalfNV = c_ushort;
    pub type GLhalfARB = c_ushort;
    pub type GLenum = c_uint;
    pub type GLbitfield = c_uint;
    pub type GLfloat = c_float;
    pub type GLdouble = c_double;
    pub type GLclampf = c_float;
    pub type GLclampd = c_double;
    pub type GLcharARB = c_char;
    #[cfg(target_os = "macos")]
    pub type GLhandleARB = *const c_void;
    #[cfg(not(target_os = "macos"))]
    pub type GLhandleARB = c_uint;
    pub enum __GLsync {}
    pub type GLsync = *const __GLsync;
    pub enum _cl_context {}
    pub enum _cl_event {}
    pub type GLvdpauSurfaceNV = GLintptr;
    pub type GLeglClientBufferEXT = *const c_void;
    pub type GLeglImageOES = *const c_void;
    pub type GLDEBUGPROC = extern "system" fn(
        source: GLenum,
        type_: GLenum,
        id: GLuint,
        severity: GLenum,
        length: GLsizei,
        message: *const GLchar,
        userParam: *mut c_void,
    );
    pub type GLDEBUGPROCARB = extern "system" fn(
        source: GLenum,
        type_: GLenum,
        id: GLuint,
        severity: GLenum,
        length: GLsizei,
        message: *const GLchar,
        userParam: *mut c_void,
    );
    pub type GLDEBUGPROCKHR = extern "system" fn(
        source: GLenum,
        type_: GLenum,
        id: GLuint,
        severity: GLenum,
        length: GLsizei,
        message: *const GLchar,
        userParam: *mut GLvoid,
    );
    pub type GLDEBUGPROCAMD = extern "system" fn(
        id: GLuint,
        category: GLenum,
        severity: GLenum,
        length: GLsizei,
        message: *const GLchar,
        userParam: *mut GLvoid,
    );
    pub type GLVULKANPROCNV = extern "system" fn();
}

pub use enums::*;
pub mod enums {
    //! Contains all the GL enumerated values.
    //!
    //! In C these are called 'enums', but in Rust we call them a 'const'. Whatever.
    use super::*;
    pub const GL_ACTIVE_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D9;
    pub const GL_ACTIVE_ATTRIBUTES: GLenum = 0x8B89;
    pub const GL_ACTIVE_ATTRIBUTE_MAX_LENGTH: GLenum = 0x8B8A;
    pub const GL_ACTIVE_PROGRAM: GLenum = 0x8259;
    pub const GL_ACTIVE_RESOURCES: GLenum = 0x92F5;
    pub const GL_ACTIVE_SUBROUTINES: GLenum = 0x8DE5;
    pub const GL_ACTIVE_SUBROUTINE_MAX_LENGTH: GLenum = 0x8E48;
    pub const GL_ACTIVE_SUBROUTINE_UNIFORMS: GLenum = 0x8DE6;
    pub const GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS: GLenum = 0x8E47;
    pub const GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH: GLenum = 0x8E49;
    pub const GL_ACTIVE_TEXTURE: GLenum = 0x84E0;
    pub const GL_ACTIVE_UNIFORMS: GLenum = 0x8B86;
    pub const GL_ACTIVE_UNIFORM_BLOCKS: GLenum = 0x8A36;
    pub const GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: GLenum = 0x8A35;
    pub const GL_ACTIVE_UNIFORM_MAX_LENGTH: GLenum = 0x8B87;
    pub const GL_ACTIVE_VARIABLES: GLenum = 0x9305;
    pub const GL_ALIASED_LINE_WIDTH_RANGE: GLenum = 0x846E;
    pub const GL_ALL_BARRIER_BITS: GLbitfield = 0xFFFFFFFF;
    pub const GL_ALL_SHADER_BITS: GLbitfield = 0xFFFFFFFF;
    pub const GL_ALPHA: GLenum = 0x1906;
    pub const GL_ALREADY_SIGNALED: GLenum = 0x911A;
    pub const GL_ALWAYS: GLenum = 0x0207;
    pub const GL_AND: GLenum = 0x1501;
    pub const GL_AND_INVERTED: GLenum = 0x1504;
    pub const GL_AND_REVERSE: GLenum = 0x1502;
    pub const GL_ANY_SAMPLES_PASSED: GLenum = 0x8C2F;
    pub const GL_ANY_SAMPLES_PASSED_CONSERVATIVE: GLenum = 0x8D6A;
    pub const GL_ARRAY_BUFFER: GLenum = 0x8892;
    pub const GL_ARRAY_BUFFER_BINDING: GLenum = 0x8894;
    pub const GL_ARRAY_SIZE: GLenum = 0x92FB;
    pub const GL_ARRAY_STRIDE: GLenum = 0x92FE;
    pub const GL_ATOMIC_COUNTER_BARRIER_BIT: GLbitfield = 0x00001000;
    pub const GL_ATOMIC_COUNTER_BUFFER: GLenum = 0x92C0;
    pub const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS: GLenum = 0x92C5;
    pub const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES: GLenum = 0x92C6;
    pub const GL_ATOMIC_COUNTER_BUFFER_BINDING: GLenum = 0x92C1;
    pub const GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE: GLenum = 0x92C4;
    pub const GL_ATOMIC_COUNTER_BUFFER_INDEX: GLenum = 0x9301;
    pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x90ED;
    pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x92CB;
    pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x92CA;
    pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x92C8;
    pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x92C9;
    pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x92C7;
    pub const GL_ATOMIC_COUNTER_BUFFER_SIZE: GLenum = 0x92C3;
    pub const GL_ATOMIC_COUNTER_BUFFER_START: GLenum = 0x92C2;
    pub const GL_ATTACHED_SHADERS: GLenum = 0x8B85;
    pub const GL_AUTO_GENERATE_MIPMAP: GLenum = 0x8295;
    pub const GL_BACK: GLenum = 0x0405;
    pub const GL_BACK_LEFT: GLenum = 0x0402;
    pub const GL_BACK_RIGHT: GLenum = 0x0403;
    pub const GL_BGR: GLenum = 0x80E0;
    pub const GL_BGRA: GLenum = 0x80E1;
    pub const GL_BGRA_INTEGER: GLenum = 0x8D9B;
    pub const GL_BGR_INTEGER: GLenum = 0x8D9A;
    pub const GL_BLEND: GLenum = 0x0BE2;
    pub const GL_BLEND_COLOR: GLenum = 0x8005;
    pub const GL_BLEND_DST: GLenum = 0x0BE0;
    pub const GL_BLEND_DST_ALPHA: GLenum = 0x80CA;
    pub const GL_BLEND_DST_RGB: GLenum = 0x80C8;
    pub const GL_BLEND_EQUATION: GLenum = 0x8009;
    pub const GL_BLEND_EQUATION_ALPHA: GLenum = 0x883D;
    pub const GL_BLEND_EQUATION_RGB: GLenum = 0x8009;
    pub const GL_BLEND_SRC: GLenum = 0x0BE1;
    pub const GL_BLEND_SRC_ALPHA: GLenum = 0x80CB;
    pub const GL_BLEND_SRC_RGB: GLenum = 0x80C9;
    pub const GL_BLOCK_INDEX: GLenum = 0x92FD;
    pub const GL_BLUE: GLenum = 0x1905;
    pub const GL_BLUE_INTEGER: GLenum = 0x8D96;
    pub const GL_BOOL: GLenum = 0x8B56;
    pub const GL_BOOL_VEC2: GLenum = 0x8B57;
    pub const GL_BOOL_VEC3: GLenum = 0x8B58;
    pub const GL_BOOL_VEC4: GLenum = 0x8B59;
    pub const GL_BUFFER: GLenum = 0x82E0;
    pub const GL_BUFFER_ACCESS: GLenum = 0x88BB;
    pub const GL_BUFFER_ACCESS_FLAGS: GLenum = 0x911F;
    pub const GL_BUFFER_BINDING: GLenum = 0x9302;
    pub const GL_BUFFER_DATA_SIZE: GLenum = 0x9303;
    pub const GL_BUFFER_IMMUTABLE_STORAGE: GLenum = 0x821F;
    pub const GL_BUFFER_MAPPED: GLenum = 0x88BC;
    pub const GL_BUFFER_MAP_LENGTH: GLenum = 0x9120;
    pub const GL_BUFFER_MAP_OFFSET: GLenum = 0x9121;
    pub const GL_BUFFER_MAP_POINTER: GLenum = 0x88BD;
    pub const GL_BUFFER_SIZE: GLenum = 0x8764;
    pub const GL_BUFFER_STORAGE_FLAGS: GLenum = 0x8220;
    pub const GL_BUFFER_UPDATE_BARRIER_BIT: GLbitfield = 0x00000200;
    pub const GL_BUFFER_USAGE: GLenum = 0x8765;
    pub const GL_BUFFER_VARIABLE: GLenum = 0x92E5;
    pub const GL_BYTE: GLenum = 0x1400;
    pub const GL_CAVEAT_SUPPORT: GLenum = 0x82B8;
    pub const GL_CCW: GLenum = 0x0901;
    pub const GL_CLAMP_READ_COLOR: GLenum = 0x891C;
    pub const GL_CLAMP_TO_BORDER: GLenum = 0x812D;
    pub const GL_CLAMP_TO_EDGE: GLenum = 0x812F;
    pub const GL_CLEAR: GLenum = 0x1500;
    pub const GL_CLEAR_BUFFER: GLenum = 0x82B4;
    pub const GL_CLEAR_TEXTURE: GLenum = 0x9365;
    pub const GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT: GLbitfield = 0x00004000;
    pub const GL_CLIENT_STORAGE_BIT: GLbitfield = 0x0200;
    pub const GL_CLIPPING_INPUT_PRIMITIVES: GLenum = 0x82F6;
    pub const GL_CLIPPING_OUTPUT_PRIMITIVES: GLenum = 0x82F7;
    pub const GL_CLIP_DEPTH_MODE: GLenum = 0x935D;

    pub const GL_CLIP_DISTANCE0: GLenum = 0x3000;

    pub const GL_CLIP_DISTANCE1: GLenum = 0x3001;

    pub const GL_CLIP_DISTANCE2: GLenum = 0x3002;

    pub const GL_CLIP_DISTANCE3: GLenum = 0x3003;

    pub const GL_CLIP_DISTANCE4: GLenum = 0x3004;

    pub const GL_CLIP_DISTANCE5: GLenum = 0x3005;
    pub const GL_CLIP_DISTANCE6: GLenum = 0x3006;
    pub const GL_CLIP_DISTANCE7: GLenum = 0x3007;
    pub const GL_CLIP_ORIGIN: GLenum = 0x935C;
    pub const GL_COLOR: GLenum = 0x1800;
    pub const GL_COLOR_ATTACHMENT0: GLenum = 0x8CE0;
    pub const GL_COLOR_ATTACHMENT1: GLenum = 0x8CE1;
    pub const GL_COLOR_ATTACHMENT10: GLenum = 0x8CEA;
    pub const GL_COLOR_ATTACHMENT11: GLenum = 0x8CEB;
    pub const GL_COLOR_ATTACHMENT12: GLenum = 0x8CEC;
    pub const GL_COLOR_ATTACHMENT13: GLenum = 0x8CED;
    pub const GL_COLOR_ATTACHMENT14: GLenum = 0x8CEE;
    pub const GL_COLOR_ATTACHMENT15: GLenum = 0x8CEF;
    pub const GL_COLOR_ATTACHMENT16: GLenum = 0x8CF0;
    pub const GL_COLOR_ATTACHMENT17: GLenum = 0x8CF1;
    pub const GL_COLOR_ATTACHMENT18: GLenum = 0x8CF2;
    pub const GL_COLOR_ATTACHMENT19: GLenum = 0x8CF3;
    pub const GL_COLOR_ATTACHMENT2: GLenum = 0x8CE2;
    pub const GL_COLOR_ATTACHMENT20: GLenum = 0x8CF4;
    pub const GL_COLOR_ATTACHMENT21: GLenum = 0x8CF5;
    pub const GL_COLOR_ATTACHMENT22: GLenum = 0x8CF6;
    pub const GL_COLOR_ATTACHMENT23: GLenum = 0x8CF7;
    pub const GL_COLOR_ATTACHMENT24: GLenum = 0x8CF8;
    pub const GL_COLOR_ATTACHMENT25: GLenum = 0x8CF9;
    pub const GL_COLOR_ATTACHMENT26: GLenum = 0x8CFA;
    pub const GL_COLOR_ATTACHMENT27: GLenum = 0x8CFB;
    pub const GL_COLOR_ATTACHMENT28: GLenum = 0x8CFC;
    pub const GL_COLOR_ATTACHMENT29: GLenum = 0x8CFD;
    pub const GL_COLOR_ATTACHMENT3: GLenum = 0x8CE3;
    pub const GL_COLOR_ATTACHMENT30: GLenum = 0x8CFE;
    pub const GL_COLOR_ATTACHMENT31: GLenum = 0x8CFF;
    pub const GL_COLOR_ATTACHMENT4: GLenum = 0x8CE4;
    pub const GL_COLOR_ATTACHMENT5: GLenum = 0x8CE5;
    pub const GL_COLOR_ATTACHMENT6: GLenum = 0x8CE6;
    pub const GL_COLOR_ATTACHMENT7: GLenum = 0x8CE7;
    pub const GL_COLOR_ATTACHMENT8: GLenum = 0x8CE8;
    pub const GL_COLOR_ATTACHMENT9: GLenum = 0x8CE9;
    pub const GL_COLOR_BUFFER_BIT: GLbitfield = 0x00004000;
    pub const GL_COLOR_CLEAR_VALUE: GLenum = 0x0C22;
    pub const GL_COLOR_COMPONENTS: GLenum = 0x8283;
    pub const GL_COLOR_ENCODING: GLenum = 0x8296;
    pub const GL_COLOR_LOGIC_OP: GLenum = 0x0BF2;
    pub const GL_COLOR_RENDERABLE: GLenum = 0x8286;
    pub const GL_COLOR_WRITEMASK: GLenum = 0x0C23;
    pub const GL_COMMAND_BARRIER_BIT: GLbitfield = 0x00000040;

    pub const GL_COMPARE_REF_TO_TEXTURE: GLenum = 0x884E;
    pub const GL_COMPATIBLE_SUBROUTINES: GLenum = 0x8E4B;
    pub const GL_COMPILE_STATUS: GLenum = 0x8B81;
    pub const GL_COMPRESSED_R11_EAC: GLenum = 0x9270;
    pub const GL_COMPRESSED_RED: GLenum = 0x8225;
    pub const GL_COMPRESSED_RED_RGTC1: GLenum = 0x8DBB;
    pub const GL_COMPRESSED_RG: GLenum = 0x8226;
    pub const GL_COMPRESSED_RG11_EAC: GLenum = 0x9272;
    pub const GL_COMPRESSED_RGB: GLenum = 0x84ED;
    pub const GL_COMPRESSED_RGB8_ETC2: GLenum = 0x9274;
    pub const GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum = 0x9276;
    pub const GL_COMPRESSED_RGBA: GLenum = 0x84EE;
    pub const GL_COMPRESSED_RGBA8_ETC2_EAC: GLenum = 0x9278;
    pub const GL_COMPRESSED_RGBA_BPTC_UNORM: GLenum = 0x8E8C;
    pub const GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: GLenum = 0x8E8E;
    pub const GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: GLenum = 0x8E8F;
    pub const GL_COMPRESSED_RG_RGTC2: GLenum = 0x8DBD;
    pub const GL_COMPRESSED_SIGNED_R11_EAC: GLenum = 0x9271;
    pub const GL_COMPRESSED_SIGNED_RED_RGTC1: GLenum = 0x8DBC;
    pub const GL_COMPRESSED_SIGNED_RG11_EAC: GLenum = 0x9273;
    pub const GL_COMPRESSED_SIGNED_RG_RGTC2: GLenum = 0x8DBE;
    pub const GL_COMPRESSED_SRGB: GLenum = 0x8C48;
    pub const GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: GLenum = 0x9279;
    pub const GL_COMPRESSED_SRGB8_ETC2: GLenum = 0x9275;
    pub const GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum = 0x9277;
    pub const GL_COMPRESSED_SRGB_ALPHA: GLenum = 0x8C49;
    pub const GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM: GLenum = 0x8E8D;
    pub const GL_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A3;
    pub const GL_COMPUTE_SHADER: GLenum = 0x91B9;
    pub const GL_COMPUTE_SHADER_BIT: GLbitfield = 0x00000020;
    pub const GL_COMPUTE_SHADER_INVOCATIONS: GLenum = 0x82F5;
    pub const GL_COMPUTE_SUBROUTINE: GLenum = 0x92ED;
    pub const GL_COMPUTE_SUBROUTINE_UNIFORM: GLenum = 0x92F3;
    pub const GL_COMPUTE_TEXTURE: GLenum = 0x82A0;
    pub const GL_COMPUTE_WORK_GROUP_SIZE: GLenum = 0x8267;
    pub const GL_CONDITION_SATISFIED: GLenum = 0x911C;
    pub const GL_CONSTANT_ALPHA: GLenum = 0x8003;
    pub const GL_CONSTANT_COLOR: GLenum = 0x8001;
    pub const GL_CONTEXT_COMPATIBILITY_PROFILE_BIT: GLbitfield = 0x00000002;
    pub const GL_CONTEXT_CORE_PROFILE_BIT: GLbitfield = 0x00000001;
    pub const GL_CONTEXT_FLAGS: GLenum = 0x821E;
    pub const GL_CONTEXT_FLAG_DEBUG_BIT: GLbitfield = 0x00000002;
    pub const GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: GLbitfield = 0x00000001;
    pub const GL_CONTEXT_FLAG_NO_ERROR_BIT: GLbitfield = 0x00000008;
    pub const GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT: GLbitfield = 0x00000004;
    pub const GL_CONTEXT_LOST: GLenum = 0x0507;
    pub const GL_CONTEXT_PROFILE_MASK: GLenum = 0x9126;
    pub const GL_CONTEXT_RELEASE_BEHAVIOR: GLenum = 0x82FB;
    pub const GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: GLenum = 0x82FC;
    pub const GL_COPY: GLenum = 0x1503;
    pub const GL_COPY_INVERTED: GLenum = 0x150C;
    pub const GL_COPY_READ_BUFFER: GLenum = 0x8F36;
    pub const GL_COPY_READ_BUFFER_BINDING: GLenum = 0x8F36;
    pub const GL_COPY_WRITE_BUFFER: GLenum = 0x8F37;
    pub const GL_COPY_WRITE_BUFFER_BINDING: GLenum = 0x8F37;
    pub const GL_CULL_FACE: GLenum = 0x0B44;
    pub const GL_CULL_FACE_MODE: GLenum = 0x0B45;
    pub const GL_CURRENT_PROGRAM: GLenum = 0x8B8D;
    pub const GL_CURRENT_QUERY: GLenum = 0x8865;
    pub const GL_CURRENT_VERTEX_ATTRIB: GLenum = 0x8626;
    pub const GL_CW: GLenum = 0x0900;
    pub const GL_DEBUG_CALLBACK_FUNCTION: GLenum = 0x8244;
    pub const GL_DEBUG_CALLBACK_USER_PARAM: GLenum = 0x8245;
    pub const GL_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826D;
    pub const GL_DEBUG_LOGGED_MESSAGES: GLenum = 0x9145;
    pub const GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: GLenum = 0x8243;
    pub const GL_DEBUG_OUTPUT: GLenum = 0x92E0;
    pub const GL_DEBUG_OUTPUT_SYNCHRONOUS: GLenum = 0x8242;
    pub const GL_DEBUG_SEVERITY_HIGH: GLenum = 0x9146;
    pub const GL_DEBUG_SEVERITY_LOW: GLenum = 0x9148;
    pub const GL_DEBUG_SEVERITY_MEDIUM: GLenum = 0x9147;
    pub const GL_DEBUG_SEVERITY_NOTIFICATION: GLenum = 0x826B;
    pub const GL_DEBUG_SOURCE_API: GLenum = 0x8246;
    pub const GL_DEBUG_SOURCE_APPLICATION: GLenum = 0x824A;
    pub const GL_DEBUG_SOURCE_OTHER: GLenum = 0x824B;
    pub const GL_DEBUG_SOURCE_SHADER_COMPILER: GLenum = 0x8248;
    pub const GL_DEBUG_SOURCE_THIRD_PARTY: GLenum = 0x8249;
    pub const GL_DEBUG_SOURCE_WINDOW_SYSTEM: GLenum = 0x8247;
    pub const GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: GLenum = 0x824D;
    pub const GL_DEBUG_TYPE_ERROR: GLenum = 0x824C;
    pub const GL_DEBUG_TYPE_MARKER: GLenum = 0x8268;
    pub const GL_DEBUG_TYPE_OTHER: GLenum = 0x8251;
    pub const GL_DEBUG_TYPE_PERFORMANCE: GLenum = 0x8250;
    pub const GL_DEBUG_TYPE_POP_GROUP: GLenum = 0x826A;
    pub const GL_DEBUG_TYPE_PORTABILITY: GLenum = 0x824F;
    pub const GL_DEBUG_TYPE_PUSH_GROUP: GLenum = 0x8269;
    pub const GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: GLenum = 0x824E;
    pub const GL_DECR: GLenum = 0x1E03;
    pub const GL_DECR_WRAP: GLenum = 0x8508;
    pub const GL_DELETE_STATUS: GLenum = 0x8B80;
    pub const GL_DEPTH: GLenum = 0x1801;
    pub const GL_DEPTH24_STENCIL8: GLenum = 0x88F0;
    pub const GL_DEPTH32F_STENCIL8: GLenum = 0x8CAD;
    pub const GL_DEPTH_ATTACHMENT: GLenum = 0x8D00;
    pub const GL_DEPTH_BUFFER_BIT: GLbitfield = 0x00000100;
    pub const GL_DEPTH_CLAMP: GLenum = 0x864F;
    pub const GL_DEPTH_CLEAR_VALUE: GLenum = 0x0B73;
    pub const GL_DEPTH_COMPONENT: GLenum = 0x1902;
    pub const GL_DEPTH_COMPONENT16: GLenum = 0x81A5;
    pub const GL_DEPTH_COMPONENT24: GLenum = 0x81A6;
    pub const GL_DEPTH_COMPONENT32: GLenum = 0x81A7;
    pub const GL_DEPTH_COMPONENT32F: GLenum = 0x8CAC;
    pub const GL_DEPTH_COMPONENTS: GLenum = 0x8284;
    pub const GL_DEPTH_FUNC: GLenum = 0x0B74;
    pub const GL_DEPTH_RANGE: GLenum = 0x0B70;
    pub const GL_DEPTH_RENDERABLE: GLenum = 0x8287;
    pub const GL_DEPTH_STENCIL: GLenum = 0x84F9;
    pub const GL_DEPTH_STENCIL_ATTACHMENT: GLenum = 0x821A;
    pub const GL_DEPTH_STENCIL_TEXTURE_MODE: GLenum = 0x90EA;
    pub const GL_DEPTH_TEST: GLenum = 0x0B71;
    pub const GL_DEPTH_WRITEMASK: GLenum = 0x0B72;
    pub const GL_DISPATCH_INDIRECT_BUFFER: GLenum = 0x90EE;
    pub const GL_DISPATCH_INDIRECT_BUFFER_BINDING: GLenum = 0x90EF;
    pub const GL_DITHER: GLenum = 0x0BD0;
    pub const GL_DONT_CARE: GLenum = 0x1100;
    pub const GL_DOUBLE: GLenum = 0x140A;
    pub const GL_DOUBLEBUFFER: GLenum = 0x0C32;
    pub const GL_DOUBLE_MAT2: GLenum = 0x8F46;
    pub const GL_DOUBLE_MAT2x3: GLenum = 0x8F49;
    pub const GL_DOUBLE_MAT2x4: GLenum = 0x8F4A;
    pub const GL_DOUBLE_MAT3: GLenum = 0x8F47;
    pub const GL_DOUBLE_MAT3x2: GLenum = 0x8F4B;
    pub const GL_DOUBLE_MAT3x4: GLenum = 0x8F4C;
    pub const GL_DOUBLE_MAT4: GLenum = 0x8F48;
    pub const GL_DOUBLE_MAT4x2: GLenum = 0x8F4D;
    pub const GL_DOUBLE_MAT4x3: GLenum = 0x8F4E;
    pub const GL_DOUBLE_VEC2: GLenum = 0x8FFC;
    pub const GL_DOUBLE_VEC3: GLenum = 0x8FFD;
    pub const GL_DOUBLE_VEC4: GLenum = 0x8FFE;
    pub const GL_DRAW_BUFFER: GLenum = 0x0C01;
    pub const GL_DRAW_BUFFER0: GLenum = 0x8825;
    pub const GL_DRAW_BUFFER1: GLenum = 0x8826;
    pub const GL_DRAW_BUFFER10: GLenum = 0x882F;
    pub const GL_DRAW_BUFFER11: GLenum = 0x8830;
    pub const GL_DRAW_BUFFER12: GLenum = 0x8831;
    pub const GL_DRAW_BUFFER13: GLenum = 0x8832;
    pub const GL_DRAW_BUFFER14: GLenum = 0x8833;
    pub const GL_DRAW_BUFFER15: GLenum = 0x8834;
    pub const GL_DRAW_BUFFER2: GLenum = 0x8827;
    pub const GL_DRAW_BUFFER3: GLenum = 0x8828;
    pub const GL_DRAW_BUFFER4: GLenum = 0x8829;
    pub const GL_DRAW_BUFFER5: GLenum = 0x882A;
    pub const GL_DRAW_BUFFER6: GLenum = 0x882B;
    pub const GL_DRAW_BUFFER7: GLenum = 0x882C;
    pub const GL_DRAW_BUFFER8: GLenum = 0x882D;
    pub const GL_DRAW_BUFFER9: GLenum = 0x882E;
    pub const GL_DRAW_FRAMEBUFFER: GLenum = 0x8CA9;
    pub const GL_DRAW_FRAMEBUFFER_BINDING: GLenum = 0x8CA6;
    pub const GL_DRAW_INDIRECT_BUFFER: GLenum = 0x8F3F;
    pub const GL_DRAW_INDIRECT_BUFFER_BINDING: GLenum = 0x8F43;
    pub const GL_DST_ALPHA: GLenum = 0x0304;
    pub const GL_DST_COLOR: GLenum = 0x0306;
    pub const GL_DYNAMIC_COPY: GLenum = 0x88EA;
    pub const GL_DYNAMIC_DRAW: GLenum = 0x88E8;
    pub const GL_DYNAMIC_READ: GLenum = 0x88E9;
    pub const GL_DYNAMIC_STORAGE_BIT: GLbitfield = 0x0100;
    pub const GL_ELEMENT_ARRAY_BARRIER_BIT: GLbitfield = 0x00000002;
    pub const GL_ELEMENT_ARRAY_BUFFER: GLenum = 0x8893;
    pub const GL_ELEMENT_ARRAY_BUFFER_BINDING: GLenum = 0x8895;
    pub const GL_EQUAL: GLenum = 0x0202;
    pub const GL_EQUIV: GLenum = 0x1509;
    pub const GL_EXTENSIONS: GLenum = 0x1F03;
    pub const GL_FALSE: GLenum = 0;
    pub const GL_FASTEST: GLenum = 0x1101;
    pub const GL_FILL: GLenum = 0x1B02;
    pub const GL_FILTER: GLenum = 0x829A;
    pub const GL_FIRST_VERTEX_CONVENTION: GLenum = 0x8E4D;
    pub const GL_FIXED: GLenum = 0x140C;
    pub const GL_FIXED_ONLY: GLenum = 0x891D;
    pub const GL_FLOAT: GLenum = 0x1406;
    pub const GL_FLOAT_32_UNSIGNED_INT_24_8_REV: GLenum = 0x8DAD;
    pub const GL_FLOAT_MAT2: GLenum = 0x8B5A;
    pub const GL_FLOAT_MAT2x3: GLenum = 0x8B65;
    pub const GL_FLOAT_MAT2x4: GLenum = 0x8B66;
    pub const GL_FLOAT_MAT3: GLenum = 0x8B5B;
    pub const GL_FLOAT_MAT3x2: GLenum = 0x8B67;
    pub const GL_FLOAT_MAT3x4: GLenum = 0x8B68;
    pub const GL_FLOAT_MAT4: GLenum = 0x8B5C;
    pub const GL_FLOAT_MAT4x2: GLenum = 0x8B69;
    pub const GL_FLOAT_MAT4x3: GLenum = 0x8B6A;
    pub const GL_FLOAT_VEC2: GLenum = 0x8B50;
    pub const GL_FLOAT_VEC3: GLenum = 0x8B51;
    pub const GL_FLOAT_VEC4: GLenum = 0x8B52;
    pub const GL_FRACTIONAL_EVEN: GLenum = 0x8E7C;
    pub const GL_FRACTIONAL_ODD: GLenum = 0x8E7B;
    pub const GL_FRAGMENT_INTERPOLATION_OFFSET_BITS: GLenum = 0x8E5D;
    pub const GL_FRAGMENT_SHADER: GLenum = 0x8B30;
    pub const GL_FRAGMENT_SHADER_BIT: GLbitfield = 0x00000002;
    pub const GL_FRAGMENT_SHADER_DERIVATIVE_HINT: GLenum = 0x8B8B;
    pub const GL_FRAGMENT_SHADER_INVOCATIONS: GLenum = 0x82F4;
    pub const GL_FRAGMENT_SUBROUTINE: GLenum = 0x92EC;
    pub const GL_FRAGMENT_SUBROUTINE_UNIFORM: GLenum = 0x92F2;
    pub const GL_FRAGMENT_TEXTURE: GLenum = 0x829F;
    pub const GL_FRAMEBUFFER: GLenum = 0x8D40;
    pub const GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: GLenum = 0x8215;
    pub const GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: GLenum = 0x8214;
    pub const GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: GLenum = 0x8210;
    pub const GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: GLenum = 0x8211;
    pub const GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: GLenum = 0x8216;
    pub const GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: GLenum = 0x8213;
    pub const GL_FRAMEBUFFER_ATTACHMENT_LAYERED: GLenum = 0x8DA7;
    pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum = 0x8CD1;
    pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum = 0x8CD0;
    pub const GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE: GLenum = 0x8212;
    pub const GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: GLenum = 0x8217;
    pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum = 0x8CD3;
    pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: GLenum = 0x8CD4;
    pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum = 0x8CD2;
    pub const GL_FRAMEBUFFER_BARRIER_BIT: GLbitfield = 0x00000400;
    pub const GL_FRAMEBUFFER_BINDING: GLenum = 0x8CA6;
    pub const GL_FRAMEBUFFER_BLEND: GLenum = 0x828B;
    pub const GL_FRAMEBUFFER_COMPLETE: GLenum = 0x8CD5;
    pub const GL_FRAMEBUFFER_DEFAULT: GLenum = 0x8218;
    pub const GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9314;
    pub const GL_FRAMEBUFFER_DEFAULT_HEIGHT: GLenum = 0x9311;
    pub const GL_FRAMEBUFFER_DEFAULT_LAYERS: GLenum = 0x9312;
    pub const GL_FRAMEBUFFER_DEFAULT_SAMPLES: GLenum = 0x9313;
    pub const GL_FRAMEBUFFER_DEFAULT_WIDTH: GLenum = 0x9310;
    pub const GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum = 0x8CD6;
    pub const GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: GLenum = 0x8CDB;
    pub const GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: GLenum = 0x8DA8;
    pub const GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum = 0x8CD7;
    pub const GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: GLenum = 0x8D56;
    pub const GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER: GLenum = 0x8CDC;
    pub const GL_FRAMEBUFFER_RENDERABLE: GLenum = 0x8289;
    pub const GL_FRAMEBUFFER_RENDERABLE_LAYERED: GLenum = 0x828A;
    pub const GL_FRAMEBUFFER_SRGB: GLenum = 0x8DB9;
    pub const GL_FRAMEBUFFER_UNDEFINED: GLenum = 0x8219;
    pub const GL_FRAMEBUFFER_UNSUPPORTED: GLenum = 0x8CDD;
    pub const GL_FRONT: GLenum = 0x0404;
    pub const GL_FRONT_AND_BACK: GLenum = 0x0408;
    pub const GL_FRONT_FACE: GLenum = 0x0B46;
    pub const GL_FRONT_LEFT: GLenum = 0x0400;
    pub const GL_FRONT_RIGHT: GLenum = 0x0401;
    pub const GL_FULL_SUPPORT: GLenum = 0x82B7;
    pub const GL_FUNC_ADD: GLenum = 0x8006;
    pub const GL_FUNC_REVERSE_SUBTRACT: GLenum = 0x800B;
    pub const GL_FUNC_SUBTRACT: GLenum = 0x800A;
    pub const GL_GEOMETRY_INPUT_TYPE: GLenum = 0x8917;
    pub const GL_GEOMETRY_OUTPUT_TYPE: GLenum = 0x8918;
    pub const GL_GEOMETRY_SHADER: GLenum = 0x8DD9;
    pub const GL_GEOMETRY_SHADER_BIT: GLbitfield = 0x00000004;
    pub const GL_GEOMETRY_SHADER_INVOCATIONS: GLenum = 0x887F;
    pub const GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED: GLenum = 0x82F3;
    pub const GL_GEOMETRY_SUBROUTINE: GLenum = 0x92EB;
    pub const GL_GEOMETRY_SUBROUTINE_UNIFORM: GLenum = 0x92F1;
    pub const GL_GEOMETRY_TEXTURE: GLenum = 0x829E;
    pub const GL_GEOMETRY_VERTICES_OUT: GLenum = 0x8916;
    pub const GL_GEQUAL: GLenum = 0x0206;
    pub const GL_GET_TEXTURE_IMAGE_FORMAT: GLenum = 0x8291;
    pub const GL_GET_TEXTURE_IMAGE_TYPE: GLenum = 0x8292;
    pub const GL_GREATER: GLenum = 0x0204;
    pub const GL_GREEN: GLenum = 0x1904;
    pub const GL_GREEN_INTEGER: GLenum = 0x8D95;
    pub const GL_GUILTY_CONTEXT_RESET: GLenum = 0x8253;
    pub const GL_HALF_FLOAT: GLenum = 0x140B;
    pub const GL_HIGH_FLOAT: GLenum = 0x8DF2;
    pub const GL_HIGH_INT: GLenum = 0x8DF5;
    pub const GL_IMAGE_1D: GLenum = 0x904C;
    pub const GL_IMAGE_1D_ARRAY: GLenum = 0x9052;
    pub const GL_IMAGE_2D: GLenum = 0x904D;
    pub const GL_IMAGE_2D_ARRAY: GLenum = 0x9053;
    pub const GL_IMAGE_2D_MULTISAMPLE: GLenum = 0x9055;
    pub const GL_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9056;
    pub const GL_IMAGE_2D_RECT: GLenum = 0x904F;
    pub const GL_IMAGE_3D: GLenum = 0x904E;
    pub const GL_IMAGE_BINDING_ACCESS: GLenum = 0x8F3E;
    pub const GL_IMAGE_BINDING_FORMAT: GLenum = 0x906E;
    pub const GL_IMAGE_BINDING_LAYER: GLenum = 0x8F3D;
    pub const GL_IMAGE_BINDING_LAYERED: GLenum = 0x8F3C;
    pub const GL_IMAGE_BINDING_LEVEL: GLenum = 0x8F3B;
    pub const GL_IMAGE_BINDING_NAME: GLenum = 0x8F3A;
    pub const GL_IMAGE_BUFFER: GLenum = 0x9051;
    pub const GL_IMAGE_CLASS_10_10_10_2: GLenum = 0x82C3;
    pub const GL_IMAGE_CLASS_11_11_10: GLenum = 0x82C2;
    pub const GL_IMAGE_CLASS_1_X_16: GLenum = 0x82BE;
    pub const GL_IMAGE_CLASS_1_X_32: GLenum = 0x82BB;
    pub const GL_IMAGE_CLASS_1_X_8: GLenum = 0x82C1;
    pub const GL_IMAGE_CLASS_2_X_16: GLenum = 0x82BD;
    pub const GL_IMAGE_CLASS_2_X_32: GLenum = 0x82BA;
    pub const GL_IMAGE_CLASS_2_X_8: GLenum = 0x82C0;
    pub const GL_IMAGE_CLASS_4_X_16: GLenum = 0x82BC;
    pub const GL_IMAGE_CLASS_4_X_32: GLenum = 0x82B9;
    pub const GL_IMAGE_CLASS_4_X_8: GLenum = 0x82BF;
    pub const GL_IMAGE_COMPATIBILITY_CLASS: GLenum = 0x82A8;
    pub const GL_IMAGE_CUBE: GLenum = 0x9050;
    pub const GL_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x9054;
    pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS: GLenum = 0x90C9;
    pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE: GLenum = 0x90C8;
    pub const GL_IMAGE_FORMAT_COMPATIBILITY_TYPE: GLenum = 0x90C7;
    pub const GL_IMAGE_PIXEL_FORMAT: GLenum = 0x82A9;
    pub const GL_IMAGE_PIXEL_TYPE: GLenum = 0x82AA;
    pub const GL_IMAGE_TEXEL_SIZE: GLenum = 0x82A7;
    pub const GL_IMPLEMENTATION_COLOR_READ_FORMAT: GLenum = 0x8B9B;
    pub const GL_IMPLEMENTATION_COLOR_READ_TYPE: GLenum = 0x8B9A;
    pub const GL_INCR: GLenum = 0x1E02;
    pub const GL_INCR_WRAP: GLenum = 0x8507;
    pub const GL_INFO_LOG_LENGTH: GLenum = 0x8B84;
    pub const GL_INNOCENT_CONTEXT_RESET: GLenum = 0x8254;
    pub const GL_INT: GLenum = 0x1404;
    pub const GL_INTERLEAVED_ATTRIBS: GLenum = 0x8C8C;
    pub const GL_INTERNALFORMAT_ALPHA_SIZE: GLenum = 0x8274;
    pub const GL_INTERNALFORMAT_ALPHA_TYPE: GLenum = 0x827B;
    pub const GL_INTERNALFORMAT_BLUE_SIZE: GLenum = 0x8273;
    pub const GL_INTERNALFORMAT_BLUE_TYPE: GLenum = 0x827A;
    pub const GL_INTERNALFORMAT_DEPTH_SIZE: GLenum = 0x8275;
    pub const GL_INTERNALFORMAT_DEPTH_TYPE: GLenum = 0x827C;
    pub const GL_INTERNALFORMAT_GREEN_SIZE: GLenum = 0x8272;
    pub const GL_INTERNALFORMAT_GREEN_TYPE: GLenum = 0x8279;
    pub const GL_INTERNALFORMAT_PREFERRED: GLenum = 0x8270;
    pub const GL_INTERNALFORMAT_RED_SIZE: GLenum = 0x8271;
    pub const GL_INTERNALFORMAT_RED_TYPE: GLenum = 0x8278;
    pub const GL_INTERNALFORMAT_SHARED_SIZE: GLenum = 0x8277;
    pub const GL_INTERNALFORMAT_STENCIL_SIZE: GLenum = 0x8276;
    pub const GL_INTERNALFORMAT_STENCIL_TYPE: GLenum = 0x827D;
    pub const GL_INTERNALFORMAT_SUPPORTED: GLenum = 0x826F;
    pub const GL_INT_2_10_10_10_REV: GLenum = 0x8D9F;
    pub const GL_INT_IMAGE_1D: GLenum = 0x9057;
    pub const GL_INT_IMAGE_1D_ARRAY: GLenum = 0x905D;
    pub const GL_INT_IMAGE_2D: GLenum = 0x9058;
    pub const GL_INT_IMAGE_2D_ARRAY: GLenum = 0x905E;
    pub const GL_INT_IMAGE_2D_MULTISAMPLE: GLenum = 0x9060;
    pub const GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9061;
    pub const GL_INT_IMAGE_2D_RECT: GLenum = 0x905A;
    pub const GL_INT_IMAGE_3D: GLenum = 0x9059;
    pub const GL_INT_IMAGE_BUFFER: GLenum = 0x905C;
    pub const GL_INT_IMAGE_CUBE: GLenum = 0x905B;
    pub const GL_INT_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x905F;
    pub const GL_INT_SAMPLER_1D: GLenum = 0x8DC9;
    pub const GL_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DCE;
    pub const GL_INT_SAMPLER_2D: GLenum = 0x8DCA;
    pub const GL_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DCF;
    pub const GL_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9109;
    pub const GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910C;
    pub const GL_INT_SAMPLER_2D_RECT: GLenum = 0x8DCD;
    pub const GL_INT_SAMPLER_3D: GLenum = 0x8DCB;
    pub const GL_INT_SAMPLER_BUFFER: GLenum = 0x8DD0;
    pub const GL_INT_SAMPLER_CUBE: GLenum = 0x8DCC;
    pub const GL_INT_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900E;
    pub const GL_INT_VEC2: GLenum = 0x8B53;
    pub const GL_INT_VEC3: GLenum = 0x8B54;
    pub const GL_INT_VEC4: GLenum = 0x8B55;
    pub const GL_INVALID_ENUM: GLenum = 0x0500;
    pub const GL_INVALID_FRAMEBUFFER_OPERATION: GLenum = 0x0506;
    pub const GL_INVALID_INDEX: GLenum = 0xFFFFFFFF;
    pub const GL_INVALID_OPERATION: GLenum = 0x0502;
    pub const GL_INVALID_VALUE: GLenum = 0x0501;
    pub const GL_INVERT: GLenum = 0x150A;
    pub const GL_ISOLINES: GLenum = 0x8E7A;
    pub const GL_IS_PER_PATCH: GLenum = 0x92E7;
    pub const GL_IS_ROW_MAJOR: GLenum = 0x9300;
    pub const GL_KEEP: GLenum = 0x1E00;
    pub const GL_LAST_VERTEX_CONVENTION: GLenum = 0x8E4E;
    pub const GL_LAYER_PROVOKING_VERTEX: GLenum = 0x825E;
    pub const GL_LEFT: GLenum = 0x0406;
    pub const GL_LEQUAL: GLenum = 0x0203;
    pub const GL_LESS: GLenum = 0x0201;
    pub const GL_LINE: GLenum = 0x1B01;
    pub const GL_LINEAR: GLenum = 0x2601;
    pub const GL_LINEAR_MIPMAP_LINEAR: GLenum = 0x2703;
    pub const GL_LINEAR_MIPMAP_NEAREST: GLenum = 0x2701;
    pub const GL_LINES: GLenum = 0x0001;
    pub const GL_LINES_ADJACENCY: GLenum = 0x000A;
    pub const GL_LINE_LOOP: GLenum = 0x0002;
    pub const GL_LINE_SMOOTH: GLenum = 0x0B20;
    pub const GL_LINE_SMOOTH_HINT: GLenum = 0x0C52;
    pub const GL_LINE_STRIP: GLenum = 0x0003;
    pub const GL_LINE_STRIP_ADJACENCY: GLenum = 0x000B;
    pub const GL_LINE_WIDTH: GLenum = 0x0B21;
    pub const GL_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23;
    pub const GL_LINE_WIDTH_RANGE: GLenum = 0x0B22;
    pub const GL_LINK_STATUS: GLenum = 0x8B82;
    pub const GL_LOCATION: GLenum = 0x930E;
    pub const GL_LOCATION_COMPONENT: GLenum = 0x934A;
    pub const GL_LOCATION_INDEX: GLenum = 0x930F;
    pub const GL_LOGIC_OP_MODE: GLenum = 0x0BF0;
    pub const GL_LOSE_CONTEXT_ON_RESET: GLenum = 0x8252;
    pub const GL_LOWER_LEFT: GLenum = 0x8CA1;
    pub const GL_LOW_FLOAT: GLenum = 0x8DF0;
    pub const GL_LOW_INT: GLenum = 0x8DF3;
    pub const GL_MAJOR_VERSION: GLenum = 0x821B;
    pub const GL_MANUAL_GENERATE_MIPMAP: GLenum = 0x8294;
    pub const GL_MAP_COHERENT_BIT: GLbitfield = 0x0080;
    pub const GL_MAP_FLUSH_EXPLICIT_BIT: GLbitfield = 0x0010;
    pub const GL_MAP_INVALIDATE_BUFFER_BIT: GLbitfield = 0x0008;
    pub const GL_MAP_INVALIDATE_RANGE_BIT: GLbitfield = 0x0004;
    pub const GL_MAP_PERSISTENT_BIT: GLbitfield = 0x0040;
    pub const GL_MAP_READ_BIT: GLbitfield = 0x0001;
    pub const GL_MAP_UNSYNCHRONIZED_BIT: GLbitfield = 0x0020;
    pub const GL_MAP_WRITE_BIT: GLbitfield = 0x0002;
    pub const GL_MATRIX_STRIDE: GLenum = 0x92FF;
    pub const GL_MAX: GLenum = 0x8008;
    pub const GL_MAX_3D_TEXTURE_SIZE: GLenum = 0x8073;
    pub const GL_MAX_ARRAY_TEXTURE_LAYERS: GLenum = 0x88FF;
    pub const GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS: GLenum = 0x92DC;
    pub const GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE: GLenum = 0x92D8;

    pub const GL_MAX_CLIP_DISTANCES: GLenum = 0x0D32;
    pub const GL_MAX_COLOR_ATTACHMENTS: GLenum = 0x8CDF;
    pub const GL_MAX_COLOR_TEXTURE_SAMPLES: GLenum = 0x910E;
    pub const GL_MAX_COMBINED_ATOMIC_COUNTERS: GLenum = 0x92D7;
    pub const GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D1;
    pub const GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES: GLenum = 0x82FA;
    pub const GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS: GLenum = 0x8266;
    pub const GL_MAX_COMBINED_DIMENSIONS: GLenum = 0x8282;
    pub const GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8A33;
    pub const GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8A32;
    pub const GL_MAX_COMBINED_IMAGE_UNIFORMS: GLenum = 0x90CF;
    pub const GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS: GLenum = 0x8F39;
    pub const GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES: GLenum = 0x8F39;
    pub const GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS: GLenum = 0x90DC;
    pub const GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS: GLenum = 0x8E1E;
    pub const GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS: GLenum = 0x8E1F;
    pub const GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4D;
    pub const GL_MAX_COMBINED_UNIFORM_BLOCKS: GLenum = 0x8A2E;
    pub const GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8A31;
    pub const GL_MAX_COMPUTE_ATOMIC_COUNTERS: GLenum = 0x8265;
    pub const GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS: GLenum = 0x8264;
    pub const GL_MAX_COMPUTE_IMAGE_UNIFORMS: GLenum = 0x91BD;
    pub const GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS: GLenum = 0x90DB;
    pub const GL_MAX_COMPUTE_SHARED_MEMORY_SIZE: GLenum = 0x8262;
    pub const GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS: GLenum = 0x91BC;
    pub const GL_MAX_COMPUTE_UNIFORM_BLOCKS: GLenum = 0x91BB;
    pub const GL_MAX_COMPUTE_UNIFORM_COMPONENTS: GLenum = 0x8263;
    pub const GL_MAX_COMPUTE_WORK_GROUP_COUNT: GLenum = 0x91BE;
    pub const GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS: GLenum = 0x90EB;
    pub const GL_MAX_COMPUTE_WORK_GROUP_SIZE: GLenum = 0x91BF;
    pub const GL_MAX_CUBE_MAP_TEXTURE_SIZE: GLenum = 0x851C;
    pub const GL_MAX_CULL_DISTANCES: GLenum = 0x82F9;
    pub const GL_MAX_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826C;
    pub const GL_MAX_DEBUG_LOGGED_MESSAGES: GLenum = 0x9144;
    pub const GL_MAX_DEBUG_MESSAGE_LENGTH: GLenum = 0x9143;
    pub const GL_MAX_DEPTH: GLenum = 0x8280;
    pub const GL_MAX_DEPTH_TEXTURE_SAMPLES: GLenum = 0x910F;
    pub const GL_MAX_DRAW_BUFFERS: GLenum = 0x8824;
    pub const GL_MAX_DUAL_SOURCE_DRAW_BUFFERS: GLenum = 0x88FC;
    pub const GL_MAX_ELEMENTS_INDICES: GLenum = 0x80E9;
    pub const GL_MAX_ELEMENTS_VERTICES: GLenum = 0x80E8;
    pub const GL_MAX_ELEMENT_INDEX: GLenum = 0x8D6B;
    pub const GL_MAX_FRAGMENT_ATOMIC_COUNTERS: GLenum = 0x92D6;
    pub const GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D0;
    pub const GL_MAX_FRAGMENT_IMAGE_UNIFORMS: GLenum = 0x90CE;
    pub const GL_MAX_FRAGMENT_INPUT_COMPONENTS: GLenum = 0x9125;
    pub const GL_MAX_FRAGMENT_INTERPOLATION_OFFSET: GLenum = 0x8E5C;
    pub const GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS: GLenum = 0x90DA;
    pub const GL_MAX_FRAGMENT_UNIFORM_BLOCKS: GLenum = 0x8A2D;
    pub const GL_MAX_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8B49;
    pub const GL_MAX_FRAGMENT_UNIFORM_VECTORS: GLenum = 0x8DFD;
    pub const GL_MAX_FRAMEBUFFER_HEIGHT: GLenum = 0x9316;
    pub const GL_MAX_FRAMEBUFFER_LAYERS: GLenum = 0x9317;
    pub const GL_MAX_FRAMEBUFFER_SAMPLES: GLenum = 0x9318;
    pub const GL_MAX_FRAMEBUFFER_WIDTH: GLenum = 0x9315;
    pub const GL_MAX_GEOMETRY_ATOMIC_COUNTERS: GLenum = 0x92D5;
    pub const GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CF;
    pub const GL_MAX_GEOMETRY_IMAGE_UNIFORMS: GLenum = 0x90CD;
    pub const GL_MAX_GEOMETRY_INPUT_COMPONENTS: GLenum = 0x9123;
    pub const GL_MAX_GEOMETRY_OUTPUT_COMPONENTS: GLenum = 0x9124;
    pub const GL_MAX_GEOMETRY_OUTPUT_VERTICES: GLenum = 0x8DE0;
    pub const GL_MAX_GEOMETRY_SHADER_INVOCATIONS: GLenum = 0x8E5A;
    pub const GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS: GLenum = 0x90D7;
    pub const GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: GLenum = 0x8C29;
    pub const GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8DE1;
    pub const GL_MAX_GEOMETRY_UNIFORM_BLOCKS: GLenum = 0x8A2C;
    pub const GL_MAX_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8DDF;
    pub const GL_MAX_HEIGHT: GLenum = 0x827F;
    pub const GL_MAX_IMAGE_SAMPLES: GLenum = 0x906D;
    pub const GL_MAX_IMAGE_UNITS: GLenum = 0x8F38;
    pub const GL_MAX_INTEGER_SAMPLES: GLenum = 0x9110;
    pub const GL_MAX_LABEL_LENGTH: GLenum = 0x82E8;
    pub const GL_MAX_LAYERS: GLenum = 0x8281;
    pub const GL_MAX_NAME_LENGTH: GLenum = 0x92F6;
    pub const GL_MAX_NUM_ACTIVE_VARIABLES: GLenum = 0x92F7;
    pub const GL_MAX_NUM_COMPATIBLE_SUBROUTINES: GLenum = 0x92F8;
    pub const GL_MAX_PATCH_VERTICES: GLenum = 0x8E7D;
    pub const GL_MAX_PROGRAM_TEXEL_OFFSET: GLenum = 0x8905;
    pub const GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET: GLenum = 0x8E5F;
    pub const GL_MAX_RECTANGLE_TEXTURE_SIZE: GLenum = 0x84F8;
    pub const GL_MAX_RENDERBUFFER_SIZE: GLenum = 0x84E8;
    pub const GL_MAX_SAMPLES: GLenum = 0x8D57;
    pub const GL_MAX_SAMPLE_MASK_WORDS: GLenum = 0x8E59;
    pub const GL_MAX_SERVER_WAIT_TIMEOUT: GLenum = 0x9111;
    pub const GL_MAX_SHADER_STORAGE_BLOCK_SIZE: GLenum = 0x90DE;
    pub const GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS: GLenum = 0x90DD;
    pub const GL_MAX_SUBROUTINES: GLenum = 0x8DE7;
    pub const GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS: GLenum = 0x8DE8;
    pub const GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS: GLenum = 0x92D3;
    pub const GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CD;
    pub const GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS: GLenum = 0x90CB;
    pub const GL_MAX_TESS_CONTROL_INPUT_COMPONENTS: GLenum = 0x886C;
    pub const GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS: GLenum = 0x8E83;
    pub const GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS: GLenum = 0x90D8;
    pub const GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS: GLenum = 0x8E81;
    pub const GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8E85;
    pub const GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS: GLenum = 0x8E89;
    pub const GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS: GLenum = 0x8E7F;
    pub const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS: GLenum = 0x92D4;
    pub const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CE;
    pub const GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS: GLenum = 0x90CC;
    pub const GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS: GLenum = 0x886D;
    pub const GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS: GLenum = 0x8E86;
    pub const GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS: GLenum = 0x90D9;
    pub const GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS: GLenum = 0x8E82;
    pub const GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS: GLenum = 0x8E8A;
    pub const GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS: GLenum = 0x8E80;
    pub const GL_MAX_TESS_GEN_LEVEL: GLenum = 0x8E7E;
    pub const GL_MAX_TESS_PATCH_COMPONENTS: GLenum = 0x8E84;
    pub const GL_MAX_TEXTURE_BUFFER_SIZE: GLenum = 0x8C2B;
    pub const GL_MAX_TEXTURE_IMAGE_UNITS: GLenum = 0x8872;
    pub const GL_MAX_TEXTURE_LOD_BIAS: GLenum = 0x84FD;
    pub const GL_MAX_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FF;
    pub const GL_MAX_TEXTURE_SIZE: GLenum = 0x0D33;
    pub const GL_MAX_TRANSFORM_FEEDBACK_BUFFERS: GLenum = 0x8E70;
    pub const GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: GLenum = 0x8C8A;
    pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: GLenum = 0x8C8B;
    pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: GLenum = 0x8C80;
    pub const GL_MAX_UNIFORM_BLOCK_SIZE: GLenum = 0x8A30;
    pub const GL_MAX_UNIFORM_BUFFER_BINDINGS: GLenum = 0x8A2F;
    pub const GL_MAX_UNIFORM_LOCATIONS: GLenum = 0x826E;

    pub const GL_MAX_VARYING_COMPONENTS: GLenum = 0x8B4B;
    pub const GL_MAX_VARYING_FLOATS: GLenum = 0x8B4B;
    pub const GL_MAX_VARYING_VECTORS: GLenum = 0x8DFC;
    pub const GL_MAX_VERTEX_ATOMIC_COUNTERS: GLenum = 0x92D2;
    pub const GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CC;
    pub const GL_MAX_VERTEX_ATTRIBS: GLenum = 0x8869;
    pub const GL_MAX_VERTEX_ATTRIB_BINDINGS: GLenum = 0x82DA;
    pub const GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET: GLenum = 0x82D9;
    pub const GL_MAX_VERTEX_ATTRIB_STRIDE: GLenum = 0x82E5;
    pub const GL_MAX_VERTEX_IMAGE_UNIFORMS: GLenum = 0x90CA;
    pub const GL_MAX_VERTEX_OUTPUT_COMPONENTS: GLenum = 0x9122;
    pub const GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS: GLenum = 0x90D6;
    pub const GL_MAX_VERTEX_STREAMS: GLenum = 0x8E71;
    pub const GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4C;
    pub const GL_MAX_VERTEX_UNIFORM_BLOCKS: GLenum = 0x8A2B;
    pub const GL_MAX_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8B4A;
    pub const GL_MAX_VERTEX_UNIFORM_VECTORS: GLenum = 0x8DFB;
    pub const GL_MAX_VIEWPORTS: GLenum = 0x825B;
    pub const GL_MAX_VIEWPORT_DIMS: GLenum = 0x0D3A;
    pub const GL_MAX_WIDTH: GLenum = 0x827E;
    pub const GL_MEDIUM_FLOAT: GLenum = 0x8DF1;
    pub const GL_MEDIUM_INT: GLenum = 0x8DF4;
    pub const GL_MIN: GLenum = 0x8007;
    pub const GL_MINOR_VERSION: GLenum = 0x821C;
    pub const GL_MIN_FRAGMENT_INTERPOLATION_OFFSET: GLenum = 0x8E5B;
    pub const GL_MIN_MAP_BUFFER_ALIGNMENT: GLenum = 0x90BC;
    pub const GL_MIN_PROGRAM_TEXEL_OFFSET: GLenum = 0x8904;
    pub const GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET: GLenum = 0x8E5E;
    pub const GL_MIN_SAMPLE_SHADING_VALUE: GLenum = 0x8C37;
    pub const GL_MIPMAP: GLenum = 0x8293;
    pub const GL_MIRRORED_REPEAT: GLenum = 0x8370;
    pub const GL_MIRROR_CLAMP_TO_EDGE: GLenum = 0x8743;
    pub const GL_MULTISAMPLE: GLenum = 0x809D;
    pub const GL_NAME_LENGTH: GLenum = 0x92F9;
    pub const GL_NAND: GLenum = 0x150E;
    pub const GL_NEAREST: GLenum = 0x2600;
    pub const GL_NEAREST_MIPMAP_LINEAR: GLenum = 0x2702;
    pub const GL_NEAREST_MIPMAP_NEAREST: GLenum = 0x2700;
    pub const GL_NEGATIVE_ONE_TO_ONE: GLenum = 0x935E;
    pub const GL_NEVER: GLenum = 0x0200;
    pub const GL_NICEST: GLenum = 0x1102;
    pub const GL_NONE: GLenum = 0;
    pub const GL_NOOP: GLenum = 0x1505;
    pub const GL_NOR: GLenum = 0x1508;
    pub const GL_NOTEQUAL: GLenum = 0x0205;
    pub const GL_NO_ERROR: GLenum = 0;
    pub const GL_NO_RESET_NOTIFICATION: GLenum = 0x8261;
    pub const GL_NUM_ACTIVE_VARIABLES: GLenum = 0x9304;
    pub const GL_NUM_COMPATIBLE_SUBROUTINES: GLenum = 0x8E4A;
    pub const GL_NUM_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A2;
    pub const GL_NUM_EXTENSIONS: GLenum = 0x821D;
    pub const GL_NUM_PROGRAM_BINARY_FORMATS: GLenum = 0x87FE;
    pub const GL_NUM_SAMPLE_COUNTS: GLenum = 0x9380;
    pub const GL_NUM_SHADER_BINARY_FORMATS: GLenum = 0x8DF9;
    pub const GL_NUM_SHADING_LANGUAGE_VERSIONS: GLenum = 0x82E9;
    pub const GL_NUM_SPIR_V_EXTENSIONS: GLenum = 0x9554;
    pub const GL_OBJECT_TYPE: GLenum = 0x9112;
    pub const GL_OFFSET: GLenum = 0x92FC;
    pub const GL_ONE: GLenum = 1;
    pub const GL_ONE_MINUS_CONSTANT_ALPHA: GLenum = 0x8004;
    pub const GL_ONE_MINUS_CONSTANT_COLOR: GLenum = 0x8002;
    pub const GL_ONE_MINUS_DST_ALPHA: GLenum = 0x0305;
    pub const GL_ONE_MINUS_DST_COLOR: GLenum = 0x0307;
    pub const GL_ONE_MINUS_SRC1_ALPHA: GLenum = 0x88FB;
    pub const GL_ONE_MINUS_SRC1_COLOR: GLenum = 0x88FA;
    pub const GL_ONE_MINUS_SRC_ALPHA: GLenum = 0x0303;
    pub const GL_ONE_MINUS_SRC_COLOR: GLenum = 0x0301;
    pub const GL_OR: GLenum = 0x1507;
    pub const GL_OR_INVERTED: GLenum = 0x150D;
    pub const GL_OR_REVERSE: GLenum = 0x150B;
    pub const GL_OUT_OF_MEMORY: GLenum = 0x0505;
    pub const GL_PACK_ALIGNMENT: GLenum = 0x0D05;
    pub const GL_PACK_COMPRESSED_BLOCK_DEPTH: GLenum = 0x912D;
    pub const GL_PACK_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x912C;
    pub const GL_PACK_COMPRESSED_BLOCK_SIZE: GLenum = 0x912E;
    pub const GL_PACK_COMPRESSED_BLOCK_WIDTH: GLenum = 0x912B;
    pub const GL_PACK_IMAGE_HEIGHT: GLenum = 0x806C;
    pub const GL_PACK_LSB_FIRST: GLenum = 0x0D01;
    pub const GL_PACK_ROW_LENGTH: GLenum = 0x0D02;
    pub const GL_PACK_SKIP_IMAGES: GLenum = 0x806B;
    pub const GL_PACK_SKIP_PIXELS: GLenum = 0x0D04;
    pub const GL_PACK_SKIP_ROWS: GLenum = 0x0D03;
    pub const GL_PACK_SWAP_BYTES: GLenum = 0x0D00;
    pub const GL_PARAMETER_BUFFER: GLenum = 0x80EE;
    pub const GL_PARAMETER_BUFFER_BINDING: GLenum = 0x80EF;
    pub const GL_PATCHES: GLenum = 0x000E;
    pub const GL_PATCH_DEFAULT_INNER_LEVEL: GLenum = 0x8E73;
    pub const GL_PATCH_DEFAULT_OUTER_LEVEL: GLenum = 0x8E74;
    pub const GL_PATCH_VERTICES: GLenum = 0x8E72;
    pub const GL_PIXEL_BUFFER_BARRIER_BIT: GLbitfield = 0x00000080;
    pub const GL_PIXEL_PACK_BUFFER: GLenum = 0x88EB;
    pub const GL_PIXEL_PACK_BUFFER_BINDING: GLenum = 0x88ED;
    pub const GL_PIXEL_UNPACK_BUFFER: GLenum = 0x88EC;
    pub const GL_PIXEL_UNPACK_BUFFER_BINDING: GLenum = 0x88EF;
    pub const GL_POINT: GLenum = 0x1B00;
    pub const GL_POINTS: GLenum = 0x0000;
    pub const GL_POINT_FADE_THRESHOLD_SIZE: GLenum = 0x8128;
    pub const GL_POINT_SIZE: GLenum = 0x0B11;
    pub const GL_POINT_SIZE_GRANULARITY: GLenum = 0x0B13;
    pub const GL_POINT_SIZE_RANGE: GLenum = 0x0B12;
    pub const GL_POINT_SPRITE_COORD_ORIGIN: GLenum = 0x8CA0;
    pub const GL_POLYGON_MODE: GLenum = 0x0B40;
    pub const GL_POLYGON_OFFSET_CLAMP: GLenum = 0x8E1B;
    pub const GL_POLYGON_OFFSET_FACTOR: GLenum = 0x8038;
    pub const GL_POLYGON_OFFSET_FILL: GLenum = 0x8037;
    pub const GL_POLYGON_OFFSET_LINE: GLenum = 0x2A02;
    pub const GL_POLYGON_OFFSET_POINT: GLenum = 0x2A01;
    pub const GL_POLYGON_OFFSET_UNITS: GLenum = 0x2A00;
    pub const GL_POLYGON_SMOOTH: GLenum = 0x0B41;
    pub const GL_POLYGON_SMOOTH_HINT: GLenum = 0x0C53;
    pub const GL_PRIMITIVES_GENERATED: GLenum = 0x8C87;
    pub const GL_PRIMITIVES_SUBMITTED: GLenum = 0x82EF;
    pub const GL_PRIMITIVE_RESTART: GLenum = 0x8F9D;
    pub const GL_PRIMITIVE_RESTART_FIXED_INDEX: GLenum = 0x8D69;
    pub const GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED: GLenum = 0x8221;
    pub const GL_PRIMITIVE_RESTART_INDEX: GLenum = 0x8F9E;
    pub const GL_PROGRAM: GLenum = 0x82E2;
    pub const GL_PROGRAM_BINARY_FORMATS: GLenum = 0x87FF;
    pub const GL_PROGRAM_BINARY_LENGTH: GLenum = 0x8741;
    pub const GL_PROGRAM_BINARY_RETRIEVABLE_HINT: GLenum = 0x8257;
    pub const GL_PROGRAM_INPUT: GLenum = 0x92E3;
    pub const GL_PROGRAM_OUTPUT: GLenum = 0x92E4;
    pub const GL_PROGRAM_PIPELINE: GLenum = 0x82E4;
    pub const GL_PROGRAM_PIPELINE_BINDING: GLenum = 0x825A;

    pub const GL_PROGRAM_POINT_SIZE: GLenum = 0x8642;
    pub const GL_PROGRAM_SEPARABLE: GLenum = 0x8258;
    pub const GL_PROVOKING_VERTEX: GLenum = 0x8E4F;
    pub const GL_PROXY_TEXTURE_1D: GLenum = 0x8063;
    pub const GL_PROXY_TEXTURE_1D_ARRAY: GLenum = 0x8C19;
    pub const GL_PROXY_TEXTURE_2D: GLenum = 0x8064;
    pub const GL_PROXY_TEXTURE_2D_ARRAY: GLenum = 0x8C1B;
    pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9101;
    pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9103;
    pub const GL_PROXY_TEXTURE_3D: GLenum = 0x8070;
    pub const GL_PROXY_TEXTURE_CUBE_MAP: GLenum = 0x851B;
    pub const GL_PROXY_TEXTURE_CUBE_MAP_ARRAY: GLenum = 0x900B;
    pub const GL_PROXY_TEXTURE_RECTANGLE: GLenum = 0x84F7;
    pub const GL_QUADS: GLenum = 0x0007;
    pub const GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: GLenum = 0x8E4C;
    pub const GL_QUERY: GLenum = 0x82E3;
    pub const GL_QUERY_BUFFER: GLenum = 0x9192;
    pub const GL_QUERY_BUFFER_BARRIER_BIT: GLbitfield = 0x00008000;
    pub const GL_QUERY_BUFFER_BINDING: GLenum = 0x9193;
    pub const GL_QUERY_BY_REGION_NO_WAIT: GLenum = 0x8E16;
    pub const GL_QUERY_BY_REGION_NO_WAIT_INVERTED: GLenum = 0x8E1A;
    pub const GL_QUERY_BY_REGION_WAIT: GLenum = 0x8E15;
    pub const GL_QUERY_BY_REGION_WAIT_INVERTED: GLenum = 0x8E19;
    pub const GL_QUERY_COUNTER_BITS: GLenum = 0x8864;
    pub const GL_QUERY_NO_WAIT: GLenum = 0x8E14;
    pub const GL_QUERY_NO_WAIT_INVERTED: GLenum = 0x8E18;
    pub const GL_QUERY_RESULT: GLenum = 0x8866;
    pub const GL_QUERY_RESULT_AVAILABLE: GLenum = 0x8867;
    pub const GL_QUERY_RESULT_NO_WAIT: GLenum = 0x9194;
    pub const GL_QUERY_TARGET: GLenum = 0x82EA;
    pub const GL_QUERY_WAIT: GLenum = 0x8E13;
    pub const GL_QUERY_WAIT_INVERTED: GLenum = 0x8E17;
    pub const GL_R11F_G11F_B10F: GLenum = 0x8C3A;
    pub const GL_R16: GLenum = 0x822A;
    pub const GL_R16F: GLenum = 0x822D;
    pub const GL_R16I: GLenum = 0x8233;
    pub const GL_R16UI: GLenum = 0x8234;
    pub const GL_R16_SNORM: GLenum = 0x8F98;
    pub const GL_R32F: GLenum = 0x822E;
    pub const GL_R32I: GLenum = 0x8235;
    pub const GL_R32UI: GLenum = 0x8236;
    pub const GL_R3_G3_B2: GLenum = 0x2A10;
    pub const GL_R8: GLenum = 0x8229;
    pub const GL_R8I: GLenum = 0x8231;
    pub const GL_R8UI: GLenum = 0x8232;
    pub const GL_R8_SNORM: GLenum = 0x8F94;
    pub const GL_RASTERIZER_DISCARD: GLenum = 0x8C89;
    pub const GL_READ_BUFFER: GLenum = 0x0C02;
    pub const GL_READ_FRAMEBUFFER: GLenum = 0x8CA8;
    pub const GL_READ_FRAMEBUFFER_BINDING: GLenum = 0x8CAA;
    pub const GL_READ_ONLY: GLenum = 0x88B8;
    pub const GL_READ_PIXELS: GLenum = 0x828C;
    pub const GL_READ_PIXELS_FORMAT: GLenum = 0x828D;
    pub const GL_READ_PIXELS_TYPE: GLenum = 0x828E;
    pub const GL_READ_WRITE: GLenum = 0x88BA;
    pub const GL_RED: GLenum = 0x1903;
    pub const GL_RED_INTEGER: GLenum = 0x8D94;
    pub const GL_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x930B;
    pub const GL_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x930A;
    pub const GL_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x9309;
    pub const GL_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x9307;
    pub const GL_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x9308;
    pub const GL_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x9306;
    pub const GL_RENDERBUFFER: GLenum = 0x8D41;
    pub const GL_RENDERBUFFER_ALPHA_SIZE: GLenum = 0x8D53;
    pub const GL_RENDERBUFFER_BINDING: GLenum = 0x8CA7;
    pub const GL_RENDERBUFFER_BLUE_SIZE: GLenum = 0x8D52;
    pub const GL_RENDERBUFFER_DEPTH_SIZE: GLenum = 0x8D54;
    pub const GL_RENDERBUFFER_GREEN_SIZE: GLenum = 0x8D51;
    pub const GL_RENDERBUFFER_HEIGHT: GLenum = 0x8D43;
    pub const GL_RENDERBUFFER_INTERNAL_FORMAT: GLenum = 0x8D44;
    pub const GL_RENDERBUFFER_RED_SIZE: GLenum = 0x8D50;
    pub const GL_RENDERBUFFER_SAMPLES: GLenum = 0x8CAB;
    pub const GL_RENDERBUFFER_STENCIL_SIZE: GLenum = 0x8D55;
    pub const GL_RENDERBUFFER_WIDTH: GLenum = 0x8D42;
    pub const GL_RENDERER: GLenum = 0x1F01;
    pub const GL_REPEAT: GLenum = 0x2901;
    pub const GL_REPLACE: GLenum = 0x1E01;
    pub const GL_RESET_NOTIFICATION_STRATEGY: GLenum = 0x8256;
    pub const GL_RG: GLenum = 0x8227;
    pub const GL_RG16: GLenum = 0x822C;
    pub const GL_RG16F: GLenum = 0x822F;
    pub const GL_RG16I: GLenum = 0x8239;
    pub const GL_RG16UI: GLenum = 0x823A;
    pub const GL_RG16_SNORM: GLenum = 0x8F99;
    pub const GL_RG32F: GLenum = 0x8230;
    pub const GL_RG32I: GLenum = 0x823B;
    pub const GL_RG32UI: GLenum = 0x823C;
    pub const GL_RG8: GLenum = 0x822B;
    pub const GL_RG8I: GLenum = 0x8237;
    pub const GL_RG8UI: GLenum = 0x8238;
    pub const GL_RG8_SNORM: GLenum = 0x8F95;
    pub const GL_RGB: GLenum = 0x1907;
    pub const GL_RGB10: GLenum = 0x8052;
    pub const GL_RGB10_A2: GLenum = 0x8059;
    pub const GL_RGB10_A2UI: GLenum = 0x906F;
    pub const GL_RGB12: GLenum = 0x8053;
    pub const GL_RGB16: GLenum = 0x8054;
    pub const GL_RGB16F: GLenum = 0x881B;
    pub const GL_RGB16I: GLenum = 0x8D89;
    pub const GL_RGB16UI: GLenum = 0x8D77;
    pub const GL_RGB16_SNORM: GLenum = 0x8F9A;
    pub const GL_RGB32F: GLenum = 0x8815;
    pub const GL_RGB32I: GLenum = 0x8D83;
    pub const GL_RGB32UI: GLenum = 0x8D71;
    pub const GL_RGB4: GLenum = 0x804F;
    pub const GL_RGB5: GLenum = 0x8050;
    pub const GL_RGB565: GLenum = 0x8D62;
    pub const GL_RGB5_A1: GLenum = 0x8057;
    pub const GL_RGB8: GLenum = 0x8051;
    pub const GL_RGB8I: GLenum = 0x8D8F;
    pub const GL_RGB8UI: GLenum = 0x8D7D;
    pub const GL_RGB8_SNORM: GLenum = 0x8F96;
    pub const GL_RGB9_E5: GLenum = 0x8C3D;
    pub const GL_RGBA: GLenum = 0x1908;
    pub const GL_RGBA12: GLenum = 0x805A;
    pub const GL_RGBA16: GLenum = 0x805B;
    pub const GL_RGBA16F: GLenum = 0x881A;
    pub const GL_RGBA16I: GLenum = 0x8D88;
    pub const GL_RGBA16UI: GLenum = 0x8D76;
    pub const GL_RGBA16_SNORM: GLenum = 0x8F9B;
    pub const GL_RGBA2: GLenum = 0x8055;
    pub const GL_RGBA32F: GLenum = 0x8814;
    pub const GL_RGBA32I: GLenum = 0x8D82;
    pub const GL_RGBA32UI: GLenum = 0x8D70;
    pub const GL_RGBA4: GLenum = 0x8056;
    pub const GL_RGBA8: GLenum = 0x8058;
    pub const GL_RGBA8I: GLenum = 0x8D8E;
    pub const GL_RGBA8UI: GLenum = 0x8D7C;
    pub const GL_RGBA8_SNORM: GLenum = 0x8F97;
    pub const GL_RGBA_INTEGER: GLenum = 0x8D99;
    pub const GL_RGB_INTEGER: GLenum = 0x8D98;
    pub const GL_RG_INTEGER: GLenum = 0x8228;
    pub const GL_RIGHT: GLenum = 0x0407;
    pub const GL_SAMPLER: GLenum = 0x82E6;
    pub const GL_SAMPLER_1D: GLenum = 0x8B5D;
    pub const GL_SAMPLER_1D_ARRAY: GLenum = 0x8DC0;
    pub const GL_SAMPLER_1D_ARRAY_SHADOW: GLenum = 0x8DC3;
    pub const GL_SAMPLER_1D_SHADOW: GLenum = 0x8B61;
    pub const GL_SAMPLER_2D: GLenum = 0x8B5E;
    pub const GL_SAMPLER_2D_ARRAY: GLenum = 0x8DC1;
    pub const GL_SAMPLER_2D_ARRAY_SHADOW: GLenum = 0x8DC4;
    pub const GL_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9108;
    pub const GL_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910B;
    pub const GL_SAMPLER_2D_RECT: GLenum = 0x8B63;
    pub const GL_SAMPLER_2D_RECT_SHADOW: GLenum = 0x8B64;
    pub const GL_SAMPLER_2D_SHADOW: GLenum = 0x8B62;
    pub const GL_SAMPLER_3D: GLenum = 0x8B5F;
    pub const GL_SAMPLER_BINDING: GLenum = 0x8919;
    pub const GL_SAMPLER_BUFFER: GLenum = 0x8DC2;
    pub const GL_SAMPLER_CUBE: GLenum = 0x8B60;
    pub const GL_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900C;
    pub const GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW: GLenum = 0x900D;
    pub const GL_SAMPLER_CUBE_SHADOW: GLenum = 0x8DC5;
    pub const GL_SAMPLES: GLenum = 0x80A9;
    pub const GL_SAMPLES_PASSED: GLenum = 0x8914;
    pub const GL_SAMPLE_ALPHA_TO_COVERAGE: GLenum = 0x809E;
    pub const GL_SAMPLE_ALPHA_TO_ONE: GLenum = 0x809F;
    pub const GL_SAMPLE_BUFFERS: GLenum = 0x80A8;
    pub const GL_SAMPLE_COVERAGE: GLenum = 0x80A0;
    pub const GL_SAMPLE_COVERAGE_INVERT: GLenum = 0x80AB;
    pub const GL_SAMPLE_COVERAGE_VALUE: GLenum = 0x80AA;
    pub const GL_SAMPLE_MASK: GLenum = 0x8E51;
    pub const GL_SAMPLE_MASK_VALUE: GLenum = 0x8E52;
    pub const GL_SAMPLE_POSITION: GLenum = 0x8E50;
    pub const GL_SAMPLE_SHADING: GLenum = 0x8C36;
    pub const GL_SCISSOR_BOX: GLenum = 0x0C10;
    pub const GL_SCISSOR_TEST: GLenum = 0x0C11;
    pub const GL_SEPARATE_ATTRIBS: GLenum = 0x8C8D;
    pub const GL_SET: GLenum = 0x150F;
    pub const GL_SHADER: GLenum = 0x82E1;
    pub const GL_SHADER_BINARY_FORMATS: GLenum = 0x8DF8;
    pub const GL_SHADER_BINARY_FORMAT_SPIR_V: GLenum = 0x9551;
    pub const GL_SHADER_COMPILER: GLenum = 0x8DFA;
    pub const GL_SHADER_IMAGE_ACCESS_BARRIER_BIT: GLbitfield = 0x00000020;
    pub const GL_SHADER_IMAGE_ATOMIC: GLenum = 0x82A6;
    pub const GL_SHADER_IMAGE_LOAD: GLenum = 0x82A4;
    pub const GL_SHADER_IMAGE_STORE: GLenum = 0x82A5;
    pub const GL_SHADER_SOURCE_LENGTH: GLenum = 0x8B88;
    pub const GL_SHADER_STORAGE_BARRIER_BIT: GLbitfield = 0x00002000;
    pub const GL_SHADER_STORAGE_BLOCK: GLenum = 0x92E6;
    pub const GL_SHADER_STORAGE_BUFFER: GLenum = 0x90D2;
    pub const GL_SHADER_STORAGE_BUFFER_BINDING: GLenum = 0x90D3;
    pub const GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x90DF;
    pub const GL_SHADER_STORAGE_BUFFER_SIZE: GLenum = 0x90D5;
    pub const GL_SHADER_STORAGE_BUFFER_START: GLenum = 0x90D4;
    pub const GL_SHADER_TYPE: GLenum = 0x8B4F;
    pub const GL_SHADING_LANGUAGE_VERSION: GLenum = 0x8B8C;
    pub const GL_SHORT: GLenum = 0x1402;
    pub const GL_SIGNALED: GLenum = 0x9119;
    pub const GL_SIGNED_NORMALIZED: GLenum = 0x8F9C;
    pub const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST: GLenum = 0x82AC;
    pub const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE: GLenum = 0x82AE;
    pub const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST: GLenum = 0x82AD;
    pub const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE: GLenum = 0x82AF;

    pub const GL_SMOOTH_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23;

    pub const GL_SMOOTH_LINE_WIDTH_RANGE: GLenum = 0x0B22;

    pub const GL_SMOOTH_POINT_SIZE_GRANULARITY: GLenum = 0x0B13;

    pub const GL_SMOOTH_POINT_SIZE_RANGE: GLenum = 0x0B12;
    pub const GL_SPIR_V_BINARY: GLenum = 0x9552;
    pub const GL_SPIR_V_EXTENSIONS: GLenum = 0x9553;

    pub const GL_SRC1_ALPHA: GLenum = 0x8589;
    pub const GL_SRC1_COLOR: GLenum = 0x88F9;
    pub const GL_SRC_ALPHA: GLenum = 0x0302;
    pub const GL_SRC_ALPHA_SATURATE: GLenum = 0x0308;
    pub const GL_SRC_COLOR: GLenum = 0x0300;
    pub const GL_SRGB: GLenum = 0x8C40;
    pub const GL_SRGB8: GLenum = 0x8C41;
    pub const GL_SRGB8_ALPHA8: GLenum = 0x8C43;
    pub const GL_SRGB_ALPHA: GLenum = 0x8C42;
    pub const GL_SRGB_READ: GLenum = 0x8297;
    pub const GL_SRGB_WRITE: GLenum = 0x8298;
    pub const GL_STACK_OVERFLOW: GLenum = 0x0503;
    pub const GL_STACK_UNDERFLOW: GLenum = 0x0504;
    pub const GL_STATIC_COPY: GLenum = 0x88E6;
    pub const GL_STATIC_DRAW: GLenum = 0x88E4;
    pub const GL_STATIC_READ: GLenum = 0x88E5;
    pub const GL_STENCIL: GLenum = 0x1802;
    pub const GL_STENCIL_ATTACHMENT: GLenum = 0x8D20;
    pub const GL_STENCIL_BACK_FAIL: GLenum = 0x8801;
    pub const GL_STENCIL_BACK_FUNC: GLenum = 0x8800;
    pub const GL_STENCIL_BACK_PASS_DEPTH_FAIL: GLenum = 0x8802;
    pub const GL_STENCIL_BACK_PASS_DEPTH_PASS: GLenum = 0x8803;
    pub const GL_STENCIL_BACK_REF: GLenum = 0x8CA3;
    pub const GL_STENCIL_BACK_VALUE_MASK: GLenum = 0x8CA4;
    pub const GL_STENCIL_BACK_WRITEMASK: GLenum = 0x8CA5;
    pub const GL_STENCIL_BUFFER_BIT: GLbitfield = 0x00000400;
    pub const GL_STENCIL_CLEAR_VALUE: GLenum = 0x0B91;
    pub const GL_STENCIL_COMPONENTS: GLenum = 0x8285;
    pub const GL_STENCIL_FAIL: GLenum = 0x0B94;
    pub const GL_STENCIL_FUNC: GLenum = 0x0B92;
    pub const GL_STENCIL_INDEX: GLenum = 0x1901;
    pub const GL_STENCIL_INDEX1: GLenum = 0x8D46;
    pub const GL_STENCIL_INDEX16: GLenum = 0x8D49;
    pub const GL_STENCIL_INDEX4: GLenum = 0x8D47;
    pub const GL_STENCIL_INDEX8: GLenum = 0x8D48;
    pub const GL_STENCIL_PASS_DEPTH_FAIL: GLenum = 0x0B95;
    pub const GL_STENCIL_PASS_DEPTH_PASS: GLenum = 0x0B96;
    pub const GL_STENCIL_REF: GLenum = 0x0B97;
    pub const GL_STENCIL_RENDERABLE: GLenum = 0x8288;
    pub const GL_STENCIL_TEST: GLenum = 0x0B90;
    pub const GL_STENCIL_VALUE_MASK: GLenum = 0x0B93;
    pub const GL_STENCIL_WRITEMASK: GLenum = 0x0B98;
    pub const GL_STEREO: GLenum = 0x0C33;
    pub const GL_STREAM_COPY: GLenum = 0x88E2;
    pub const GL_STREAM_DRAW: GLenum = 0x88E0;
    pub const GL_STREAM_READ: GLenum = 0x88E1;
    pub const GL_SUBPIXEL_BITS: GLenum = 0x0D50;
    pub const GL_SYNC_CONDITION: GLenum = 0x9113;
    pub const GL_SYNC_FENCE: GLenum = 0x9116;
    pub const GL_SYNC_FLAGS: GLenum = 0x9115;
    pub const GL_SYNC_FLUSH_COMMANDS_BIT: GLbitfield = 0x00000001;
    pub const GL_SYNC_GPU_COMMANDS_COMPLETE: GLenum = 0x9117;
    pub const GL_SYNC_STATUS: GLenum = 0x9114;
    pub const GL_TESS_CONTROL_OUTPUT_VERTICES: GLenum = 0x8E75;
    pub const GL_TESS_CONTROL_SHADER: GLenum = 0x8E88;
    pub const GL_TESS_CONTROL_SHADER_BIT: GLbitfield = 0x00000008;
    pub const GL_TESS_CONTROL_SHADER_PATCHES: GLenum = 0x82F1;
    pub const GL_TESS_CONTROL_SUBROUTINE: GLenum = 0x92E9;
    pub const GL_TESS_CONTROL_SUBROUTINE_UNIFORM: GLenum = 0x92EF;
    pub const GL_TESS_CONTROL_TEXTURE: GLenum = 0x829C;
    pub const GL_TESS_EVALUATION_SHADER: GLenum = 0x8E87;
    pub const GL_TESS_EVALUATION_SHADER_BIT: GLbitfield = 0x00000010;
    pub const GL_TESS_EVALUATION_SHADER_INVOCATIONS: GLenum = 0x82F2;
    pub const GL_TESS_EVALUATION_SUBROUTINE: GLenum = 0x92EA;
    pub const GL_TESS_EVALUATION_SUBROUTINE_UNIFORM: GLenum = 0x92F0;
    pub const GL_TESS_EVALUATION_TEXTURE: GLenum = 0x829D;
    pub const GL_TESS_GEN_MODE: GLenum = 0x8E76;
    pub const GL_TESS_GEN_POINT_MODE: GLenum = 0x8E79;
    pub const GL_TESS_GEN_SPACING: GLenum = 0x8E77;
    pub const GL_TESS_GEN_VERTEX_ORDER: GLenum = 0x8E78;
    pub const GL_TEXTURE: GLenum = 0x1702;
    pub const GL_TEXTURE0: GLenum = 0x84C0;
    pub const GL_TEXTURE1: GLenum = 0x84C1;
    pub const GL_TEXTURE10: GLenum = 0x84CA;
    pub const GL_TEXTURE11: GLenum = 0x84CB;
    pub const GL_TEXTURE12: GLenum = 0x84CC;
    pub const GL_TEXTURE13: GLenum = 0x84CD;
    pub const GL_TEXTURE14: GLenum = 0x84CE;
    pub const GL_TEXTURE15: GLenum = 0x84CF;
    pub const GL_TEXTURE16: GLenum = 0x84D0;
    pub const GL_TEXTURE17: GLenum = 0x84D1;
    pub const GL_TEXTURE18: GLenum = 0x84D2;
    pub const GL_TEXTURE19: GLenum = 0x84D3;
    pub const GL_TEXTURE2: GLenum = 0x84C2;
    pub const GL_TEXTURE20: GLenum = 0x84D4;
    pub const GL_TEXTURE21: GLenum = 0x84D5;
    pub const GL_TEXTURE22: GLenum = 0x84D6;
    pub const GL_TEXTURE23: GLenum = 0x84D7;
    pub const GL_TEXTURE24: GLenum = 0x84D8;
    pub const GL_TEXTURE25: GLenum = 0x84D9;
    pub const GL_TEXTURE26: GLenum = 0x84DA;
    pub const GL_TEXTURE27: GLenum = 0x84DB;
    pub const GL_TEXTURE28: GLenum = 0x84DC;
    pub const GL_TEXTURE29: GLenum = 0x84DD;
    pub const GL_TEXTURE3: GLenum = 0x84C3;
    pub const GL_TEXTURE30: GLenum = 0x84DE;
    pub const GL_TEXTURE31: GLenum = 0x84DF;
    pub const GL_TEXTURE4: GLenum = 0x84C4;
    pub const GL_TEXTURE5: GLenum = 0x84C5;
    pub const GL_TEXTURE6: GLenum = 0x84C6;
    pub const GL_TEXTURE7: GLenum = 0x84C7;
    pub const GL_TEXTURE8: GLenum = 0x84C8;
    pub const GL_TEXTURE9: GLenum = 0x84C9;
    pub const GL_TEXTURE_1D: GLenum = 0x0DE0;
    pub const GL_TEXTURE_1D_ARRAY: GLenum = 0x8C18;
    pub const GL_TEXTURE_2D: GLenum = 0x0DE1;
    pub const GL_TEXTURE_2D_ARRAY: GLenum = 0x8C1A;
    pub const GL_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9100;
    pub const GL_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9102;
    pub const GL_TEXTURE_3D: GLenum = 0x806F;
    pub const GL_TEXTURE_ALPHA_SIZE: GLenum = 0x805F;
    pub const GL_TEXTURE_ALPHA_TYPE: GLenum = 0x8C13;
    pub const GL_TEXTURE_BASE_LEVEL: GLenum = 0x813C;
    pub const GL_TEXTURE_BINDING_1D: GLenum = 0x8068;
    pub const GL_TEXTURE_BINDING_1D_ARRAY: GLenum = 0x8C1C;
    pub const GL_TEXTURE_BINDING_2D: GLenum = 0x8069;
    pub const GL_TEXTURE_BINDING_2D_ARRAY: GLenum = 0x8C1D;
    pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE: GLenum = 0x9104;
    pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: GLenum = 0x9105;
    pub const GL_TEXTURE_BINDING_3D: GLenum = 0x806A;
    pub const GL_TEXTURE_BINDING_BUFFER: GLenum = 0x8C2C;
    pub const GL_TEXTURE_BINDING_CUBE_MAP: GLenum = 0x8514;
    pub const GL_TEXTURE_BINDING_CUBE_MAP_ARRAY: GLenum = 0x900A;
    pub const GL_TEXTURE_BINDING_RECTANGLE: GLenum = 0x84F6;
    pub const GL_TEXTURE_BLUE_SIZE: GLenum = 0x805E;
    pub const GL_TEXTURE_BLUE_TYPE: GLenum = 0x8C12;
    pub const GL_TEXTURE_BORDER_COLOR: GLenum = 0x1004;
    pub const GL_TEXTURE_BUFFER: GLenum = 0x8C2A;
    pub const GL_TEXTURE_BUFFER_BINDING: GLenum = 0x8C2A;
    pub const GL_TEXTURE_BUFFER_DATA_STORE_BINDING: GLenum = 0x8C2D;
    pub const GL_TEXTURE_BUFFER_OFFSET: GLenum = 0x919D;
    pub const GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x919F;
    pub const GL_TEXTURE_BUFFER_SIZE: GLenum = 0x919E;
    pub const GL_TEXTURE_COMPARE_FUNC: GLenum = 0x884D;
    pub const GL_TEXTURE_COMPARE_MODE: GLenum = 0x884C;
    pub const GL_TEXTURE_COMPRESSED: GLenum = 0x86A1;
    pub const GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x82B2;
    pub const GL_TEXTURE_COMPRESSED_BLOCK_SIZE: GLenum = 0x82B3;
    pub const GL_TEXTURE_COMPRESSED_BLOCK_WIDTH: GLenum = 0x82B1;
    pub const GL_TEXTURE_COMPRESSED_IMAGE_SIZE: GLenum = 0x86A0;
    pub const GL_TEXTURE_COMPRESSION_HINT: GLenum = 0x84EF;
    pub const GL_TEXTURE_CUBE_MAP: GLenum = 0x8513;
    pub const GL_TEXTURE_CUBE_MAP_ARRAY: GLenum = 0x9009;
    pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum = 0x8516;
    pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum = 0x8518;
    pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum = 0x851A;
    pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: GLenum = 0x8515;
    pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum = 0x8517;
    pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum = 0x8519;
    pub const GL_TEXTURE_CUBE_MAP_SEAMLESS: GLenum = 0x884F;
    pub const GL_TEXTURE_DEPTH: GLenum = 0x8071;
    pub const GL_TEXTURE_DEPTH_SIZE: GLenum = 0x884A;
    pub const GL_TEXTURE_DEPTH_TYPE: GLenum = 0x8C16;
    pub const GL_TEXTURE_FETCH_BARRIER_BIT: GLbitfield = 0x00000008;
    pub const GL_TEXTURE_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9107;
    pub const GL_TEXTURE_GATHER: GLenum = 0x82A2;
    pub const GL_TEXTURE_GATHER_SHADOW: GLenum = 0x82A3;
    pub const GL_TEXTURE_GREEN_SIZE: GLenum = 0x805D;
    pub const GL_TEXTURE_GREEN_TYPE: GLenum = 0x8C11;
    pub const GL_TEXTURE_HEIGHT: GLenum = 0x1001;
    pub const GL_TEXTURE_IMAGE_FORMAT: GLenum = 0x828F;
    pub const GL_TEXTURE_IMAGE_TYPE: GLenum = 0x8290;
    pub const GL_TEXTURE_IMMUTABLE_FORMAT: GLenum = 0x912F;
    pub const GL_TEXTURE_IMMUTABLE_LEVELS: GLenum = 0x82DF;
    pub const GL_TEXTURE_INTERNAL_FORMAT: GLenum = 0x1003;
    pub const GL_TEXTURE_LOD_BIAS: GLenum = 0x8501;
    pub const GL_TEXTURE_MAG_FILTER: GLenum = 0x2800;
    pub const GL_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FE;
    pub const GL_TEXTURE_MAX_LEVEL: GLenum = 0x813D;
    pub const GL_TEXTURE_MAX_LOD: GLenum = 0x813B;
    pub const GL_TEXTURE_MIN_FILTER: GLenum = 0x2801;
    pub const GL_TEXTURE_MIN_LOD: GLenum = 0x813A;
    pub const GL_TEXTURE_RECTANGLE: GLenum = 0x84F5;
    pub const GL_TEXTURE_RED_SIZE: GLenum = 0x805C;
    pub const GL_TEXTURE_RED_TYPE: GLenum = 0x8C10;
    pub const GL_TEXTURE_SAMPLES: GLenum = 0x9106;
    pub const GL_TEXTURE_SHADOW: GLenum = 0x82A1;
    pub const GL_TEXTURE_SHARED_SIZE: GLenum = 0x8C3F;
    pub const GL_TEXTURE_STENCIL_SIZE: GLenum = 0x88F1;
    pub const GL_TEXTURE_SWIZZLE_A: GLenum = 0x8E45;
    pub const GL_TEXTURE_SWIZZLE_B: GLenum = 0x8E44;
    pub const GL_TEXTURE_SWIZZLE_G: GLenum = 0x8E43;
    pub const GL_TEXTURE_SWIZZLE_R: GLenum = 0x8E42;
    pub const GL_TEXTURE_SWIZZLE_RGBA: GLenum = 0x8E46;
    pub const GL_TEXTURE_TARGET: GLenum = 0x1006;
    pub const GL_TEXTURE_UPDATE_BARRIER_BIT: GLbitfield = 0x00000100;
    pub const GL_TEXTURE_VIEW: GLenum = 0x82B5;
    pub const GL_TEXTURE_VIEW_MIN_LAYER: GLenum = 0x82DD;
    pub const GL_TEXTURE_VIEW_MIN_LEVEL: GLenum = 0x82DB;
    pub const GL_TEXTURE_VIEW_NUM_LAYERS: GLenum = 0x82DE;
    pub const GL_TEXTURE_VIEW_NUM_LEVELS: GLenum = 0x82DC;
    pub const GL_TEXTURE_WIDTH: GLenum = 0x1000;
    pub const GL_TEXTURE_WRAP_R: GLenum = 0x8072;
    pub const GL_TEXTURE_WRAP_S: GLenum = 0x2802;
    pub const GL_TEXTURE_WRAP_T: GLenum = 0x2803;
    pub const GL_TIMEOUT_EXPIRED: GLenum = 0x911B;
    pub const GL_TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
    pub const GL_TIMESTAMP: GLenum = 0x8E28;
    pub const GL_TIME_ELAPSED: GLenum = 0x88BF;
    pub const GL_TOP_LEVEL_ARRAY_SIZE: GLenum = 0x930C;
    pub const GL_TOP_LEVEL_ARRAY_STRIDE: GLenum = 0x930D;
    pub const GL_TRANSFORM_FEEDBACK: GLenum = 0x8E22;

    pub const GL_TRANSFORM_FEEDBACK_ACTIVE: GLenum = 0x8E24;
    pub const GL_TRANSFORM_FEEDBACK_BARRIER_BIT: GLbitfield = 0x00000800;
    pub const GL_TRANSFORM_FEEDBACK_BINDING: GLenum = 0x8E25;
    pub const GL_TRANSFORM_FEEDBACK_BUFFER: GLenum = 0x8C8E;
    pub const GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE: GLenum = 0x8E24;
    pub const GL_TRANSFORM_FEEDBACK_BUFFER_BINDING: GLenum = 0x8C8F;
    pub const GL_TRANSFORM_FEEDBACK_BUFFER_INDEX: GLenum = 0x934B;
    pub const GL_TRANSFORM_FEEDBACK_BUFFER_MODE: GLenum = 0x8C7F;
    pub const GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED: GLenum = 0x8E23;
    pub const GL_TRANSFORM_FEEDBACK_BUFFER_SIZE: GLenum = 0x8C85;
    pub const GL_TRANSFORM_FEEDBACK_BUFFER_START: GLenum = 0x8C84;
    pub const GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE: GLenum = 0x934C;
    pub const GL_TRANSFORM_FEEDBACK_OVERFLOW: GLenum = 0x82EC;

    pub const GL_TRANSFORM_FEEDBACK_PAUSED: GLenum = 0x8E23;
    pub const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: GLenum = 0x8C88;
    pub const GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW: GLenum = 0x82ED;
    pub const GL_TRANSFORM_FEEDBACK_VARYING: GLenum = 0x92F4;
    pub const GL_TRANSFORM_FEEDBACK_VARYINGS: GLenum = 0x8C83;
    pub const GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: GLenum = 0x8C76;
    pub const GL_TRIANGLES: GLenum = 0x0004;
    pub const GL_TRIANGLES_ADJACENCY: GLenum = 0x000C;
    pub const GL_TRIANGLE_FAN: GLenum = 0x0006;
    pub const GL_TRIANGLE_STRIP: GLenum = 0x0005;
    pub const GL_TRIANGLE_STRIP_ADJACENCY: GLenum = 0x000D;
    pub const GL_TRUE: GLenum = 1;
    pub const GL_TYPE: GLenum = 0x92FA;
    pub const GL_UNDEFINED_VERTEX: GLenum = 0x8260;
    pub const GL_UNIFORM: GLenum = 0x92E1;
    pub const GL_UNIFORM_ARRAY_STRIDE: GLenum = 0x8A3C;
    pub const GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX: GLenum = 0x92DA;
    pub const GL_UNIFORM_BARRIER_BIT: GLbitfield = 0x00000004;
    pub const GL_UNIFORM_BLOCK: GLenum = 0x92E2;
    pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: GLenum = 0x8A42;
    pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: GLenum = 0x8A43;
    pub const GL_UNIFORM_BLOCK_BINDING: GLenum = 0x8A3F;
    pub const GL_UNIFORM_BLOCK_DATA_SIZE: GLenum = 0x8A40;
    pub const GL_UNIFORM_BLOCK_INDEX: GLenum = 0x8A3A;
    pub const GL_UNIFORM_BLOCK_NAME_LENGTH: GLenum = 0x8A41;
    pub const GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x90EC;
    pub const GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x8A46;
    pub const GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x8A45;
    pub const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x84F0;
    pub const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x84F1;
    pub const GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x8A44;
    pub const GL_UNIFORM_BUFFER: GLenum = 0x8A11;
    pub const GL_UNIFORM_BUFFER_BINDING: GLenum = 0x8A28;
    pub const GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x8A34;
    pub const GL_UNIFORM_BUFFER_SIZE: GLenum = 0x8A2A;
    pub const GL_UNIFORM_BUFFER_START: GLenum = 0x8A29;
    pub const GL_UNIFORM_IS_ROW_MAJOR: GLenum = 0x8A3E;
    pub const GL_UNIFORM_MATRIX_STRIDE: GLenum = 0x8A3D;
    pub const GL_UNIFORM_NAME_LENGTH: GLenum = 0x8A39;
    pub const GL_UNIFORM_OFFSET: GLenum = 0x8A3B;
    pub const GL_UNIFORM_SIZE: GLenum = 0x8A38;
    pub const GL_UNIFORM_TYPE: GLenum = 0x8A37;
    pub const GL_UNKNOWN_CONTEXT_RESET: GLenum = 0x8255;
    pub const GL_UNPACK_ALIGNMENT: GLenum = 0x0CF5;
    pub const GL_UNPACK_COMPRESSED_BLOCK_DEPTH: GLenum = 0x9129;
    pub const GL_UNPACK_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x9128;
    pub const GL_UNPACK_COMPRESSED_BLOCK_SIZE: GLenum = 0x912A;
    pub const GL_UNPACK_COMPRESSED_BLOCK_WIDTH: GLenum = 0x9127;
    pub const GL_UNPACK_IMAGE_HEIGHT: GLenum = 0x806E;
    pub const GL_UNPACK_LSB_FIRST: GLenum = 0x0CF1;
    pub const GL_UNPACK_ROW_LENGTH: GLenum = 0x0CF2;
    pub const GL_UNPACK_SKIP_IMAGES: GLenum = 0x806D;
    pub const GL_UNPACK_SKIP_PIXELS: GLenum = 0x0CF4;
    pub const GL_UNPACK_SKIP_ROWS: GLenum = 0x0CF3;
    pub const GL_UNPACK_SWAP_BYTES: GLenum = 0x0CF0;
    pub const GL_UNSIGNALED: GLenum = 0x9118;
    pub const GL_UNSIGNED_BYTE: GLenum = 0x1401;
    pub const GL_UNSIGNED_BYTE_2_3_3_REV: GLenum = 0x8362;
    pub const GL_UNSIGNED_BYTE_3_3_2: GLenum = 0x8032;
    pub const GL_UNSIGNED_INT: GLenum = 0x1405;
    pub const GL_UNSIGNED_INT_10F_11F_11F_REV: GLenum = 0x8C3B;
    pub const GL_UNSIGNED_INT_10_10_10_2: GLenum = 0x8036;
    pub const GL_UNSIGNED_INT_24_8: GLenum = 0x84FA;
    pub const GL_UNSIGNED_INT_2_10_10_10_REV: GLenum = 0x8368;
    pub const GL_UNSIGNED_INT_5_9_9_9_REV: GLenum = 0x8C3E;
    pub const GL_UNSIGNED_INT_8_8_8_8: GLenum = 0x8035;
    pub const GL_UNSIGNED_INT_8_8_8_8_REV: GLenum = 0x8367;
    pub const GL_UNSIGNED_INT_ATOMIC_COUNTER: GLenum = 0x92DB;
    pub const GL_UNSIGNED_INT_IMAGE_1D: GLenum = 0x9062;
    pub const GL_UNSIGNED_INT_IMAGE_1D_ARRAY: GLenum = 0x9068;
    pub const GL_UNSIGNED_INT_IMAGE_2D: GLenum = 0x9063;
    pub const GL_UNSIGNED_INT_IMAGE_2D_ARRAY: GLenum = 0x9069;
    pub const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE: GLenum = 0x906B;
    pub const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x906C;
    pub const GL_UNSIGNED_INT_IMAGE_2D_RECT: GLenum = 0x9065;
    pub const GL_UNSIGNED_INT_IMAGE_3D: GLenum = 0x9064;
    pub const GL_UNSIGNED_INT_IMAGE_BUFFER: GLenum = 0x9067;
    pub const GL_UNSIGNED_INT_IMAGE_CUBE: GLenum = 0x9066;
    pub const GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x906A;
    pub const GL_UNSIGNED_INT_SAMPLER_1D: GLenum = 0x8DD1;
    pub const GL_UNSIGNED_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DD6;
    pub const GL_UNSIGNED_INT_SAMPLER_2D: GLenum = 0x8DD2;
    pub const GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DD7;
    pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x910A;
    pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910D;
    pub const GL_UNSIGNED_INT_SAMPLER_2D_RECT: GLenum = 0x8DD5;
    pub const GL_UNSIGNED_INT_SAMPLER_3D: GLenum = 0x8DD3;
    pub const GL_UNSIGNED_INT_SAMPLER_BUFFER: GLenum = 0x8DD8;
    pub const GL_UNSIGNED_INT_SAMPLER_CUBE: GLenum = 0x8DD4;
    pub const GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900F;
    pub const GL_UNSIGNED_INT_VEC2: GLenum = 0x8DC6;
    pub const GL_UNSIGNED_INT_VEC3: GLenum = 0x8DC7;
    pub const GL_UNSIGNED_INT_VEC4: GLenum = 0x8DC8;
    pub const GL_UNSIGNED_NORMALIZED: GLenum = 0x8C17;
    pub const GL_UNSIGNED_SHORT: GLenum = 0x1403;
    pub const GL_UNSIGNED_SHORT_1_5_5_5_REV: GLenum = 0x8366;
    pub const GL_UNSIGNED_SHORT_4_4_4_4: GLenum = 0x8033;
    pub const GL_UNSIGNED_SHORT_4_4_4_4_REV: GLenum = 0x8365;
    pub const GL_UNSIGNED_SHORT_5_5_5_1: GLenum = 0x8034;
    pub const GL_UNSIGNED_SHORT_5_6_5: GLenum = 0x8363;
    pub const GL_UNSIGNED_SHORT_5_6_5_REV: GLenum = 0x8364;
    pub const GL_UPPER_LEFT: GLenum = 0x8CA2;
    pub const GL_VALIDATE_STATUS: GLenum = 0x8B83;
    pub const GL_VENDOR: GLenum = 0x1F00;
    pub const GL_VERSION: GLenum = 0x1F02;
    pub const GL_VERTEX_ARRAY: GLenum = 0x8074;
    pub const GL_VERTEX_ARRAY_BINDING: GLenum = 0x85B5;
    pub const GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT: GLbitfield = 0x00000001;
    pub const GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum = 0x889F;
    pub const GL_VERTEX_ATTRIB_ARRAY_DIVISOR: GLenum = 0x88FE;
    pub const GL_VERTEX_ATTRIB_ARRAY_ENABLED: GLenum = 0x8622;
    pub const GL_VERTEX_ATTRIB_ARRAY_INTEGER: GLenum = 0x88FD;
    pub const GL_VERTEX_ATTRIB_ARRAY_LONG: GLenum = 0x874E;
    pub const GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum = 0x886A;
    pub const GL_VERTEX_ATTRIB_ARRAY_POINTER: GLenum = 0x8645;
    pub const GL_VERTEX_ATTRIB_ARRAY_SIZE: GLenum = 0x8623;
    pub const GL_VERTEX_ATTRIB_ARRAY_STRIDE: GLenum = 0x8624;
    pub const GL_VERTEX_ATTRIB_ARRAY_TYPE: GLenum = 0x8625;
    pub const GL_VERTEX_ATTRIB_BINDING: GLenum = 0x82D4;
    pub const GL_VERTEX_ATTRIB_RELATIVE_OFFSET: GLenum = 0x82D5;
    pub const GL_VERTEX_BINDING_BUFFER: GLenum = 0x8F4F;
    pub const GL_VERTEX_BINDING_DIVISOR: GLenum = 0x82D6;
    pub const GL_VERTEX_BINDING_OFFSET: GLenum = 0x82D7;
    pub const GL_VERTEX_BINDING_STRIDE: GLenum = 0x82D8;
    pub const GL_VERTEX_PROGRAM_POINT_SIZE: GLenum = 0x8642;
    pub const GL_VERTEX_SHADER: GLenum = 0x8B31;
    pub const GL_VERTEX_SHADER_BIT: GLbitfield = 0x00000001;
    pub const GL_VERTEX_SHADER_INVOCATIONS: GLenum = 0x82F0;
    pub const GL_VERTEX_SUBROUTINE: GLenum = 0x92E8;
    pub const GL_VERTEX_SUBROUTINE_UNIFORM: GLenum = 0x92EE;
    pub const GL_VERTEX_TEXTURE: GLenum = 0x829B;
    pub const GL_VERTICES_SUBMITTED: GLenum = 0x82EE;
    pub const GL_VIEWPORT: GLenum = 0x0BA2;
    pub const GL_VIEWPORT_BOUNDS_RANGE: GLenum = 0x825D;
    pub const GL_VIEWPORT_INDEX_PROVOKING_VERTEX: GLenum = 0x825F;
    pub const GL_VIEWPORT_SUBPIXEL_BITS: GLenum = 0x825C;
    pub const GL_VIEW_CLASS_128_BITS: GLenum = 0x82C4;
    pub const GL_VIEW_CLASS_16_BITS: GLenum = 0x82CA;
    pub const GL_VIEW_CLASS_24_BITS: GLenum = 0x82C9;
    pub const GL_VIEW_CLASS_32_BITS: GLenum = 0x82C8;
    pub const GL_VIEW_CLASS_48_BITS: GLenum = 0x82C7;
    pub const GL_VIEW_CLASS_64_BITS: GLenum = 0x82C6;
    pub const GL_VIEW_CLASS_8_BITS: GLenum = 0x82CB;
    pub const GL_VIEW_CLASS_96_BITS: GLenum = 0x82C5;
    pub const GL_VIEW_CLASS_BPTC_FLOAT: GLenum = 0x82D3;
    pub const GL_VIEW_CLASS_BPTC_UNORM: GLenum = 0x82D2;
    pub const GL_VIEW_CLASS_RGTC1_RED: GLenum = 0x82D0;
    pub const GL_VIEW_CLASS_RGTC2_RG: GLenum = 0x82D1;
    pub const GL_VIEW_CLASS_S3TC_DXT1_RGB: GLenum = 0x82CC;
    pub const GL_VIEW_CLASS_S3TC_DXT1_RGBA: GLenum = 0x82CD;
    pub const GL_VIEW_CLASS_S3TC_DXT3_RGBA: GLenum = 0x82CE;
    pub const GL_VIEW_CLASS_S3TC_DXT5_RGBA: GLenum = 0x82CF;
    pub const GL_VIEW_COMPATIBILITY_CLASS: GLenum = 0x82B6;
    pub const GL_WAIT_FAILED: GLenum = 0x911D;
    pub const GL_WRITE_ONLY: GLenum = 0x88B9;
    pub const GL_XOR: GLenum = 0x1506;
    pub const GL_ZERO: GLenum = 0;
    pub const GL_ZERO_TO_ONE: GLenum = 0x935F;
}

/// This is called to panic when a not-loaded function is attempted.
///
/// Placing the panic mechanism in this cold function generally helps code generation for the hot path.
/// Or so the sages say, at least.
#[cold]
#[inline(never)]
fn go_panic_because_fn_not_loaded(name: &str) -> ! {
    panic!("called {name} but it was not loaded.", name = name)
}

/// Loads a function pointer.
/// Rejects suggested pointer addresses which are likely to be lies.
/// This function is used by both the global loader and struct loader.
/// We mark it as `inline(never)` to favor a small binary over initialization speed.
/// Returns if there's now a non-null value in the atomic pointer.
#[inline(never)]
fn load_dyn_name_atomic_ptr(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    fn_name: &[u8],
    ptr: &APcv,
) -> bool {
    // if this fails the code generator itself royally screwed up somehow,
    // and so it's only a debug assert.
    debug_assert_eq!(*fn_name.last().unwrap(), 0);
    let p: *mut c_void = get_proc_address(fn_name.as_ptr() as *const c_char);
    let p_usize = p as usize;
    // You *should* get null for failed lookups, but some systems have been
    // reported to give "error code" values such as -1 or small non-null values.
    // To help guard against this silliness, we consider these values to also
    // just be a result of null.
    if p_usize == core::usize::MAX || p_usize < 8 {
        panic!(
            "Failed to load function {}",
            String::from_utf8_lossy(fn_name)
        );
        ptr.store(null_mut(), RELAX);
        false
    } else {
        ptr.store(p, RELAX);
        true
    }
}

/// Returns if an error was printed.
#[cfg(feature = "trace-errors")]
#[inline(never)]
fn report_error_code_from(name: &str, err: GLenum) {
    match err {
        GL_NO_ERROR => (),
        GL_INVALID_ENUM => error!("Invalid Enum to {name}.", name = name),
        GL_INVALID_VALUE => error!("Invalid Value to {name}.", name = name),
        GL_INVALID_OPERATION => error!("Invalid Operation to {name}.", name = name),
        GL_INVALID_FRAMEBUFFER_OPERATION => {
            error!("Invalid Framebuffer Operation to {name}.", name = name)
        }
        GL_OUT_OF_MEMORY => error!("Out of Memory in {name}.", name = name),
        GL_STACK_UNDERFLOW => error!("Stack Underflow in {name}.", name = name),
        GL_STACK_OVERFLOW => error!("Stack Overflow in {name}.", name = name),
        unknown => error!(
            "Unknown error code {unknown} to {name}.",
            name = name,
            unknown = unknown
        ),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_0arg<Ret>(name: &str, ptr: &APcv) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn() -> Ret>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_1arg<Ret, A>(name: &str, ptr: &APcv, a: A) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A) -> Ret>>(p) {
        Some(fn_p) => fn_p(a),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_2arg<Ret, A, B>(name: &str, ptr: &APcv, a: A, b: B) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_3arg<Ret, A, B, C>(name: &str, ptr: &APcv, a: A, b: B, c: C) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_4arg<Ret, A, B, C, D>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c, d),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_5arg<Ret, A, B, C, D, E>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c, d, e),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_6arg<Ret, A, B, C, D, E, F>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c, d, e, f),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_7arg<Ret, A, B, C, D, E, F, G>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F, G) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_8arg<Ret, A, B, C, D, E, F, G, H>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F, G, H) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_9arg<Ret, A, B, C, D, E, F, G, H, I>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
    i: I,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F, G, H, I) -> Ret>>(p)
    {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_10arg<Ret, A, B, C, D, E, F, G, H, I, J>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
    i: I,
    j: J,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F, G, H, I, J) -> Ret>>(
        p,
    ) {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i, j),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_11arg<Ret, A, B, C, D, E, F, G, H, I, J, K>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
    i: I,
    j: J,
    k: K,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F, G, H, I, J, K) -> Ret>>(
        p,
    ) {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i, j, k),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_12arg<Ret, A, B, C, D, E, F, G, H, I, J, K, L>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
    i: I,
    j: J,
    k: K,
    l: L,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<
        *mut c_void,
        Option<extern "system" fn(A, B, C, D, E, F, G, H, I, J, K, L) -> Ret>,
    >(p)
    {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i, j, k, l),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
unsafe fn call_atomic_ptr_15arg<Ret, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
    i: I,
    j: J,
    k: K,
    l: L,
    m: M,
    n: N,
    o: O,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<
        *mut c_void,
        Option<extern "system" fn(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) -> Ret>,
    >(p)
    {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o),
        None => go_panic_because_fn_not_loaded(name),
    }
}

pub use struct_commands::*;
pub mod struct_commands {
    //! Contains the [`GlFns`] type for using the struct GL loader.
    use super::*;
    impl GlFns {
        /// Constructs a new struct with all pointers loaded by the `get_proc_address` given.
        pub unsafe fn load_with<F>(mut get_proc_address: F) -> Self
        where
            F: FnMut(*const c_char) -> *mut c_void,
        {
            // Safety: The `GlFns` struct is nothing but `AtomicPtr` fields,
            // which can be safely constructed with `zeroed`.
            let out: Self = core::mem::zeroed();
            out.load_all_with_dyn(&mut get_proc_address);
            out
        }

        #[cfg(feature = "trace-errors")]
        #[inline(never)]
        unsafe fn automatic_glGetError(&self, name: &str) {
            let mut err = self.GetError();
            while err != GL_NO_ERROR {
                report_error_code_from(name, err);
                err = self.GetError();
            }
        }

        /// Loads all pointers using the `get_proc_address` given.

        #[inline(never)]
        pub unsafe fn load_all_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) {
            self.ActiveShaderProgram_load_with_dyn(get_proc_address);
            self.ActiveTexture_load_with_dyn(get_proc_address);
            self.AttachShader_load_with_dyn(get_proc_address);
            self.BeginConditionalRender_load_with_dyn(get_proc_address);
            self.BeginQuery_load_with_dyn(get_proc_address);
            self.BeginQueryIndexed_load_with_dyn(get_proc_address);
            self.BeginTransformFeedback_load_with_dyn(get_proc_address);
            self.BindAttribLocation_load_with_dyn(get_proc_address);
            self.BindBuffer_load_with_dyn(get_proc_address);
            self.BindBufferBase_load_with_dyn(get_proc_address);
            self.BindBufferRange_load_with_dyn(get_proc_address);
            self.BindBuffersBase_load_with_dyn(get_proc_address);
            self.BindBuffersRange_load_with_dyn(get_proc_address);
            self.BindFragDataLocation_load_with_dyn(get_proc_address);
            self.BindFragDataLocationIndexed_load_with_dyn(get_proc_address);
            self.BindFramebuffer_load_with_dyn(get_proc_address);
            self.BindImageTexture_load_with_dyn(get_proc_address);
            self.BindImageTextures_load_with_dyn(get_proc_address);
            self.BindProgramPipeline_load_with_dyn(get_proc_address);
            self.BindRenderbuffer_load_with_dyn(get_proc_address);
            self.BindSampler_load_with_dyn(get_proc_address);
            self.BindSamplers_load_with_dyn(get_proc_address);
            self.BindTexture_load_with_dyn(get_proc_address);
            self.BindTextureUnit_load_with_dyn(get_proc_address);
            self.BindTextures_load_with_dyn(get_proc_address);
            self.BindTransformFeedback_load_with_dyn(get_proc_address);
            self.BindVertexArray_load_with_dyn(get_proc_address);
            self.BindVertexBuffer_load_with_dyn(get_proc_address);
            self.BindVertexBuffers_load_with_dyn(get_proc_address);
            self.BlendColor_load_with_dyn(get_proc_address);
            self.BlendEquation_load_with_dyn(get_proc_address);
            self.BlendEquationSeparate_load_with_dyn(get_proc_address);
            self.BlendEquationSeparatei_load_with_dyn(get_proc_address);
            self.BlendEquationi_load_with_dyn(get_proc_address);
            self.BlendFunc_load_with_dyn(get_proc_address);
            self.BlendFuncSeparate_load_with_dyn(get_proc_address);
            self.BlendFuncSeparatei_load_with_dyn(get_proc_address);
            self.BlendFunci_load_with_dyn(get_proc_address);
            self.BlitFramebuffer_load_with_dyn(get_proc_address);
            self.BlitNamedFramebuffer_load_with_dyn(get_proc_address);
            self.BufferData_load_with_dyn(get_proc_address);
            self.BufferStorage_load_with_dyn(get_proc_address);
            self.BufferSubData_load_with_dyn(get_proc_address);
            self.CheckFramebufferStatus_load_with_dyn(get_proc_address);
            self.CheckNamedFramebufferStatus_load_with_dyn(get_proc_address);
            self.ClampColor_load_with_dyn(get_proc_address);
            self.Clear_load_with_dyn(get_proc_address);
            self.ClearBufferData_load_with_dyn(get_proc_address);
            self.ClearBufferSubData_load_with_dyn(get_proc_address);
            self.ClearBufferfi_load_with_dyn(get_proc_address);
            self.ClearBufferfv_load_with_dyn(get_proc_address);
            self.ClearBufferiv_load_with_dyn(get_proc_address);
            self.ClearBufferuiv_load_with_dyn(get_proc_address);
            self.ClearColor_load_with_dyn(get_proc_address);
            self.ClearDepth_load_with_dyn(get_proc_address);
            self.ClearDepthf_load_with_dyn(get_proc_address);
            self.ClearNamedBufferData_load_with_dyn(get_proc_address);
            self.ClearNamedBufferSubData_load_with_dyn(get_proc_address);
            self.ClearNamedFramebufferfi_load_with_dyn(get_proc_address);
            self.ClearNamedFramebufferfv_load_with_dyn(get_proc_address);
            self.ClearNamedFramebufferiv_load_with_dyn(get_proc_address);
            self.ClearNamedFramebufferuiv_load_with_dyn(get_proc_address);
            self.ClearStencil_load_with_dyn(get_proc_address);
            self.ClearTexImage_load_with_dyn(get_proc_address);
            self.ClearTexSubImage_load_with_dyn(get_proc_address);
            self.ClientWaitSync_load_with_dyn(get_proc_address);
            self.ClipControl_load_with_dyn(get_proc_address);
            self.ColorMask_load_with_dyn(get_proc_address);
            self.ColorMaski_load_with_dyn(get_proc_address);
            self.CompileShader_load_with_dyn(get_proc_address);
            self.CompressedTexImage1D_load_with_dyn(get_proc_address);
            self.CompressedTexImage2D_load_with_dyn(get_proc_address);
            self.CompressedTexImage3D_load_with_dyn(get_proc_address);
            self.CompressedTexSubImage1D_load_with_dyn(get_proc_address);
            self.CompressedTexSubImage2D_load_with_dyn(get_proc_address);
            self.CompressedTexSubImage3D_load_with_dyn(get_proc_address);
            self.CompressedTextureSubImage1D_load_with_dyn(get_proc_address);
            self.CompressedTextureSubImage2D_load_with_dyn(get_proc_address);
            self.CompressedTextureSubImage3D_load_with_dyn(get_proc_address);
            self.CopyBufferSubData_load_with_dyn(get_proc_address);
            self.CopyImageSubData_load_with_dyn(get_proc_address);
            self.CopyNamedBufferSubData_load_with_dyn(get_proc_address);
            self.CopyTexImage1D_load_with_dyn(get_proc_address);
            self.CopyTexImage2D_load_with_dyn(get_proc_address);
            self.CopyTexSubImage1D_load_with_dyn(get_proc_address);
            self.CopyTexSubImage2D_load_with_dyn(get_proc_address);
            self.CopyTexSubImage3D_load_with_dyn(get_proc_address);
            self.CopyTextureSubImage1D_load_with_dyn(get_proc_address);
            self.CopyTextureSubImage2D_load_with_dyn(get_proc_address);
            self.CopyTextureSubImage3D_load_with_dyn(get_proc_address);
            self.CreateBuffers_load_with_dyn(get_proc_address);
            self.CreateFramebuffers_load_with_dyn(get_proc_address);
            self.CreateProgram_load_with_dyn(get_proc_address);
            self.CreateProgramPipelines_load_with_dyn(get_proc_address);
            self.CreateQueries_load_with_dyn(get_proc_address);
            self.CreateRenderbuffers_load_with_dyn(get_proc_address);
            self.CreateSamplers_load_with_dyn(get_proc_address);
            self.CreateShader_load_with_dyn(get_proc_address);
            self.CreateShaderProgramv_load_with_dyn(get_proc_address);
            self.CreateTextures_load_with_dyn(get_proc_address);
            self.CreateTransformFeedbacks_load_with_dyn(get_proc_address);
            self.CreateVertexArrays_load_with_dyn(get_proc_address);
            self.CullFace_load_with_dyn(get_proc_address);
            self.DebugMessageCallback_load_with_dyn(get_proc_address);
            self.DebugMessageControl_load_with_dyn(get_proc_address);
            self.DebugMessageInsert_load_with_dyn(get_proc_address);
            self.DeleteBuffers_load_with_dyn(get_proc_address);
            self.DeleteFramebuffers_load_with_dyn(get_proc_address);
            self.DeleteProgram_load_with_dyn(get_proc_address);
            self.DeleteProgramPipelines_load_with_dyn(get_proc_address);
            self.DeleteQueries_load_with_dyn(get_proc_address);
            self.DeleteRenderbuffers_load_with_dyn(get_proc_address);
            self.DeleteSamplers_load_with_dyn(get_proc_address);
            self.DeleteShader_load_with_dyn(get_proc_address);
            self.DeleteSync_load_with_dyn(get_proc_address);
            self.DeleteTextures_load_with_dyn(get_proc_address);
            self.DeleteTransformFeedbacks_load_with_dyn(get_proc_address);
            self.DeleteVertexArrays_load_with_dyn(get_proc_address);
            self.DepthFunc_load_with_dyn(get_proc_address);
            self.DepthMask_load_with_dyn(get_proc_address);
            self.DepthRange_load_with_dyn(get_proc_address);
            self.DepthRangeArrayv_load_with_dyn(get_proc_address);
            self.DepthRangeIndexed_load_with_dyn(get_proc_address);
            self.DepthRangef_load_with_dyn(get_proc_address);
            self.DetachShader_load_with_dyn(get_proc_address);
            self.Disable_load_with_dyn(get_proc_address);
            self.DisableVertexArrayAttrib_load_with_dyn(get_proc_address);
            self.DisableVertexAttribArray_load_with_dyn(get_proc_address);
            self.Disablei_load_with_dyn(get_proc_address);
            self.DispatchCompute_load_with_dyn(get_proc_address);
            self.DispatchComputeIndirect_load_with_dyn(get_proc_address);
            self.DrawArrays_load_with_dyn(get_proc_address);
            self.DrawArraysIndirect_load_with_dyn(get_proc_address);
            self.DrawArraysInstanced_load_with_dyn(get_proc_address);
            self.DrawArraysInstancedBaseInstance_load_with_dyn(get_proc_address);
            self.DrawBuffer_load_with_dyn(get_proc_address);
            self.DrawBuffers_load_with_dyn(get_proc_address);
            self.DrawElements_load_with_dyn(get_proc_address);
            self.DrawElementsBaseVertex_load_with_dyn(get_proc_address);
            self.DrawElementsIndirect_load_with_dyn(get_proc_address);
            self.DrawElementsInstanced_load_with_dyn(get_proc_address);
            self.DrawElementsInstancedBaseInstance_load_with_dyn(get_proc_address);
            self.DrawElementsInstancedBaseVertex_load_with_dyn(get_proc_address);
            self.DrawElementsInstancedBaseVertexBaseInstance_load_with_dyn(get_proc_address);
            self.DrawRangeElements_load_with_dyn(get_proc_address);
            self.DrawRangeElementsBaseVertex_load_with_dyn(get_proc_address);
            self.DrawTransformFeedback_load_with_dyn(get_proc_address);
            self.DrawTransformFeedbackInstanced_load_with_dyn(get_proc_address);
            self.DrawTransformFeedbackStream_load_with_dyn(get_proc_address);
            self.DrawTransformFeedbackStreamInstanced_load_with_dyn(get_proc_address);
            self.Enable_load_with_dyn(get_proc_address);
            self.EnableVertexArrayAttrib_load_with_dyn(get_proc_address);
            self.EnableVertexAttribArray_load_with_dyn(get_proc_address);
            self.Enablei_load_with_dyn(get_proc_address);
            self.EndConditionalRender_load_with_dyn(get_proc_address);
            self.EndQuery_load_with_dyn(get_proc_address);
            self.EndQueryIndexed_load_with_dyn(get_proc_address);
            self.EndTransformFeedback_load_with_dyn(get_proc_address);
            self.FenceSync_load_with_dyn(get_proc_address);
            self.Finish_load_with_dyn(get_proc_address);
            self.Flush_load_with_dyn(get_proc_address);
            self.FlushMappedBufferRange_load_with_dyn(get_proc_address);
            self.FlushMappedNamedBufferRange_load_with_dyn(get_proc_address);
            self.FramebufferParameteri_load_with_dyn(get_proc_address);
            self.FramebufferRenderbuffer_load_with_dyn(get_proc_address);
            self.FramebufferTexture_load_with_dyn(get_proc_address);
            self.FramebufferTexture1D_load_with_dyn(get_proc_address);
            self.FramebufferTexture2D_load_with_dyn(get_proc_address);
            self.FramebufferTexture3D_load_with_dyn(get_proc_address);
            self.FramebufferTextureLayer_load_with_dyn(get_proc_address);
            self.FrontFace_load_with_dyn(get_proc_address);
            self.GenBuffers_load_with_dyn(get_proc_address);
            self.GenFramebuffers_load_with_dyn(get_proc_address);
            self.GenProgramPipelines_load_with_dyn(get_proc_address);
            self.GenQueries_load_with_dyn(get_proc_address);
            self.GenRenderbuffers_load_with_dyn(get_proc_address);
            self.GenSamplers_load_with_dyn(get_proc_address);
            self.GenTextures_load_with_dyn(get_proc_address);
            self.GenTransformFeedbacks_load_with_dyn(get_proc_address);
            self.GenVertexArrays_load_with_dyn(get_proc_address);
            self.GenerateMipmap_load_with_dyn(get_proc_address);
            self.GenerateTextureMipmap_load_with_dyn(get_proc_address);
            self.GetActiveAtomicCounterBufferiv_load_with_dyn(get_proc_address);
            self.GetActiveAttrib_load_with_dyn(get_proc_address);
            self.GetActiveSubroutineName_load_with_dyn(get_proc_address);
            self.GetActiveSubroutineUniformName_load_with_dyn(get_proc_address);
            self.GetActiveSubroutineUniformiv_load_with_dyn(get_proc_address);
            self.GetActiveUniform_load_with_dyn(get_proc_address);
            self.GetActiveUniformBlockName_load_with_dyn(get_proc_address);
            self.GetActiveUniformBlockiv_load_with_dyn(get_proc_address);
            self.GetActiveUniformName_load_with_dyn(get_proc_address);
            self.GetActiveUniformsiv_load_with_dyn(get_proc_address);
            self.GetAttachedShaders_load_with_dyn(get_proc_address);
            self.GetAttribLocation_load_with_dyn(get_proc_address);
            self.GetBooleani_v_load_with_dyn(get_proc_address);
            self.GetBooleanv_load_with_dyn(get_proc_address);
            self.GetBufferParameteri64v_load_with_dyn(get_proc_address);
            self.GetBufferParameteriv_load_with_dyn(get_proc_address);
            self.GetBufferPointerv_load_with_dyn(get_proc_address);
            self.GetBufferSubData_load_with_dyn(get_proc_address);
            self.GetCompressedTexImage_load_with_dyn(get_proc_address);
            self.GetCompressedTextureImage_load_with_dyn(get_proc_address);
            self.GetCompressedTextureSubImage_load_with_dyn(get_proc_address);
            self.GetDebugMessageLog_load_with_dyn(get_proc_address);
            self.GetDoublei_v_load_with_dyn(get_proc_address);
            self.GetDoublev_load_with_dyn(get_proc_address);
            self.GetError_load_with_dyn(get_proc_address);
            self.GetFloati_v_load_with_dyn(get_proc_address);
            self.GetFloatv_load_with_dyn(get_proc_address);
            self.GetFragDataIndex_load_with_dyn(get_proc_address);
            self.GetFragDataLocation_load_with_dyn(get_proc_address);
            self.GetFramebufferAttachmentParameteriv_load_with_dyn(get_proc_address);
            self.GetFramebufferParameteriv_load_with_dyn(get_proc_address);
            self.GetGraphicsResetStatus_load_with_dyn(get_proc_address);
            self.GetInteger64i_v_load_with_dyn(get_proc_address);
            self.GetInteger64v_load_with_dyn(get_proc_address);
            self.GetIntegeri_v_load_with_dyn(get_proc_address);
            self.GetIntegerv_load_with_dyn(get_proc_address);
            self.GetInternalformati64v_load_with_dyn(get_proc_address);
            self.GetInternalformativ_load_with_dyn(get_proc_address);
            self.GetMultisamplefv_load_with_dyn(get_proc_address);
            self.GetNamedBufferParameteri64v_load_with_dyn(get_proc_address);
            self.GetNamedBufferParameteriv_load_with_dyn(get_proc_address);
            self.GetNamedBufferPointerv_load_with_dyn(get_proc_address);
            self.GetNamedBufferSubData_load_with_dyn(get_proc_address);
            self.GetNamedFramebufferAttachmentParameteriv_load_with_dyn(get_proc_address);
            self.GetNamedFramebufferParameteriv_load_with_dyn(get_proc_address);
            self.GetNamedRenderbufferParameteriv_load_with_dyn(get_proc_address);
            self.GetObjectLabel_load_with_dyn(get_proc_address);
            self.GetObjectPtrLabel_load_with_dyn(get_proc_address);
            self.GetPointerv_load_with_dyn(get_proc_address);
            self.GetProgramBinary_load_with_dyn(get_proc_address);
            self.GetProgramInfoLog_load_with_dyn(get_proc_address);
            self.GetProgramInterfaceiv_load_with_dyn(get_proc_address);
            self.GetProgramPipelineInfoLog_load_with_dyn(get_proc_address);
            self.GetProgramPipelineiv_load_with_dyn(get_proc_address);
            self.GetProgramResourceIndex_load_with_dyn(get_proc_address);
            self.GetProgramResourceLocation_load_with_dyn(get_proc_address);
            self.GetProgramResourceLocationIndex_load_with_dyn(get_proc_address);
            self.GetProgramResourceName_load_with_dyn(get_proc_address);
            self.GetProgramResourceiv_load_with_dyn(get_proc_address);
            self.GetProgramStageiv_load_with_dyn(get_proc_address);
            self.GetProgramiv_load_with_dyn(get_proc_address);
            self.GetQueryBufferObjecti64v_load_with_dyn(get_proc_address);
            self.GetQueryBufferObjectiv_load_with_dyn(get_proc_address);
            self.GetQueryBufferObjectui64v_load_with_dyn(get_proc_address);
            self.GetQueryBufferObjectuiv_load_with_dyn(get_proc_address);
            self.GetQueryIndexediv_load_with_dyn(get_proc_address);
            self.GetQueryObjecti64v_load_with_dyn(get_proc_address);
            self.GetQueryObjectiv_load_with_dyn(get_proc_address);
            self.GetQueryObjectui64v_load_with_dyn(get_proc_address);
            self.GetQueryObjectuiv_load_with_dyn(get_proc_address);
            self.GetQueryiv_load_with_dyn(get_proc_address);
            self.GetRenderbufferParameteriv_load_with_dyn(get_proc_address);
            self.GetSamplerParameterIiv_load_with_dyn(get_proc_address);
            self.GetSamplerParameterIuiv_load_with_dyn(get_proc_address);
            self.GetSamplerParameterfv_load_with_dyn(get_proc_address);
            self.GetSamplerParameteriv_load_with_dyn(get_proc_address);
            self.GetShaderInfoLog_load_with_dyn(get_proc_address);
            self.GetShaderPrecisionFormat_load_with_dyn(get_proc_address);
            self.GetShaderSource_load_with_dyn(get_proc_address);
            self.GetShaderiv_load_with_dyn(get_proc_address);
            self.GetString_load_with_dyn(get_proc_address);
            self.GetStringi_load_with_dyn(get_proc_address);
            self.GetSubroutineIndex_load_with_dyn(get_proc_address);
            self.GetSubroutineUniformLocation_load_with_dyn(get_proc_address);
            self.GetSynciv_load_with_dyn(get_proc_address);
            self.GetTexImage_load_with_dyn(get_proc_address);
            self.GetTexLevelParameterfv_load_with_dyn(get_proc_address);
            self.GetTexLevelParameteriv_load_with_dyn(get_proc_address);
            self.GetTexParameterIiv_load_with_dyn(get_proc_address);
            self.GetTexParameterIuiv_load_with_dyn(get_proc_address);
            self.GetTexParameterfv_load_with_dyn(get_proc_address);
            self.GetTexParameteriv_load_with_dyn(get_proc_address);
            self.GetTextureImage_load_with_dyn(get_proc_address);
            self.GetTextureLevelParameterfv_load_with_dyn(get_proc_address);
            self.GetTextureLevelParameteriv_load_with_dyn(get_proc_address);
            self.GetTextureParameterIiv_load_with_dyn(get_proc_address);
            self.GetTextureParameterIuiv_load_with_dyn(get_proc_address);
            self.GetTextureParameterfv_load_with_dyn(get_proc_address);
            self.GetTextureParameteriv_load_with_dyn(get_proc_address);
            self.GetTextureSubImage_load_with_dyn(get_proc_address);
            self.GetTransformFeedbackVarying_load_with_dyn(get_proc_address);
            self.GetTransformFeedbacki64_v_load_with_dyn(get_proc_address);
            self.GetTransformFeedbacki_v_load_with_dyn(get_proc_address);
            self.GetTransformFeedbackiv_load_with_dyn(get_proc_address);
            self.GetUniformBlockIndex_load_with_dyn(get_proc_address);
            self.GetUniformIndices_load_with_dyn(get_proc_address);
            self.GetUniformLocation_load_with_dyn(get_proc_address);
            self.GetUniformSubroutineuiv_load_with_dyn(get_proc_address);
            self.GetUniformdv_load_with_dyn(get_proc_address);
            self.GetUniformfv_load_with_dyn(get_proc_address);
            self.GetUniformiv_load_with_dyn(get_proc_address);
            self.GetUniformuiv_load_with_dyn(get_proc_address);
            self.GetVertexArrayIndexed64iv_load_with_dyn(get_proc_address);
            self.GetVertexArrayIndexediv_load_with_dyn(get_proc_address);
            self.GetVertexArrayiv_load_with_dyn(get_proc_address);
            self.GetVertexAttribIiv_load_with_dyn(get_proc_address);
            self.GetVertexAttribIuiv_load_with_dyn(get_proc_address);
            self.GetVertexAttribLdv_load_with_dyn(get_proc_address);
            self.GetVertexAttribPointerv_load_with_dyn(get_proc_address);
            self.GetVertexAttribdv_load_with_dyn(get_proc_address);
            self.GetVertexAttribfv_load_with_dyn(get_proc_address);
            self.GetVertexAttribiv_load_with_dyn(get_proc_address);
            self.GetnCompressedTexImage_load_with_dyn(get_proc_address);
            self.GetnTexImage_load_with_dyn(get_proc_address);
            self.GetnUniformdv_load_with_dyn(get_proc_address);
            self.GetnUniformfv_load_with_dyn(get_proc_address);
            self.GetnUniformiv_load_with_dyn(get_proc_address);
            self.GetnUniformuiv_load_with_dyn(get_proc_address);
            self.Hint_load_with_dyn(get_proc_address);
            self.InvalidateBufferData_load_with_dyn(get_proc_address);
            self.InvalidateBufferSubData_load_with_dyn(get_proc_address);
            self.InvalidateFramebuffer_load_with_dyn(get_proc_address);
            self.InvalidateNamedFramebufferData_load_with_dyn(get_proc_address);
            self.InvalidateNamedFramebufferSubData_load_with_dyn(get_proc_address);
            self.InvalidateSubFramebuffer_load_with_dyn(get_proc_address);
            self.InvalidateTexImage_load_with_dyn(get_proc_address);
            self.InvalidateTexSubImage_load_with_dyn(get_proc_address);
            self.IsBuffer_load_with_dyn(get_proc_address);
            self.IsEnabled_load_with_dyn(get_proc_address);
            self.IsEnabledi_load_with_dyn(get_proc_address);
            self.IsFramebuffer_load_with_dyn(get_proc_address);
            self.IsProgram_load_with_dyn(get_proc_address);
            self.IsProgramPipeline_load_with_dyn(get_proc_address);
            self.IsQuery_load_with_dyn(get_proc_address);
            self.IsRenderbuffer_load_with_dyn(get_proc_address);
            self.IsSampler_load_with_dyn(get_proc_address);
            self.IsShader_load_with_dyn(get_proc_address);
            self.IsSync_load_with_dyn(get_proc_address);
            self.IsTexture_load_with_dyn(get_proc_address);
            self.IsTransformFeedback_load_with_dyn(get_proc_address);
            self.IsVertexArray_load_with_dyn(get_proc_address);
            self.LineWidth_load_with_dyn(get_proc_address);
            self.LinkProgram_load_with_dyn(get_proc_address);
            self.LogicOp_load_with_dyn(get_proc_address);
            self.MapBuffer_load_with_dyn(get_proc_address);
            self.MapBufferRange_load_with_dyn(get_proc_address);
            self.MapNamedBuffer_load_with_dyn(get_proc_address);
            self.MapNamedBufferRange_load_with_dyn(get_proc_address);
            self.MemoryBarrier_load_with_dyn(get_proc_address);
            self.MemoryBarrierByRegion_load_with_dyn(get_proc_address);
            self.MinSampleShading_load_with_dyn(get_proc_address);
            self.MultiDrawArrays_load_with_dyn(get_proc_address);
            self.MultiDrawArraysIndirect_load_with_dyn(get_proc_address);
            self.MultiDrawArraysIndirectCount_load_with_dyn(get_proc_address);
            self.MultiDrawElements_load_with_dyn(get_proc_address);
            self.MultiDrawElementsBaseVertex_load_with_dyn(get_proc_address);
            self.MultiDrawElementsIndirect_load_with_dyn(get_proc_address);
            self.MultiDrawElementsIndirectCount_load_with_dyn(get_proc_address);
            self.NamedBufferData_load_with_dyn(get_proc_address);
            self.NamedBufferStorage_load_with_dyn(get_proc_address);
            self.NamedBufferSubData_load_with_dyn(get_proc_address);
            self.NamedFramebufferDrawBuffer_load_with_dyn(get_proc_address);
            self.NamedFramebufferDrawBuffers_load_with_dyn(get_proc_address);
            self.NamedFramebufferParameteri_load_with_dyn(get_proc_address);
            self.NamedFramebufferReadBuffer_load_with_dyn(get_proc_address);
            self.NamedFramebufferRenderbuffer_load_with_dyn(get_proc_address);
            self.NamedFramebufferTexture_load_with_dyn(get_proc_address);
            self.NamedFramebufferTextureLayer_load_with_dyn(get_proc_address);
            self.NamedRenderbufferStorage_load_with_dyn(get_proc_address);
            self.NamedRenderbufferStorageMultisample_load_with_dyn(get_proc_address);
            self.ObjectLabel_load_with_dyn(get_proc_address);
            self.ObjectPtrLabel_load_with_dyn(get_proc_address);
            self.PatchParameterfv_load_with_dyn(get_proc_address);
            self.PatchParameteri_load_with_dyn(get_proc_address);
            self.PauseTransformFeedback_load_with_dyn(get_proc_address);
            self.PixelStoref_load_with_dyn(get_proc_address);
            self.PixelStorei_load_with_dyn(get_proc_address);
            self.PointParameterf_load_with_dyn(get_proc_address);
            self.PointParameterfv_load_with_dyn(get_proc_address);
            self.PointParameteri_load_with_dyn(get_proc_address);
            self.PointParameteriv_load_with_dyn(get_proc_address);
            self.PointSize_load_with_dyn(get_proc_address);
            self.PolygonMode_load_with_dyn(get_proc_address);
            self.PolygonOffset_load_with_dyn(get_proc_address);
            self.PolygonOffsetClamp_load_with_dyn(get_proc_address);
            self.PopDebugGroup_load_with_dyn(get_proc_address);
            self.PrimitiveRestartIndex_load_with_dyn(get_proc_address);
            self.ProgramBinary_load_with_dyn(get_proc_address);
            self.ProgramParameteri_load_with_dyn(get_proc_address);
            self.ProgramUniform1d_load_with_dyn(get_proc_address);
            self.ProgramUniform1dv_load_with_dyn(get_proc_address);
            self.ProgramUniform1f_load_with_dyn(get_proc_address);
            self.ProgramUniform1fv_load_with_dyn(get_proc_address);
            self.ProgramUniform1i_load_with_dyn(get_proc_address);
            self.ProgramUniform1iv_load_with_dyn(get_proc_address);
            self.ProgramUniform1ui_load_with_dyn(get_proc_address);
            self.ProgramUniform1uiv_load_with_dyn(get_proc_address);
            self.ProgramUniform2d_load_with_dyn(get_proc_address);
            self.ProgramUniform2dv_load_with_dyn(get_proc_address);
            self.ProgramUniform2f_load_with_dyn(get_proc_address);
            self.ProgramUniform2fv_load_with_dyn(get_proc_address);
            self.ProgramUniform2i_load_with_dyn(get_proc_address);
            self.ProgramUniform2iv_load_with_dyn(get_proc_address);
            self.ProgramUniform2ui_load_with_dyn(get_proc_address);
            self.ProgramUniform2uiv_load_with_dyn(get_proc_address);
            self.ProgramUniform3d_load_with_dyn(get_proc_address);
            self.ProgramUniform3dv_load_with_dyn(get_proc_address);
            self.ProgramUniform3f_load_with_dyn(get_proc_address);
            self.ProgramUniform3fv_load_with_dyn(get_proc_address);
            self.ProgramUniform3i_load_with_dyn(get_proc_address);
            self.ProgramUniform3iv_load_with_dyn(get_proc_address);
            self.ProgramUniform3ui_load_with_dyn(get_proc_address);
            self.ProgramUniform3uiv_load_with_dyn(get_proc_address);
            self.ProgramUniform4d_load_with_dyn(get_proc_address);
            self.ProgramUniform4dv_load_with_dyn(get_proc_address);
            self.ProgramUniform4f_load_with_dyn(get_proc_address);
            self.ProgramUniform4fv_load_with_dyn(get_proc_address);
            self.ProgramUniform4i_load_with_dyn(get_proc_address);
            self.ProgramUniform4iv_load_with_dyn(get_proc_address);
            self.ProgramUniform4ui_load_with_dyn(get_proc_address);
            self.ProgramUniform4uiv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix2dv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix2fv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix2x3dv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix2x3fv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix2x4dv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix2x4fv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix3dv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix3fv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix3x2dv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix3x2fv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix3x4dv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix3x4fv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix4dv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix4fv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix4x2dv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix4x2fv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix4x3dv_load_with_dyn(get_proc_address);
            self.ProgramUniformMatrix4x3fv_load_with_dyn(get_proc_address);
            self.ProvokingVertex_load_with_dyn(get_proc_address);
            self.PushDebugGroup_load_with_dyn(get_proc_address);
            self.QueryCounter_load_with_dyn(get_proc_address);
            self.ReadBuffer_load_with_dyn(get_proc_address);
            self.ReadPixels_load_with_dyn(get_proc_address);
            self.ReadnPixels_load_with_dyn(get_proc_address);
            self.ReleaseShaderCompiler_load_with_dyn(get_proc_address);
            self.RenderbufferStorage_load_with_dyn(get_proc_address);
            self.RenderbufferStorageMultisample_load_with_dyn(get_proc_address);
            self.ResumeTransformFeedback_load_with_dyn(get_proc_address);
            self.SampleCoverage_load_with_dyn(get_proc_address);
            self.SampleMaski_load_with_dyn(get_proc_address);
            self.SamplerParameterIiv_load_with_dyn(get_proc_address);
            self.SamplerParameterIuiv_load_with_dyn(get_proc_address);
            self.SamplerParameterf_load_with_dyn(get_proc_address);
            self.SamplerParameterfv_load_with_dyn(get_proc_address);
            self.SamplerParameteri_load_with_dyn(get_proc_address);
            self.SamplerParameteriv_load_with_dyn(get_proc_address);
            self.Scissor_load_with_dyn(get_proc_address);
            self.ScissorArrayv_load_with_dyn(get_proc_address);
            self.ScissorIndexed_load_with_dyn(get_proc_address);
            self.ScissorIndexedv_load_with_dyn(get_proc_address);
            self.ShaderBinary_load_with_dyn(get_proc_address);
            self.ShaderSource_load_with_dyn(get_proc_address);
            self.ShaderStorageBlockBinding_load_with_dyn(get_proc_address);
            self.SpecializeShader_load_with_dyn(get_proc_address);
            self.StencilFunc_load_with_dyn(get_proc_address);
            self.StencilFuncSeparate_load_with_dyn(get_proc_address);
            self.StencilMask_load_with_dyn(get_proc_address);
            self.StencilMaskSeparate_load_with_dyn(get_proc_address);
            self.StencilOp_load_with_dyn(get_proc_address);
            self.StencilOpSeparate_load_with_dyn(get_proc_address);
            self.TexBuffer_load_with_dyn(get_proc_address);
            self.TexBufferRange_load_with_dyn(get_proc_address);
            self.TexImage1D_load_with_dyn(get_proc_address);
            self.TexImage2D_load_with_dyn(get_proc_address);
            self.TexImage2DMultisample_load_with_dyn(get_proc_address);
            self.TexImage3D_load_with_dyn(get_proc_address);
            self.TexImage3DMultisample_load_with_dyn(get_proc_address);
            self.TexParameterIiv_load_with_dyn(get_proc_address);
            self.TexParameterIuiv_load_with_dyn(get_proc_address);
            self.TexParameterf_load_with_dyn(get_proc_address);
            self.TexParameterfv_load_with_dyn(get_proc_address);
            self.TexParameteri_load_with_dyn(get_proc_address);
            self.TexParameteriv_load_with_dyn(get_proc_address);
            self.TexStorage1D_load_with_dyn(get_proc_address);
            self.TexStorage2D_load_with_dyn(get_proc_address);
            self.TexStorage2DMultisample_load_with_dyn(get_proc_address);
            self.TexStorage3D_load_with_dyn(get_proc_address);
            self.TexStorage3DMultisample_load_with_dyn(get_proc_address);
            self.TexSubImage1D_load_with_dyn(get_proc_address);
            self.TexSubImage2D_load_with_dyn(get_proc_address);
            self.TexSubImage3D_load_with_dyn(get_proc_address);
            self.TextureBarrier_load_with_dyn(get_proc_address);
            self.TextureBuffer_load_with_dyn(get_proc_address);
            self.TextureBufferRange_load_with_dyn(get_proc_address);
            self.TextureParameterIiv_load_with_dyn(get_proc_address);
            self.TextureParameterIuiv_load_with_dyn(get_proc_address);
            self.TextureParameterf_load_with_dyn(get_proc_address);
            self.TextureParameterfv_load_with_dyn(get_proc_address);
            self.TextureParameteri_load_with_dyn(get_proc_address);
            self.TextureParameteriv_load_with_dyn(get_proc_address);
            self.TextureStorage1D_load_with_dyn(get_proc_address);
            self.TextureStorage2D_load_with_dyn(get_proc_address);
            self.TextureStorage2DMultisample_load_with_dyn(get_proc_address);
            self.TextureStorage3D_load_with_dyn(get_proc_address);
            self.TextureStorage3DMultisample_load_with_dyn(get_proc_address);
            self.TextureSubImage1D_load_with_dyn(get_proc_address);
            self.TextureSubImage2D_load_with_dyn(get_proc_address);
            self.TextureSubImage3D_load_with_dyn(get_proc_address);
            self.TextureView_load_with_dyn(get_proc_address);
            self.TransformFeedbackBufferBase_load_with_dyn(get_proc_address);
            self.TransformFeedbackBufferRange_load_with_dyn(get_proc_address);
            self.TransformFeedbackVaryings_load_with_dyn(get_proc_address);
            self.Uniform1d_load_with_dyn(get_proc_address);
            self.Uniform1dv_load_with_dyn(get_proc_address);
            self.Uniform1f_load_with_dyn(get_proc_address);
            self.Uniform1fv_load_with_dyn(get_proc_address);
            self.Uniform1i_load_with_dyn(get_proc_address);
            self.Uniform1iv_load_with_dyn(get_proc_address);
            self.Uniform1ui_load_with_dyn(get_proc_address);
            self.Uniform1uiv_load_with_dyn(get_proc_address);
            self.Uniform2d_load_with_dyn(get_proc_address);
            self.Uniform2dv_load_with_dyn(get_proc_address);
            self.Uniform2f_load_with_dyn(get_proc_address);
            self.Uniform2fv_load_with_dyn(get_proc_address);
            self.Uniform2i_load_with_dyn(get_proc_address);
            self.Uniform2iv_load_with_dyn(get_proc_address);
            self.Uniform2ui_load_with_dyn(get_proc_address);
            self.Uniform2uiv_load_with_dyn(get_proc_address);
            self.Uniform3d_load_with_dyn(get_proc_address);
            self.Uniform3dv_load_with_dyn(get_proc_address);
            self.Uniform3f_load_with_dyn(get_proc_address);
            self.Uniform3fv_load_with_dyn(get_proc_address);
            self.Uniform3i_load_with_dyn(get_proc_address);
            self.Uniform3iv_load_with_dyn(get_proc_address);
            self.Uniform3ui_load_with_dyn(get_proc_address);
            self.Uniform3uiv_load_with_dyn(get_proc_address);
            self.Uniform4d_load_with_dyn(get_proc_address);
            self.Uniform4dv_load_with_dyn(get_proc_address);
            self.Uniform4f_load_with_dyn(get_proc_address);
            self.Uniform4fv_load_with_dyn(get_proc_address);
            self.Uniform4i_load_with_dyn(get_proc_address);
            self.Uniform4iv_load_with_dyn(get_proc_address);
            self.Uniform4ui_load_with_dyn(get_proc_address);
            self.Uniform4uiv_load_with_dyn(get_proc_address);
            self.UniformBlockBinding_load_with_dyn(get_proc_address);
            self.UniformMatrix2dv_load_with_dyn(get_proc_address);
            self.UniformMatrix2fv_load_with_dyn(get_proc_address);
            self.UniformMatrix2x3dv_load_with_dyn(get_proc_address);
            self.UniformMatrix2x3fv_load_with_dyn(get_proc_address);
            self.UniformMatrix2x4dv_load_with_dyn(get_proc_address);
            self.UniformMatrix2x4fv_load_with_dyn(get_proc_address);
            self.UniformMatrix3dv_load_with_dyn(get_proc_address);
            self.UniformMatrix3fv_load_with_dyn(get_proc_address);
            self.UniformMatrix3x2dv_load_with_dyn(get_proc_address);
            self.UniformMatrix3x2fv_load_with_dyn(get_proc_address);
            self.UniformMatrix3x4dv_load_with_dyn(get_proc_address);
            self.UniformMatrix3x4fv_load_with_dyn(get_proc_address);
            self.UniformMatrix4dv_load_with_dyn(get_proc_address);
            self.UniformMatrix4fv_load_with_dyn(get_proc_address);
            self.UniformMatrix4x2dv_load_with_dyn(get_proc_address);
            self.UniformMatrix4x2fv_load_with_dyn(get_proc_address);
            self.UniformMatrix4x3dv_load_with_dyn(get_proc_address);
            self.UniformMatrix4x3fv_load_with_dyn(get_proc_address);
            self.UniformSubroutinesuiv_load_with_dyn(get_proc_address);
            self.UnmapBuffer_load_with_dyn(get_proc_address);
            self.UnmapNamedBuffer_load_with_dyn(get_proc_address);
            self.UseProgram_load_with_dyn(get_proc_address);
            self.UseProgramStages_load_with_dyn(get_proc_address);
            self.ValidateProgram_load_with_dyn(get_proc_address);
            self.ValidateProgramPipeline_load_with_dyn(get_proc_address);
            self.VertexArrayAttribBinding_load_with_dyn(get_proc_address);
            self.VertexArrayAttribFormat_load_with_dyn(get_proc_address);
            self.VertexArrayAttribIFormat_load_with_dyn(get_proc_address);
            self.VertexArrayAttribLFormat_load_with_dyn(get_proc_address);
            self.VertexArrayBindingDivisor_load_with_dyn(get_proc_address);
            self.VertexArrayElementBuffer_load_with_dyn(get_proc_address);
            self.VertexArrayVertexBuffer_load_with_dyn(get_proc_address);
            self.VertexArrayVertexBuffers_load_with_dyn(get_proc_address);
            self.VertexAttrib1d_load_with_dyn(get_proc_address);
            self.VertexAttrib1dv_load_with_dyn(get_proc_address);
            self.VertexAttrib1f_load_with_dyn(get_proc_address);
            self.VertexAttrib1fv_load_with_dyn(get_proc_address);
            self.VertexAttrib1s_load_with_dyn(get_proc_address);
            self.VertexAttrib1sv_load_with_dyn(get_proc_address);
            self.VertexAttrib2d_load_with_dyn(get_proc_address);
            self.VertexAttrib2dv_load_with_dyn(get_proc_address);
            self.VertexAttrib2f_load_with_dyn(get_proc_address);
            self.VertexAttrib2fv_load_with_dyn(get_proc_address);
            self.VertexAttrib2s_load_with_dyn(get_proc_address);
            self.VertexAttrib2sv_load_with_dyn(get_proc_address);
            self.VertexAttrib3d_load_with_dyn(get_proc_address);
            self.VertexAttrib3dv_load_with_dyn(get_proc_address);
            self.VertexAttrib3f_load_with_dyn(get_proc_address);
            self.VertexAttrib3fv_load_with_dyn(get_proc_address);
            self.VertexAttrib3s_load_with_dyn(get_proc_address);
            self.VertexAttrib3sv_load_with_dyn(get_proc_address);
            self.VertexAttrib4Nbv_load_with_dyn(get_proc_address);
            self.VertexAttrib4Niv_load_with_dyn(get_proc_address);
            self.VertexAttrib4Nsv_load_with_dyn(get_proc_address);
            self.VertexAttrib4Nub_load_with_dyn(get_proc_address);
            self.VertexAttrib4Nubv_load_with_dyn(get_proc_address);
            self.VertexAttrib4Nuiv_load_with_dyn(get_proc_address);
            self.VertexAttrib4Nusv_load_with_dyn(get_proc_address);
            self.VertexAttrib4bv_load_with_dyn(get_proc_address);
            self.VertexAttrib4d_load_with_dyn(get_proc_address);
            self.VertexAttrib4dv_load_with_dyn(get_proc_address);
            self.VertexAttrib4f_load_with_dyn(get_proc_address);
            self.VertexAttrib4fv_load_with_dyn(get_proc_address);
            self.VertexAttrib4iv_load_with_dyn(get_proc_address);
            self.VertexAttrib4s_load_with_dyn(get_proc_address);
            self.VertexAttrib4sv_load_with_dyn(get_proc_address);
            self.VertexAttrib4ubv_load_with_dyn(get_proc_address);
            self.VertexAttrib4uiv_load_with_dyn(get_proc_address);
            self.VertexAttrib4usv_load_with_dyn(get_proc_address);
            self.VertexAttribBinding_load_with_dyn(get_proc_address);
            self.VertexAttribDivisor_load_with_dyn(get_proc_address);
            self.VertexAttribFormat_load_with_dyn(get_proc_address);
            self.VertexAttribI1i_load_with_dyn(get_proc_address);
            self.VertexAttribI1iv_load_with_dyn(get_proc_address);
            self.VertexAttribI1ui_load_with_dyn(get_proc_address);
            self.VertexAttribI1uiv_load_with_dyn(get_proc_address);
            self.VertexAttribI2i_load_with_dyn(get_proc_address);
            self.VertexAttribI2iv_load_with_dyn(get_proc_address);
            self.VertexAttribI2ui_load_with_dyn(get_proc_address);
            self.VertexAttribI2uiv_load_with_dyn(get_proc_address);
            self.VertexAttribI3i_load_with_dyn(get_proc_address);
            self.VertexAttribI3iv_load_with_dyn(get_proc_address);
            self.VertexAttribI3ui_load_with_dyn(get_proc_address);
            self.VertexAttribI3uiv_load_with_dyn(get_proc_address);
            self.VertexAttribI4bv_load_with_dyn(get_proc_address);
            self.VertexAttribI4i_load_with_dyn(get_proc_address);
            self.VertexAttribI4iv_load_with_dyn(get_proc_address);
            self.VertexAttribI4sv_load_with_dyn(get_proc_address);
            self.VertexAttribI4ubv_load_with_dyn(get_proc_address);
            self.VertexAttribI4ui_load_with_dyn(get_proc_address);
            self.VertexAttribI4uiv_load_with_dyn(get_proc_address);
            self.VertexAttribI4usv_load_with_dyn(get_proc_address);
            self.VertexAttribIFormat_load_with_dyn(get_proc_address);
            self.VertexAttribIPointer_load_with_dyn(get_proc_address);
            self.VertexAttribL1d_load_with_dyn(get_proc_address);
            self.VertexAttribL1dv_load_with_dyn(get_proc_address);
            self.VertexAttribL2d_load_with_dyn(get_proc_address);
            self.VertexAttribL2dv_load_with_dyn(get_proc_address);
            self.VertexAttribL3d_load_with_dyn(get_proc_address);
            self.VertexAttribL3dv_load_with_dyn(get_proc_address);
            self.VertexAttribL4d_load_with_dyn(get_proc_address);
            self.VertexAttribL4dv_load_with_dyn(get_proc_address);
            self.VertexAttribLFormat_load_with_dyn(get_proc_address);
            self.VertexAttribLPointer_load_with_dyn(get_proc_address);
            self.VertexAttribP1ui_load_with_dyn(get_proc_address);
            self.VertexAttribP1uiv_load_with_dyn(get_proc_address);
            self.VertexAttribP2ui_load_with_dyn(get_proc_address);
            self.VertexAttribP2uiv_load_with_dyn(get_proc_address);
            self.VertexAttribP3ui_load_with_dyn(get_proc_address);
            self.VertexAttribP3uiv_load_with_dyn(get_proc_address);
            self.VertexAttribP4ui_load_with_dyn(get_proc_address);
            self.VertexAttribP4uiv_load_with_dyn(get_proc_address);
            self.VertexAttribPointer_load_with_dyn(get_proc_address);
            self.VertexBindingDivisor_load_with_dyn(get_proc_address);
            self.Viewport_load_with_dyn(get_proc_address);
            self.ViewportArrayv_load_with_dyn(get_proc_address);
            self.ViewportIndexedf_load_with_dyn(get_proc_address);
            self.ViewportIndexedfv_load_with_dyn(get_proc_address);
            self.WaitSync_load_with_dyn(get_proc_address);
        }
        /// [glActiveShaderProgram](http://docs.gl/gl4/glActiveShaderProgram)(pipeline, program)
        /// * `pipeline` class: program pipeline
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ActiveShaderProgram(&self, pipeline: GLuint, program: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ActiveShaderProgram({:?}, {:?});",
                    pipeline,
                    program
                );
            }
            let out = call_atomic_ptr_2arg(
                "glActiveShaderProgram",
                &self.glActiveShaderProgram_p,
                pipeline,
                program,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glActiveShaderProgram");
            }
            out
        }

        pub unsafe fn ActiveShaderProgram_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glActiveShaderProgram\0",
                &self.glActiveShaderProgram_p,
            )
        }
        #[inline]

        pub fn ActiveShaderProgram_is_loaded(&self) -> bool {
            !self.glActiveShaderProgram_p.load(RELAX).is_null()
        }
        /// [glActiveTexture](http://docs.gl/gl4/glActiveTexture)(texture)
        /// * `texture` group: TextureUnit
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ActiveTexture(&self, texture: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ActiveTexture({:#X});", texture);
            }
            let out = call_atomic_ptr_1arg("glActiveTexture", &self.glActiveTexture_p, texture);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glActiveTexture");
            }
            out
        }

        pub unsafe fn ActiveTexture_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glActiveTexture\0",
                &self.glActiveTexture_p,
            )
        }
        #[inline]

        pub fn ActiveTexture_is_loaded(&self) -> bool {
            !self.glActiveTexture_p.load(RELAX).is_null()
        }
        /// [glAttachShader](http://docs.gl/gl4/glAttachShader)(program, shader)
        /// * `program` class: program
        /// * `shader` class: shader
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn AttachShader(&self, program: GLuint, shader: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.AttachShader({:?}, {:?});", program, shader);
            }
            let out =
                call_atomic_ptr_2arg("glAttachShader", &self.glAttachShader_p, program, shader);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glAttachShader");
            }
            out
        }

        pub unsafe fn AttachShader_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glAttachShader\0",
                &self.glAttachShader_p,
            )
        }
        #[inline]

        pub fn AttachShader_is_loaded(&self) -> bool {
            !self.glAttachShader_p.load(RELAX).is_null()
        }
        /// [glBeginConditionalRender](http://docs.gl/gl4/glBeginConditionalRender)(id, mode)
        /// * `mode` group: ConditionalRenderMode
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BeginConditionalRender(&self, id: GLuint, mode: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BeginConditionalRender({:?}, {:#X});", id, mode);
            }
            let out = call_atomic_ptr_2arg(
                "glBeginConditionalRender",
                &self.glBeginConditionalRender_p,
                id,
                mode,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBeginConditionalRender");
            }
            out
        }

        pub unsafe fn BeginConditionalRender_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBeginConditionalRender\0",
                &self.glBeginConditionalRender_p,
            )
        }
        #[inline]

        pub fn BeginConditionalRender_is_loaded(&self) -> bool {
            !self.glBeginConditionalRender_p.load(RELAX).is_null()
        }
        /// [glBeginQuery](http://docs.gl/gl4/glBeginQuery)(target, id)
        /// * `target` group: QueryTarget
        /// * `id` class: query
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BeginQuery(&self, target: GLenum, id: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BeginQuery({:#X}, {:?});", target, id);
            }
            let out = call_atomic_ptr_2arg("glBeginQuery", &self.glBeginQuery_p, target, id);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBeginQuery");
            }
            out
        }

        pub unsafe fn BeginQuery_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glBeginQuery\0", &self.glBeginQuery_p)
        }
        #[inline]

        pub fn BeginQuery_is_loaded(&self) -> bool {
            !self.glBeginQuery_p.load(RELAX).is_null()
        }
        /// [glBeginQueryIndexed](http://docs.gl/gl4/glBeginQueryIndexed)(target, index, id)
        /// * `target` group: QueryTarget
        /// * `id` class: query
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BeginQueryIndexed(&self, target: GLenum, index: GLuint, id: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BeginQueryIndexed({:#X}, {:?}, {:?});",
                    target,
                    index,
                    id
                );
            }
            let out = call_atomic_ptr_3arg(
                "glBeginQueryIndexed",
                &self.glBeginQueryIndexed_p,
                target,
                index,
                id,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBeginQueryIndexed");
            }
            out
        }

        pub unsafe fn BeginQueryIndexed_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBeginQueryIndexed\0",
                &self.glBeginQueryIndexed_p,
            )
        }
        #[inline]

        pub fn BeginQueryIndexed_is_loaded(&self) -> bool {
            !self.glBeginQueryIndexed_p.load(RELAX).is_null()
        }
        /// [glBeginTransformFeedback](http://docs.gl/gl4/glBeginTransformFeedback)(primitiveMode)
        /// * `primitiveMode` group: PrimitiveType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BeginTransformFeedback(&self, primitiveMode: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BeginTransformFeedback({:#X});", primitiveMode);
            }
            let out = call_atomic_ptr_1arg(
                "glBeginTransformFeedback",
                &self.glBeginTransformFeedback_p,
                primitiveMode,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBeginTransformFeedback");
            }
            out
        }

        pub unsafe fn BeginTransformFeedback_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBeginTransformFeedback\0",
                &self.glBeginTransformFeedback_p,
            )
        }
        #[inline]

        pub fn BeginTransformFeedback_is_loaded(&self) -> bool {
            !self.glBeginTransformFeedback_p.load(RELAX).is_null()
        }
        /// [glBindAttribLocation](http://docs.gl/gl4/glBindAttribLocation)(program, index, name)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindAttribLocation(
            &self,
            program: GLuint,
            index: GLuint,
            name: *const GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindAttribLocation({:?}, {:?}, {:p});",
                    program,
                    index,
                    name
                );
            }
            let out = call_atomic_ptr_3arg(
                "glBindAttribLocation",
                &self.glBindAttribLocation_p,
                program,
                index,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindAttribLocation");
            }
            out
        }

        pub unsafe fn BindAttribLocation_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindAttribLocation\0",
                &self.glBindAttribLocation_p,
            )
        }
        #[inline]

        pub fn BindAttribLocation_is_loaded(&self) -> bool {
            !self.glBindAttribLocation_p.load(RELAX).is_null()
        }
        /// [glBindBuffer](http://docs.gl/gl4/glBindBuffer)(target, buffer)
        /// * `target` group: BufferTargetARB
        /// * `buffer` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindBuffer(&self, target: GLenum, buffer: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BindBuffer({:#X}, {:?});", target, buffer);
            }
            let out = call_atomic_ptr_2arg("glBindBuffer", &self.glBindBuffer_p, target, buffer);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindBuffer");
            }
            out
        }

        pub unsafe fn BindBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glBindBuffer\0", &self.glBindBuffer_p)
        }
        #[inline]

        pub fn BindBuffer_is_loaded(&self) -> bool {
            !self.glBindBuffer_p.load(RELAX).is_null()
        }
        /// [glBindBufferBase](http://docs.gl/gl4/glBindBufferBase)(target, index, buffer)
        /// * `target` group: BufferTargetARB
        /// * `buffer` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindBufferBase(&self, target: GLenum, index: GLuint, buffer: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindBufferBase({:#X}, {:?}, {:?});",
                    target,
                    index,
                    buffer
                );
            }
            let out = call_atomic_ptr_3arg(
                "glBindBufferBase",
                &self.glBindBufferBase_p,
                target,
                index,
                buffer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindBufferBase");
            }
            out
        }

        pub unsafe fn BindBufferBase_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindBufferBase\0",
                &self.glBindBufferBase_p,
            )
        }
        #[inline]

        pub fn BindBufferBase_is_loaded(&self) -> bool {
            !self.glBindBufferBase_p.load(RELAX).is_null()
        }
        /// [glBindBufferRange](http://docs.gl/gl4/glBindBufferRange)(target, index, buffer, offset, size)
        /// * `target` group: BufferTargetARB
        /// * `buffer` class: buffer
        /// * `offset` group: BufferOffset
        /// * `size` group: BufferSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindBufferRange(
            &self,
            target: GLenum,
            index: GLuint,
            buffer: GLuint,
            offset: GLintptr,
            size: GLsizeiptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindBufferRange({:#X}, {:?}, {:?}, {:?}, {:?});",
                    target,
                    index,
                    buffer,
                    offset,
                    size
                );
            }
            let out = call_atomic_ptr_5arg(
                "glBindBufferRange",
                &self.glBindBufferRange_p,
                target,
                index,
                buffer,
                offset,
                size,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindBufferRange");
            }
            out
        }

        pub unsafe fn BindBufferRange_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindBufferRange\0",
                &self.glBindBufferRange_p,
            )
        }
        #[inline]

        pub fn BindBufferRange_is_loaded(&self) -> bool {
            !self.glBindBufferRange_p.load(RELAX).is_null()
        }
        /// [glBindBuffersBase](http://docs.gl/gl4/glBindBuffersBase)(target, first, count, buffers)
        /// * `target` group: BufferTargetARB
        /// * `buffers` len: count
        /// * `buffers` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindBuffersBase(
            &self,
            target: GLenum,
            first: GLuint,
            count: GLsizei,
            buffers: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindBuffersBase({:#X}, {:?}, {:?}, {:p});",
                    target,
                    first,
                    count,
                    buffers
                );
            }
            let out = call_atomic_ptr_4arg(
                "glBindBuffersBase",
                &self.glBindBuffersBase_p,
                target,
                first,
                count,
                buffers,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindBuffersBase");
            }
            out
        }

        pub unsafe fn BindBuffersBase_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindBuffersBase\0",
                &self.glBindBuffersBase_p,
            )
        }
        #[inline]

        pub fn BindBuffersBase_is_loaded(&self) -> bool {
            !self.glBindBuffersBase_p.load(RELAX).is_null()
        }
        /// [glBindBuffersRange](http://docs.gl/gl4/glBindBuffersRange)(target, first, count, buffers, offsets, sizes)
        /// * `target` group: BufferTargetARB
        /// * `buffers` len: count
        /// * `buffers` class: buffer
        /// * `offsets` len: count
        /// * `sizes` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindBuffersRange(
            &self,
            target: GLenum,
            first: GLuint,
            count: GLsizei,
            buffers: *const GLuint,
            offsets: *const GLintptr,
            sizes: *const GLsizeiptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindBuffersRange({:#X}, {:?}, {:?}, {:p}, {:p}, {:p});",
                    target,
                    first,
                    count,
                    buffers,
                    offsets,
                    sizes
                );
            }
            let out = call_atomic_ptr_6arg(
                "glBindBuffersRange",
                &self.glBindBuffersRange_p,
                target,
                first,
                count,
                buffers,
                offsets,
                sizes,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindBuffersRange");
            }
            out
        }

        pub unsafe fn BindBuffersRange_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindBuffersRange\0",
                &self.glBindBuffersRange_p,
            )
        }
        #[inline]

        pub fn BindBuffersRange_is_loaded(&self) -> bool {
            !self.glBindBuffersRange_p.load(RELAX).is_null()
        }
        /// [glBindFragDataLocation](http://docs.gl/gl4/glBindFragDataLocation)(program, color, name)
        /// * `program` class: program
        /// * `name` len: COMPSIZE(name)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindFragDataLocation(
            &self,
            program: GLuint,
            color: GLuint,
            name: *const GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindFragDataLocation({:?}, {:?}, {:p});",
                    program,
                    color,
                    name
                );
            }
            let out = call_atomic_ptr_3arg(
                "glBindFragDataLocation",
                &self.glBindFragDataLocation_p,
                program,
                color,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindFragDataLocation");
            }
            out
        }

        pub unsafe fn BindFragDataLocation_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindFragDataLocation\0",
                &self.glBindFragDataLocation_p,
            )
        }
        #[inline]

        pub fn BindFragDataLocation_is_loaded(&self) -> bool {
            !self.glBindFragDataLocation_p.load(RELAX).is_null()
        }
        /// [glBindFragDataLocationIndexed](http://docs.gl/gl4/glBindFragDataLocationIndexed)(program, colorNumber, index, name)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindFragDataLocationIndexed(
            &self,
            program: GLuint,
            colorNumber: GLuint,
            index: GLuint,
            name: *const GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindFragDataLocationIndexed({:?}, {:?}, {:?}, {:p});",
                    program,
                    colorNumber,
                    index,
                    name
                );
            }
            let out = call_atomic_ptr_4arg(
                "glBindFragDataLocationIndexed",
                &self.glBindFragDataLocationIndexed_p,
                program,
                colorNumber,
                index,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindFragDataLocationIndexed");
            }
            out
        }

        pub unsafe fn BindFragDataLocationIndexed_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindFragDataLocationIndexed\0",
                &self.glBindFragDataLocationIndexed_p,
            )
        }
        #[inline]

        pub fn BindFragDataLocationIndexed_is_loaded(&self) -> bool {
            !self.glBindFragDataLocationIndexed_p.load(RELAX).is_null()
        }
        /// [glBindFramebuffer](http://docs.gl/gl4/glBindFramebuffer)(target, framebuffer)
        /// * `target` group: FramebufferTarget
        /// * `framebuffer` class: framebuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindFramebuffer(&self, target: GLenum, framebuffer: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindFramebuffer({:#X}, {:?});",
                    target,
                    framebuffer
                );
            }
            let out = call_atomic_ptr_2arg(
                "glBindFramebuffer",
                &self.glBindFramebuffer_p,
                target,
                framebuffer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindFramebuffer");
            }
            out
        }

        pub unsafe fn BindFramebuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindFramebuffer\0",
                &self.glBindFramebuffer_p,
            )
        }
        #[inline]

        pub fn BindFramebuffer_is_loaded(&self) -> bool {
            !self.glBindFramebuffer_p.load(RELAX).is_null()
        }
        /// [glBindImageTexture](http://docs.gl/gl4/glBindImageTexture)(unit, texture, level, layered, layer, access, format)
        /// * `texture` class: texture
        /// * `access` group: BufferAccessARB
        /// * `format` group: InternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindImageTexture(
            &self,
            unit: GLuint,
            texture: GLuint,
            level: GLint,
            layered: GLboolean,
            layer: GLint,
            access: GLenum,
            format: GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindImageTexture({:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X});",
                    unit,
                    texture,
                    level,
                    layered,
                    layer,
                    access,
                    format
                );
            }
            let out = call_atomic_ptr_7arg(
                "glBindImageTexture",
                &self.glBindImageTexture_p,
                unit,
                texture,
                level,
                layered,
                layer,
                access,
                format,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindImageTexture");
            }
            out
        }

        pub unsafe fn BindImageTexture_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindImageTexture\0",
                &self.glBindImageTexture_p,
            )
        }
        #[inline]

        pub fn BindImageTexture_is_loaded(&self) -> bool {
            !self.glBindImageTexture_p.load(RELAX).is_null()
        }
        /// [glBindImageTextures](http://docs.gl/gl4/glBindImageTextures)(first, count, textures)
        /// * `textures` len: count
        /// * `textures` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindImageTextures(
            &self,
            first: GLuint,
            count: GLsizei,
            textures: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindImageTextures({:?}, {:?}, {:p});",
                    first,
                    count,
                    textures
                );
            }
            let out = call_atomic_ptr_3arg(
                "glBindImageTextures",
                &self.glBindImageTextures_p,
                first,
                count,
                textures,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindImageTextures");
            }
            out
        }

        pub unsafe fn BindImageTextures_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindImageTextures\0",
                &self.glBindImageTextures_p,
            )
        }
        #[inline]

        pub fn BindImageTextures_is_loaded(&self) -> bool {
            !self.glBindImageTextures_p.load(RELAX).is_null()
        }
        /// [glBindProgramPipeline](http://docs.gl/gl4/glBindProgramPipeline)(pipeline)
        /// * `pipeline` class: program pipeline
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindProgramPipeline(&self, pipeline: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BindProgramPipeline({:?});", pipeline);
            }
            let out = call_atomic_ptr_1arg(
                "glBindProgramPipeline",
                &self.glBindProgramPipeline_p,
                pipeline,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindProgramPipeline");
            }
            out
        }

        pub unsafe fn BindProgramPipeline_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindProgramPipeline\0",
                &self.glBindProgramPipeline_p,
            )
        }
        #[inline]

        pub fn BindProgramPipeline_is_loaded(&self) -> bool {
            !self.glBindProgramPipeline_p.load(RELAX).is_null()
        }
        /// [glBindRenderbuffer](http://docs.gl/gl4/glBindRenderbuffer)(target, renderbuffer)
        /// * `target` group: RenderbufferTarget
        /// * `renderbuffer` class: renderbuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindRenderbuffer(&self, target: GLenum, renderbuffer: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindRenderbuffer({:#X}, {:?});",
                    target,
                    renderbuffer
                );
            }
            let out = call_atomic_ptr_2arg(
                "glBindRenderbuffer",
                &self.glBindRenderbuffer_p,
                target,
                renderbuffer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindRenderbuffer");
            }
            out
        }

        pub unsafe fn BindRenderbuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindRenderbuffer\0",
                &self.glBindRenderbuffer_p,
            )
        }
        #[inline]

        pub fn BindRenderbuffer_is_loaded(&self) -> bool {
            !self.glBindRenderbuffer_p.load(RELAX).is_null()
        }
        /// [glBindSampler](http://docs.gl/gl4/glBindSampler)(unit, sampler)
        /// * `sampler` class: sampler
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindSampler(&self, unit: GLuint, sampler: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BindSampler({:?}, {:?});", unit, sampler);
            }
            let out = call_atomic_ptr_2arg("glBindSampler", &self.glBindSampler_p, unit, sampler);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindSampler");
            }
            out
        }

        pub unsafe fn BindSampler_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glBindSampler\0", &self.glBindSampler_p)
        }
        #[inline]

        pub fn BindSampler_is_loaded(&self) -> bool {
            !self.glBindSampler_p.load(RELAX).is_null()
        }
        /// [glBindSamplers](http://docs.gl/gl4/glBindSamplers)(first, count, samplers)
        /// * `samplers` len: count
        /// * `samplers` class: sampler
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindSamplers(&self, first: GLuint, count: GLsizei, samplers: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindSamplers({:?}, {:?}, {:p});",
                    first,
                    count,
                    samplers
                );
            }
            let out = call_atomic_ptr_3arg(
                "glBindSamplers",
                &self.glBindSamplers_p,
                first,
                count,
                samplers,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindSamplers");
            }
            out
        }

        pub unsafe fn BindSamplers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindSamplers\0",
                &self.glBindSamplers_p,
            )
        }
        #[inline]

        pub fn BindSamplers_is_loaded(&self) -> bool {
            !self.glBindSamplers_p.load(RELAX).is_null()
        }
        /// [glBindTexture](http://docs.gl/gl4/glBindTexture)(target, texture)
        /// * `target` group: TextureTarget
        /// * `texture` group: Texture
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindTexture(&self, target: GLenum, texture: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BindTexture({:#X}, {:?});", target, texture);
            }
            let out = call_atomic_ptr_2arg("glBindTexture", &self.glBindTexture_p, target, texture);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindTexture");
            }
            out
        }

        pub unsafe fn BindTexture_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glBindTexture\0", &self.glBindTexture_p)
        }
        #[inline]

        pub fn BindTexture_is_loaded(&self) -> bool {
            !self.glBindTexture_p.load(RELAX).is_null()
        }
        /// [glBindTextureUnit](http://docs.gl/gl4/glBindTextureUnit)(unit, texture)
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindTextureUnit(&self, unit: GLuint, texture: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BindTextureUnit({:?}, {:?});", unit, texture);
            }
            let out = call_atomic_ptr_2arg(
                "glBindTextureUnit",
                &self.glBindTextureUnit_p,
                unit,
                texture,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindTextureUnit");
            }
            out
        }

        pub unsafe fn BindTextureUnit_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindTextureUnit\0",
                &self.glBindTextureUnit_p,
            )
        }
        #[inline]

        pub fn BindTextureUnit_is_loaded(&self) -> bool {
            !self.glBindTextureUnit_p.load(RELAX).is_null()
        }
        /// [glBindTextures](http://docs.gl/gl4/glBindTextures)(first, count, textures)
        /// * `textures` len: count
        /// * `textures` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindTextures({:?}, {:?}, {:p});",
                    first,
                    count,
                    textures
                );
            }
            let out = call_atomic_ptr_3arg(
                "glBindTextures",
                &self.glBindTextures_p,
                first,
                count,
                textures,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindTextures");
            }
            out
        }

        pub unsafe fn BindTextures_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindTextures\0",
                &self.glBindTextures_p,
            )
        }
        #[inline]

        pub fn BindTextures_is_loaded(&self) -> bool {
            !self.glBindTextures_p.load(RELAX).is_null()
        }
        /// [glBindTransformFeedback](http://docs.gl/gl4/glBindTransformFeedback)(target, id)
        /// * `target` group: BindTransformFeedbackTarget
        /// * `id` class: transform feedback
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindTransformFeedback(&self, target: GLenum, id: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BindTransformFeedback({:#X}, {:?});", target, id);
            }
            let out = call_atomic_ptr_2arg(
                "glBindTransformFeedback",
                &self.glBindTransformFeedback_p,
                target,
                id,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindTransformFeedback");
            }
            out
        }

        pub unsafe fn BindTransformFeedback_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindTransformFeedback\0",
                &self.glBindTransformFeedback_p,
            )
        }
        #[inline]

        pub fn BindTransformFeedback_is_loaded(&self) -> bool {
            !self.glBindTransformFeedback_p.load(RELAX).is_null()
        }
        /// [glBindVertexArray](http://docs.gl/gl4/glBindVertexArray)(array)
        /// * `array` class: vertex array
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindVertexArray(&self, array: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BindVertexArray({:?});", array);
            }
            let out = call_atomic_ptr_1arg("glBindVertexArray", &self.glBindVertexArray_p, array);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindVertexArray");
            }
            out
        }

        pub unsafe fn BindVertexArray_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindVertexArray\0",
                &self.glBindVertexArray_p,
            )
        }
        #[inline]

        pub fn BindVertexArray_is_loaded(&self) -> bool {
            !self.glBindVertexArray_p.load(RELAX).is_null()
        }
        /// [glBindVertexBuffer](http://docs.gl/gl4/glBindVertexBuffer)(bindingindex, buffer, offset, stride)
        /// * `buffer` class: buffer
        /// * `offset` group: BufferOffset
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindVertexBuffer(
            &self,
            bindingindex: GLuint,
            buffer: GLuint,
            offset: GLintptr,
            stride: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindVertexBuffer({:?}, {:?}, {:?}, {:?});",
                    bindingindex,
                    buffer,
                    offset,
                    stride
                );
            }
            let out = call_atomic_ptr_4arg(
                "glBindVertexBuffer",
                &self.glBindVertexBuffer_p,
                bindingindex,
                buffer,
                offset,
                stride,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindVertexBuffer");
            }
            out
        }

        pub unsafe fn BindVertexBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindVertexBuffer\0",
                &self.glBindVertexBuffer_p,
            )
        }
        #[inline]

        pub fn BindVertexBuffer_is_loaded(&self) -> bool {
            !self.glBindVertexBuffer_p.load(RELAX).is_null()
        }
        /// [glBindVertexBuffers](http://docs.gl/gl4/glBindVertexBuffers)(first, count, buffers, offsets, strides)
        /// * `buffers` len: count
        /// * `buffers` class: buffer
        /// * `offsets` len: count
        /// * `strides` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BindVertexBuffers(
            &self,
            first: GLuint,
            count: GLsizei,
            buffers: *const GLuint,
            offsets: *const GLintptr,
            strides: *const GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BindVertexBuffers({:?}, {:?}, {:p}, {:p}, {:p});",
                    first,
                    count,
                    buffers,
                    offsets,
                    strides
                );
            }
            let out = call_atomic_ptr_5arg(
                "glBindVertexBuffers",
                &self.glBindVertexBuffers_p,
                first,
                count,
                buffers,
                offsets,
                strides,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBindVertexBuffers");
            }
            out
        }

        pub unsafe fn BindVertexBuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBindVertexBuffers\0",
                &self.glBindVertexBuffers_p,
            )
        }
        #[inline]

        pub fn BindVertexBuffers_is_loaded(&self) -> bool {
            !self.glBindVertexBuffers_p.load(RELAX).is_null()
        }
        /// [glBlendColor](http://docs.gl/gl4/glBlendColor)(red, green, blue, alpha)
        /// * `red` group: ColorF
        /// * `green` group: ColorF
        /// * `blue` group: ColorF
        /// * `alpha` group: ColorF
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BlendColor(
            &self,
            red: GLfloat,
            green: GLfloat,
            blue: GLfloat,
            alpha: GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BlendColor({:?}, {:?}, {:?}, {:?});",
                    red,
                    green,
                    blue,
                    alpha
                );
            }
            let out = call_atomic_ptr_4arg(
                "glBlendColor",
                &self.glBlendColor_p,
                red,
                green,
                blue,
                alpha,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBlendColor");
            }
            out
        }

        pub unsafe fn BlendColor_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glBlendColor\0", &self.glBlendColor_p)
        }
        #[inline]

        pub fn BlendColor_is_loaded(&self) -> bool {
            !self.glBlendColor_p.load(RELAX).is_null()
        }
        /// [glBlendEquation](http://docs.gl/gl4/glBlendEquation)(mode)
        /// * `mode` group: BlendEquationModeEXT
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BlendEquation(&self, mode: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BlendEquation({:#X});", mode);
            }
            let out = call_atomic_ptr_1arg("glBlendEquation", &self.glBlendEquation_p, mode);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBlendEquation");
            }
            out
        }

        pub unsafe fn BlendEquation_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBlendEquation\0",
                &self.glBlendEquation_p,
            )
        }
        #[inline]

        pub fn BlendEquation_is_loaded(&self) -> bool {
            !self.glBlendEquation_p.load(RELAX).is_null()
        }
        /// [glBlendEquationSeparate](http://docs.gl/gl4/glBlendEquationSeparate)(modeRGB, modeAlpha)
        /// * `modeRGB` group: BlendEquationModeEXT
        /// * `modeAlpha` group: BlendEquationModeEXT
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BlendEquationSeparate(&self, modeRGB: GLenum, modeAlpha: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BlendEquationSeparate({:#X}, {:#X});",
                    modeRGB,
                    modeAlpha
                );
            }
            let out = call_atomic_ptr_2arg(
                "glBlendEquationSeparate",
                &self.glBlendEquationSeparate_p,
                modeRGB,
                modeAlpha,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBlendEquationSeparate");
            }
            out
        }

        pub unsafe fn BlendEquationSeparate_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBlendEquationSeparate\0",
                &self.glBlendEquationSeparate_p,
            )
        }
        #[inline]

        pub fn BlendEquationSeparate_is_loaded(&self) -> bool {
            !self.glBlendEquationSeparate_p.load(RELAX).is_null()
        }
        /// [glBlendEquationSeparatei](http://docs.gl/gl4/glBlendEquationSeparate)(buf, modeRGB, modeAlpha)
        /// * `modeRGB` group: BlendEquationModeEXT
        /// * `modeAlpha` group: BlendEquationModeEXT
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BlendEquationSeparatei(
            &self,
            buf: GLuint,
            modeRGB: GLenum,
            modeAlpha: GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BlendEquationSeparatei({:?}, {:#X}, {:#X});",
                    buf,
                    modeRGB,
                    modeAlpha
                );
            }
            let out = call_atomic_ptr_3arg(
                "glBlendEquationSeparatei",
                &self.glBlendEquationSeparatei_p,
                buf,
                modeRGB,
                modeAlpha,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBlendEquationSeparatei");
            }
            out
        }

        pub unsafe fn BlendEquationSeparatei_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBlendEquationSeparatei\0",
                &self.glBlendEquationSeparatei_p,
            )
        }
        #[inline]

        pub fn BlendEquationSeparatei_is_loaded(&self) -> bool {
            !self.glBlendEquationSeparatei_p.load(RELAX).is_null()
        }
        /// [glBlendEquationi](http://docs.gl/gl4/glBlendEquation)(buf, mode)
        /// * `mode` group: BlendEquationModeEXT
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BlendEquationi(&self, buf: GLuint, mode: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BlendEquationi({:?}, {:#X});", buf, mode);
            }
            let out = call_atomic_ptr_2arg("glBlendEquationi", &self.glBlendEquationi_p, buf, mode);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBlendEquationi");
            }
            out
        }

        pub unsafe fn BlendEquationi_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBlendEquationi\0",
                &self.glBlendEquationi_p,
            )
        }
        #[inline]

        pub fn BlendEquationi_is_loaded(&self) -> bool {
            !self.glBlendEquationi_p.load(RELAX).is_null()
        }
        /// [glBlendFunc](http://docs.gl/gl4/glBlendFunc)(sfactor, dfactor)
        /// * `sfactor` group: BlendingFactor
        /// * `dfactor` group: BlendingFactor
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BlendFunc(&self, sfactor: GLenum, dfactor: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BlendFunc({:#X}, {:#X});", sfactor, dfactor);
            }
            let out = call_atomic_ptr_2arg("glBlendFunc", &self.glBlendFunc_p, sfactor, dfactor);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBlendFunc");
            }
            out
        }

        pub unsafe fn BlendFunc_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glBlendFunc\0", &self.glBlendFunc_p)
        }
        #[inline]

        pub fn BlendFunc_is_loaded(&self) -> bool {
            !self.glBlendFunc_p.load(RELAX).is_null()
        }
        /// [glBlendFuncSeparate](http://docs.gl/gl4/glBlendFuncSeparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)
        /// * `sfactorRGB` group: BlendingFactor
        /// * `dfactorRGB` group: BlendingFactor
        /// * `sfactorAlpha` group: BlendingFactor
        /// * `dfactorAlpha` group: BlendingFactor
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BlendFuncSeparate(
            &self,
            sfactorRGB: GLenum,
            dfactorRGB: GLenum,
            sfactorAlpha: GLenum,
            dfactorAlpha: GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BlendFuncSeparate({:#X}, {:#X}, {:#X}, {:#X});",
                    sfactorRGB,
                    dfactorRGB,
                    sfactorAlpha,
                    dfactorAlpha
                );
            }
            let out = call_atomic_ptr_4arg(
                "glBlendFuncSeparate",
                &self.glBlendFuncSeparate_p,
                sfactorRGB,
                dfactorRGB,
                sfactorAlpha,
                dfactorAlpha,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBlendFuncSeparate");
            }
            out
        }

        pub unsafe fn BlendFuncSeparate_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBlendFuncSeparate\0",
                &self.glBlendFuncSeparate_p,
            )
        }
        #[inline]

        pub fn BlendFuncSeparate_is_loaded(&self) -> bool {
            !self.glBlendFuncSeparate_p.load(RELAX).is_null()
        }
        /// [glBlendFuncSeparatei](http://docs.gl/gl4/glBlendFuncSeparate)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)
        /// * `srcRGB` group: BlendingFactor
        /// * `dstRGB` group: BlendingFactor
        /// * `srcAlpha` group: BlendingFactor
        /// * `dstAlpha` group: BlendingFactor
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BlendFuncSeparatei(
            &self,
            buf: GLuint,
            srcRGB: GLenum,
            dstRGB: GLenum,
            srcAlpha: GLenum,
            dstAlpha: GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BlendFuncSeparatei({:?}, {:#X}, {:#X}, {:#X}, {:#X});",
                    buf,
                    srcRGB,
                    dstRGB,
                    srcAlpha,
                    dstAlpha
                );
            }
            let out = call_atomic_ptr_5arg(
                "glBlendFuncSeparatei",
                &self.glBlendFuncSeparatei_p,
                buf,
                srcRGB,
                dstRGB,
                srcAlpha,
                dstAlpha,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBlendFuncSeparatei");
            }
            out
        }

        pub unsafe fn BlendFuncSeparatei_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBlendFuncSeparatei\0",
                &self.glBlendFuncSeparatei_p,
            )
        }
        #[inline]

        pub fn BlendFuncSeparatei_is_loaded(&self) -> bool {
            !self.glBlendFuncSeparatei_p.load(RELAX).is_null()
        }
        /// [glBlendFunci](http://docs.gl/gl4/glBlendFunc)(buf, src, dst)
        /// * `src` group: BlendingFactor
        /// * `dst` group: BlendingFactor
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BlendFunci(&self, buf: GLuint, src: GLenum, dst: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BlendFunci({:?}, {:#X}, {:#X});", buf, src, dst);
            }
            let out = call_atomic_ptr_3arg("glBlendFunci", &self.glBlendFunci_p, buf, src, dst);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBlendFunci");
            }
            out
        }

        pub unsafe fn BlendFunci_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glBlendFunci\0", &self.glBlendFunci_p)
        }
        #[inline]

        pub fn BlendFunci_is_loaded(&self) -> bool {
            !self.glBlendFunci_p.load(RELAX).is_null()
        }
        /// [glBlitFramebuffer](http://docs.gl/gl4/glBlitFramebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
        /// * `mask` group: ClearBufferMask
        /// * `filter` group: BlitFramebufferFilter
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BlitFramebuffer(
            &self,
            srcX0: GLint,
            srcY0: GLint,
            srcX1: GLint,
            srcY1: GLint,
            dstX0: GLint,
            dstY0: GLint,
            dstX1: GLint,
            dstY1: GLint,
            mask: GLbitfield,
            filter: GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BlitFramebuffer({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X});", srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            }
            let out = call_atomic_ptr_10arg(
                "glBlitFramebuffer",
                &self.glBlitFramebuffer_p,
                srcX0,
                srcY0,
                srcX1,
                srcY1,
                dstX0,
                dstY0,
                dstX1,
                dstY1,
                mask,
                filter,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBlitFramebuffer");
            }
            out
        }

        pub unsafe fn BlitFramebuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBlitFramebuffer\0",
                &self.glBlitFramebuffer_p,
            )
        }
        #[inline]

        pub fn BlitFramebuffer_is_loaded(&self) -> bool {
            !self.glBlitFramebuffer_p.load(RELAX).is_null()
        }
        /// [glBlitNamedFramebuffer](http://docs.gl/gl4/glBlitNamedFramebuffer)(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
        /// * `readFramebuffer` class: framebuffer
        /// * `drawFramebuffer` class: framebuffer
        /// * `mask` group: ClearBufferMask
        /// * `filter` group: BlitFramebufferFilter
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BlitNamedFramebuffer(
            &self,
            readFramebuffer: GLuint,
            drawFramebuffer: GLuint,
            srcX0: GLint,
            srcY0: GLint,
            srcX1: GLint,
            srcY1: GLint,
            dstX0: GLint,
            dstY0: GLint,
            dstX1: GLint,
            dstY1: GLint,
            mask: GLbitfield,
            filter: GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.BlitNamedFramebuffer({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X});", readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            }
            let out = call_atomic_ptr_12arg(
                "glBlitNamedFramebuffer",
                &self.glBlitNamedFramebuffer_p,
                readFramebuffer,
                drawFramebuffer,
                srcX0,
                srcY0,
                srcX1,
                srcY1,
                dstX0,
                dstY0,
                dstX1,
                dstY1,
                mask,
                filter,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBlitNamedFramebuffer");
            }
            out
        }

        pub unsafe fn BlitNamedFramebuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBlitNamedFramebuffer\0",
                &self.glBlitNamedFramebuffer_p,
            )
        }
        #[inline]

        pub fn BlitNamedFramebuffer_is_loaded(&self) -> bool {
            !self.glBlitNamedFramebuffer_p.load(RELAX).is_null()
        }
        /// [glBufferData](http://docs.gl/gl4/glBufferData)(target, size, data, usage)
        /// * `target` group: BufferTargetARB
        /// * `size` group: BufferSize
        /// * `data` len: size
        /// * `usage` group: BufferUsageARB
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BufferData(
            &self,
            target: GLenum,
            size: GLsizeiptr,
            data: *const c_void,
            usage: GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BufferData({:#X}, {:?}, {:p}, {:#X});",
                    target,
                    size,
                    data,
                    usage
                );
            }
            let out = call_atomic_ptr_4arg(
                "glBufferData",
                &self.glBufferData_p,
                target,
                size,
                data,
                usage,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBufferData");
            }
            out
        }

        pub unsafe fn BufferData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glBufferData\0", &self.glBufferData_p)
        }
        #[inline]

        pub fn BufferData_is_loaded(&self) -> bool {
            !self.glBufferData_p.load(RELAX).is_null()
        }
        /// [glBufferStorage](http://docs.gl/gl4/glBufferStorage)(target, size, data, flags)
        /// * `target` group: BufferStorageTarget
        /// * `data` len: size
        /// * `flags` group: BufferStorageMask
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BufferStorage(
            &self,
            target: GLenum,
            size: GLsizeiptr,
            data: *const c_void,
            flags: GLbitfield,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BufferStorage({:#X}, {:?}, {:p}, {:?});",
                    target,
                    size,
                    data,
                    flags
                );
            }
            let out = call_atomic_ptr_4arg(
                "glBufferStorage",
                &self.glBufferStorage_p,
                target,
                size,
                data,
                flags,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBufferStorage");
            }
            out
        }

        pub unsafe fn BufferStorage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBufferStorage\0",
                &self.glBufferStorage_p,
            )
        }
        #[inline]

        pub fn BufferStorage_is_loaded(&self) -> bool {
            !self.glBufferStorage_p.load(RELAX).is_null()
        }
        /// [glBufferSubData](http://docs.gl/gl4/glBufferSubData)(target, offset, size, data)
        /// * `target` group: BufferTargetARB
        /// * `offset` group: BufferOffset
        /// * `size` group: BufferSize
        /// * `data` len: size
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn BufferSubData(
            &self,
            target: GLenum,
            offset: GLintptr,
            size: GLsizeiptr,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.BufferSubData({:#X}, {:?}, {:?}, {:p});",
                    target,
                    offset,
                    size,
                    data
                );
            }
            let out = call_atomic_ptr_4arg(
                "glBufferSubData",
                &self.glBufferSubData_p,
                target,
                offset,
                size,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glBufferSubData");
            }
            out
        }

        pub unsafe fn BufferSubData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glBufferSubData\0",
                &self.glBufferSubData_p,
            )
        }
        #[inline]

        pub fn BufferSubData_is_loaded(&self) -> bool {
            !self.glBufferSubData_p.load(RELAX).is_null()
        }
        /// [glCheckFramebufferStatus](http://docs.gl/gl4/glCheckFramebufferStatus)(target)
        /// * `target` group: FramebufferTarget
        /// * return value group: FramebufferStatus
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CheckFramebufferStatus(&self, target: GLenum) -> GLenum {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CheckFramebufferStatus({:#X});", target);
            }
            let out = call_atomic_ptr_1arg(
                "glCheckFramebufferStatus",
                &self.glCheckFramebufferStatus_p,
                target,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCheckFramebufferStatus");
            }
            out
        }

        pub unsafe fn CheckFramebufferStatus_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCheckFramebufferStatus\0",
                &self.glCheckFramebufferStatus_p,
            )
        }
        #[inline]

        pub fn CheckFramebufferStatus_is_loaded(&self) -> bool {
            !self.glCheckFramebufferStatus_p.load(RELAX).is_null()
        }
        /// [glCheckNamedFramebufferStatus](http://docs.gl/gl4/glCheckNamedFramebufferStatus)(framebuffer, target)
        /// * `framebuffer` class: framebuffer
        /// * `target` group: FramebufferTarget
        /// * return value group: FramebufferStatus
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CheckNamedFramebufferStatus(
            &self,
            framebuffer: GLuint,
            target: GLenum,
        ) -> GLenum {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CheckNamedFramebufferStatus({:?}, {:#X});",
                    framebuffer,
                    target
                );
            }
            let out = call_atomic_ptr_2arg(
                "glCheckNamedFramebufferStatus",
                &self.glCheckNamedFramebufferStatus_p,
                framebuffer,
                target,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCheckNamedFramebufferStatus");
            }
            out
        }

        pub unsafe fn CheckNamedFramebufferStatus_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCheckNamedFramebufferStatus\0",
                &self.glCheckNamedFramebufferStatus_p,
            )
        }
        #[inline]

        pub fn CheckNamedFramebufferStatus_is_loaded(&self) -> bool {
            !self.glCheckNamedFramebufferStatus_p.load(RELAX).is_null()
        }
        /// [glClampColor](http://docs.gl/gl4/glClampColor)(target, clamp)
        /// * `target` group: ClampColorTargetARB
        /// * `clamp` group: ClampColorModeARB
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClampColor(&self, target: GLenum, clamp: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ClampColor({:#X}, {:#X});", target, clamp);
            }
            let out = call_atomic_ptr_2arg("glClampColor", &self.glClampColor_p, target, clamp);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClampColor");
            }
            out
        }

        pub unsafe fn ClampColor_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glClampColor\0", &self.glClampColor_p)
        }
        #[inline]

        pub fn ClampColor_is_loaded(&self) -> bool {
            !self.glClampColor_p.load(RELAX).is_null()
        }
        /// [glClear](http://docs.gl/gl4/glClear)(mask)
        /// * `mask` group: ClearBufferMask
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Clear(&self, mask: GLbitfield) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Clear({:?});", mask);
            }
            let out = call_atomic_ptr_1arg("glClear", &self.glClear_p, mask);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClear");
            }
            out
        }

        pub unsafe fn Clear_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glClear\0", &self.glClear_p)
        }
        #[inline]

        pub fn Clear_is_loaded(&self) -> bool {
            !self.glClear_p.load(RELAX).is_null()
        }
        /// [glClearBufferData](http://docs.gl/gl4/glClearBufferData)(target, internalformat, format, type_, data)
        /// * `target` group: BufferStorageTarget
        /// * `internalformat` group: SizedInternalFormat
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `data` len: COMPSIZE(format,type)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearBufferData(
            &self,
            target: GLenum,
            internalformat: GLenum,
            format: GLenum,
            type_: GLenum,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearBufferData({:#X}, {:#X}, {:#X}, {:#X}, {:p});",
                    target,
                    internalformat,
                    format,
                    type_,
                    data
                );
            }
            let out = call_atomic_ptr_5arg(
                "glClearBufferData",
                &self.glClearBufferData_p,
                target,
                internalformat,
                format,
                type_,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearBufferData");
            }
            out
        }

        pub unsafe fn ClearBufferData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearBufferData\0",
                &self.glClearBufferData_p,
            )
        }
        #[inline]

        pub fn ClearBufferData_is_loaded(&self) -> bool {
            !self.glClearBufferData_p.load(RELAX).is_null()
        }
        /// [glClearBufferSubData](http://docs.gl/gl4/glClearBufferSubData)(target, internalformat, offset, size, format, type_, data)
        /// * `target` group: BufferTargetARB
        /// * `internalformat` group: SizedInternalFormat
        /// * `offset` group: BufferOffset
        /// * `size` group: BufferSize
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `data` len: COMPSIZE(format,type)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearBufferSubData(
            &self,
            target: GLenum,
            internalformat: GLenum,
            offset: GLintptr,
            size: GLsizeiptr,
            format: GLenum,
            type_: GLenum,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearBufferSubData({:#X}, {:#X}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                    target,
                    internalformat,
                    offset,
                    size,
                    format,
                    type_,
                    data
                );
            }
            let out = call_atomic_ptr_7arg(
                "glClearBufferSubData",
                &self.glClearBufferSubData_p,
                target,
                internalformat,
                offset,
                size,
                format,
                type_,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearBufferSubData");
            }
            out
        }

        pub unsafe fn ClearBufferSubData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearBufferSubData\0",
                &self.glClearBufferSubData_p,
            )
        }
        #[inline]

        pub fn ClearBufferSubData_is_loaded(&self) -> bool {
            !self.glClearBufferSubData_p.load(RELAX).is_null()
        }
        /// [glClearBufferfi](http://docs.gl/gl4/glClearBuffer)(buffer, drawbuffer, depth, stencil)
        /// * `buffer` group: Buffer
        /// * `drawbuffer` group: DrawBufferName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearBufferfi(
            &self,
            buffer: GLenum,
            drawbuffer: GLint,
            depth: GLfloat,
            stencil: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearBufferfi({:#X}, {:?}, {:?}, {:?});",
                    buffer,
                    drawbuffer,
                    depth,
                    stencil
                );
            }
            let out = call_atomic_ptr_4arg(
                "glClearBufferfi",
                &self.glClearBufferfi_p,
                buffer,
                drawbuffer,
                depth,
                stencil,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearBufferfi");
            }
            out
        }

        pub unsafe fn ClearBufferfi_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearBufferfi\0",
                &self.glClearBufferfi_p,
            )
        }
        #[inline]

        pub fn ClearBufferfi_is_loaded(&self) -> bool {
            !self.glClearBufferfi_p.load(RELAX).is_null()
        }
        /// [glClearBufferfv](http://docs.gl/gl4/glClearBuffer)(buffer, drawbuffer, value)
        /// * `buffer` group: Buffer
        /// * `drawbuffer` group: DrawBufferName
        /// * `value` len: COMPSIZE(buffer)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearBufferfv(
            &self,
            buffer: GLenum,
            drawbuffer: GLint,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearBufferfv({:#X}, {:?}, {:p});",
                    buffer,
                    drawbuffer,
                    value
                );
            }
            let out = call_atomic_ptr_3arg(
                "glClearBufferfv",
                &self.glClearBufferfv_p,
                buffer,
                drawbuffer,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearBufferfv");
            }
            out
        }

        pub unsafe fn ClearBufferfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearBufferfv\0",
                &self.glClearBufferfv_p,
            )
        }
        #[inline]

        pub fn ClearBufferfv_is_loaded(&self) -> bool {
            !self.glClearBufferfv_p.load(RELAX).is_null()
        }
        /// [glClearBufferiv](http://docs.gl/gl4/glClearBuffer)(buffer, drawbuffer, value)
        /// * `buffer` group: Buffer
        /// * `drawbuffer` group: DrawBufferName
        /// * `value` len: COMPSIZE(buffer)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearBufferiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearBufferiv({:#X}, {:?}, {:p});",
                    buffer,
                    drawbuffer,
                    value
                );
            }
            let out = call_atomic_ptr_3arg(
                "glClearBufferiv",
                &self.glClearBufferiv_p,
                buffer,
                drawbuffer,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearBufferiv");
            }
            out
        }

        pub unsafe fn ClearBufferiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearBufferiv\0",
                &self.glClearBufferiv_p,
            )
        }
        #[inline]

        pub fn ClearBufferiv_is_loaded(&self) -> bool {
            !self.glClearBufferiv_p.load(RELAX).is_null()
        }
        /// [glClearBufferuiv](http://docs.gl/gl4/glClearBuffer)(buffer, drawbuffer, value)
        /// * `buffer` group: Buffer
        /// * `drawbuffer` group: DrawBufferName
        /// * `value` len: COMPSIZE(buffer)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearBufferuiv(
            &self,
            buffer: GLenum,
            drawbuffer: GLint,
            value: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearBufferuiv({:#X}, {:?}, {:p});",
                    buffer,
                    drawbuffer,
                    value
                );
            }
            let out = call_atomic_ptr_3arg(
                "glClearBufferuiv",
                &self.glClearBufferuiv_p,
                buffer,
                drawbuffer,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearBufferuiv");
            }
            out
        }

        pub unsafe fn ClearBufferuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearBufferuiv\0",
                &self.glClearBufferuiv_p,
            )
        }
        #[inline]

        pub fn ClearBufferuiv_is_loaded(&self) -> bool {
            !self.glClearBufferuiv_p.load(RELAX).is_null()
        }
        /// [glClearColor](http://docs.gl/gl4/glClearColor)(red, green, blue, alpha)
        /// * `red` group: ColorF
        /// * `green` group: ColorF
        /// * `blue` group: ColorF
        /// * `alpha` group: ColorF
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearColor(
            &self,
            red: GLfloat,
            green: GLfloat,
            blue: GLfloat,
            alpha: GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearColor({:?}, {:?}, {:?}, {:?});",
                    red,
                    green,
                    blue,
                    alpha
                );
            }
            let out = call_atomic_ptr_4arg(
                "glClearColor",
                &self.glClearColor_p,
                red,
                green,
                blue,
                alpha,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearColor");
            }
            out
        }

        pub unsafe fn ClearColor_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glClearColor\0", &self.glClearColor_p)
        }
        #[inline]

        pub fn ClearColor_is_loaded(&self) -> bool {
            !self.glClearColor_p.load(RELAX).is_null()
        }
        /// [glClearDepth](http://docs.gl/gl4/glClearDepth)(depth)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearDepth(&self, depth: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ClearDepth({:?});", depth);
            }
            let out = call_atomic_ptr_1arg("glClearDepth", &self.glClearDepth_p, depth);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearDepth");
            }
            out
        }

        pub unsafe fn ClearDepth_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glClearDepth\0", &self.glClearDepth_p)
        }
        #[inline]

        pub fn ClearDepth_is_loaded(&self) -> bool {
            !self.glClearDepth_p.load(RELAX).is_null()
        }
        /// [glClearDepthf](http://docs.gl/gl4/glClearDepth)(d)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearDepthf(&self, d: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ClearDepthf({:?});", d);
            }
            let out = call_atomic_ptr_1arg("glClearDepthf", &self.glClearDepthf_p, d);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearDepthf");
            }
            out
        }

        pub unsafe fn ClearDepthf_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glClearDepthf\0", &self.glClearDepthf_p)
        }
        #[inline]

        pub fn ClearDepthf_is_loaded(&self) -> bool {
            !self.glClearDepthf_p.load(RELAX).is_null()
        }
        /// [glClearNamedBufferData](http://docs.gl/gl4/glClearNamedBufferData)(buffer, internalformat, format, type_, data)
        /// * `buffer` class: buffer
        /// * `internalformat` group: SizedInternalFormat
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearNamedBufferData(
            &self,
            buffer: GLuint,
            internalformat: GLenum,
            format: GLenum,
            type_: GLenum,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearNamedBufferData({:?}, {:#X}, {:#X}, {:#X}, {:p});",
                    buffer,
                    internalformat,
                    format,
                    type_,
                    data
                );
            }
            let out = call_atomic_ptr_5arg(
                "glClearNamedBufferData",
                &self.glClearNamedBufferData_p,
                buffer,
                internalformat,
                format,
                type_,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearNamedBufferData");
            }
            out
        }

        pub unsafe fn ClearNamedBufferData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearNamedBufferData\0",
                &self.glClearNamedBufferData_p,
            )
        }
        #[inline]

        pub fn ClearNamedBufferData_is_loaded(&self) -> bool {
            !self.glClearNamedBufferData_p.load(RELAX).is_null()
        }
        /// [glClearNamedBufferSubData](http://docs.gl/gl4/glClearNamedBufferSubData)(buffer, internalformat, offset, size, format, type_, data)
        /// * `buffer` class: buffer
        /// * `internalformat` group: SizedInternalFormat
        /// * `size` group: BufferSize
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearNamedBufferSubData(
            &self,
            buffer: GLuint,
            internalformat: GLenum,
            offset: GLintptr,
            size: GLsizeiptr,
            format: GLenum,
            type_: GLenum,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ClearNamedBufferSubData({:?}, {:#X}, {:?}, {:?}, {:#X}, {:#X}, {:p});", buffer, internalformat, offset, size, format, type_, data);
            }
            let out = call_atomic_ptr_7arg(
                "glClearNamedBufferSubData",
                &self.glClearNamedBufferSubData_p,
                buffer,
                internalformat,
                offset,
                size,
                format,
                type_,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearNamedBufferSubData");
            }
            out
        }

        pub unsafe fn ClearNamedBufferSubData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearNamedBufferSubData\0",
                &self.glClearNamedBufferSubData_p,
            )
        }
        #[inline]

        pub fn ClearNamedBufferSubData_is_loaded(&self) -> bool {
            !self.glClearNamedBufferSubData_p.load(RELAX).is_null()
        }
        /// [glClearNamedFramebufferfi](http://docs.gl/gl4/glClearNamedFramebuffer)(framebuffer, buffer, drawbuffer, depth, stencil)
        /// * `framebuffer` class: framebuffer
        /// * `buffer` group: Buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearNamedFramebufferfi(
            &self,
            framebuffer: GLuint,
            buffer: GLenum,
            drawbuffer: GLint,
            depth: GLfloat,
            stencil: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearNamedFramebufferfi({:?}, {:#X}, {:?}, {:?}, {:?});",
                    framebuffer,
                    buffer,
                    drawbuffer,
                    depth,
                    stencil
                );
            }
            let out = call_atomic_ptr_5arg(
                "glClearNamedFramebufferfi",
                &self.glClearNamedFramebufferfi_p,
                framebuffer,
                buffer,
                drawbuffer,
                depth,
                stencil,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearNamedFramebufferfi");
            }
            out
        }

        pub unsafe fn ClearNamedFramebufferfi_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearNamedFramebufferfi\0",
                &self.glClearNamedFramebufferfi_p,
            )
        }
        #[inline]

        pub fn ClearNamedFramebufferfi_is_loaded(&self) -> bool {
            !self.glClearNamedFramebufferfi_p.load(RELAX).is_null()
        }
        /// [glClearNamedFramebufferfv](http://docs.gl/gl4/glClearNamedFramebuffer)(framebuffer, buffer, drawbuffer, value)
        /// * `framebuffer` class: framebuffer
        /// * `buffer` group: Buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearNamedFramebufferfv(
            &self,
            framebuffer: GLuint,
            buffer: GLenum,
            drawbuffer: GLint,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearNamedFramebufferfv({:?}, {:#X}, {:?}, {:p});",
                    framebuffer,
                    buffer,
                    drawbuffer,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glClearNamedFramebufferfv",
                &self.glClearNamedFramebufferfv_p,
                framebuffer,
                buffer,
                drawbuffer,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearNamedFramebufferfv");
            }
            out
        }

        pub unsafe fn ClearNamedFramebufferfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearNamedFramebufferfv\0",
                &self.glClearNamedFramebufferfv_p,
            )
        }
        #[inline]

        pub fn ClearNamedFramebufferfv_is_loaded(&self) -> bool {
            !self.glClearNamedFramebufferfv_p.load(RELAX).is_null()
        }
        /// [glClearNamedFramebufferiv](http://docs.gl/gl4/glClearNamedFramebuffer)(framebuffer, buffer, drawbuffer, value)
        /// * `framebuffer` class: framebuffer
        /// * `buffer` group: Buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearNamedFramebufferiv(
            &self,
            framebuffer: GLuint,
            buffer: GLenum,
            drawbuffer: GLint,
            value: *const GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearNamedFramebufferiv({:?}, {:#X}, {:?}, {:p});",
                    framebuffer,
                    buffer,
                    drawbuffer,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glClearNamedFramebufferiv",
                &self.glClearNamedFramebufferiv_p,
                framebuffer,
                buffer,
                drawbuffer,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearNamedFramebufferiv");
            }
            out
        }

        pub unsafe fn ClearNamedFramebufferiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearNamedFramebufferiv\0",
                &self.glClearNamedFramebufferiv_p,
            )
        }
        #[inline]

        pub fn ClearNamedFramebufferiv_is_loaded(&self) -> bool {
            !self.glClearNamedFramebufferiv_p.load(RELAX).is_null()
        }
        /// [glClearNamedFramebufferuiv](http://docs.gl/gl4/glClearNamedFramebuffer)(framebuffer, buffer, drawbuffer, value)
        /// * `framebuffer` class: framebuffer
        /// * `buffer` group: Buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearNamedFramebufferuiv(
            &self,
            framebuffer: GLuint,
            buffer: GLenum,
            drawbuffer: GLint,
            value: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearNamedFramebufferuiv({:?}, {:#X}, {:?}, {:p});",
                    framebuffer,
                    buffer,
                    drawbuffer,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glClearNamedFramebufferuiv",
                &self.glClearNamedFramebufferuiv_p,
                framebuffer,
                buffer,
                drawbuffer,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearNamedFramebufferuiv");
            }
            out
        }

        pub unsafe fn ClearNamedFramebufferuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearNamedFramebufferuiv\0",
                &self.glClearNamedFramebufferuiv_p,
            )
        }
        #[inline]

        pub fn ClearNamedFramebufferuiv_is_loaded(&self) -> bool {
            !self.glClearNamedFramebufferuiv_p.load(RELAX).is_null()
        }
        /// [glClearStencil](http://docs.gl/gl4/glClearStencil)(s)
        /// * `s` group: StencilValue
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearStencil(&self, s: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ClearStencil({:?});", s);
            }
            let out = call_atomic_ptr_1arg("glClearStencil", &self.glClearStencil_p, s);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearStencil");
            }
            out
        }

        pub unsafe fn ClearStencil_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearStencil\0",
                &self.glClearStencil_p,
            )
        }
        #[inline]

        pub fn ClearStencil_is_loaded(&self) -> bool {
            !self.glClearStencil_p.load(RELAX).is_null()
        }
        /// [glClearTexImage](http://docs.gl/gl4/glClearTexImage)(texture, level, format, type_, data)
        /// * `texture` class: texture
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `data` len: COMPSIZE(format,type)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearTexImage(
            &self,
            texture: GLuint,
            level: GLint,
            format: GLenum,
            type_: GLenum,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClearTexImage({:?}, {:?}, {:#X}, {:#X}, {:p});",
                    texture,
                    level,
                    format,
                    type_,
                    data
                );
            }
            let out = call_atomic_ptr_5arg(
                "glClearTexImage",
                &self.glClearTexImage_p,
                texture,
                level,
                format,
                type_,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearTexImage");
            }
            out
        }

        pub unsafe fn ClearTexImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearTexImage\0",
                &self.glClearTexImage_p,
            )
        }
        #[inline]

        pub fn ClearTexImage_is_loaded(&self) -> bool {
            !self.glClearTexImage_p.load(RELAX).is_null()
        }
        /// [glClearTexSubImage](http://docs.gl/gl4/glClearTexSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data)
        /// * `texture` class: texture
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `data` len: COMPSIZE(format,type)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClearTexSubImage(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            zoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            format: GLenum,
            type_: GLenum,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ClearTexSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data);
            }
            let out = call_atomic_ptr_11arg(
                "glClearTexSubImage",
                &self.glClearTexSubImage_p,
                texture,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                format,
                type_,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClearTexSubImage");
            }
            out
        }

        pub unsafe fn ClearTexSubImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClearTexSubImage\0",
                &self.glClearTexSubImage_p,
            )
        }
        #[inline]

        pub fn ClearTexSubImage_is_loaded(&self) -> bool {
            !self.glClearTexSubImage_p.load(RELAX).is_null()
        }
        /// [glClientWaitSync](http://docs.gl/gl4/glClientWaitSync)(sync, flags, timeout)
        /// * `sync` group: sync
        /// * `sync` class: sync
        /// * `flags` group: SyncObjectMask
        /// * return value group: SyncStatus
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClientWaitSync(
            &self,
            sync: GLsync,
            flags: GLbitfield,
            timeout: GLuint64,
        ) -> GLenum {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ClientWaitSync({:p}, {:?}, {:?});",
                    sync,
                    flags,
                    timeout
                );
            }
            let out = call_atomic_ptr_3arg(
                "glClientWaitSync",
                &self.glClientWaitSync_p,
                sync,
                flags,
                timeout,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClientWaitSync");
            }
            out
        }

        pub unsafe fn ClientWaitSync_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glClientWaitSync\0",
                &self.glClientWaitSync_p,
            )
        }
        #[inline]

        pub fn ClientWaitSync_is_loaded(&self) -> bool {
            !self.glClientWaitSync_p.load(RELAX).is_null()
        }
        /// [glClipControl](http://docs.gl/gl4/glClipControl)(origin, depth)
        /// * `origin` group: ClipControlOrigin
        /// * `depth` group: ClipControlDepth
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ClipControl(&self, origin: GLenum, depth: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ClipControl({:#X}, {:#X});", origin, depth);
            }
            let out = call_atomic_ptr_2arg("glClipControl", &self.glClipControl_p, origin, depth);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glClipControl");
            }
            out
        }

        pub unsafe fn ClipControl_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glClipControl\0", &self.glClipControl_p)
        }
        #[inline]

        pub fn ClipControl_is_loaded(&self) -> bool {
            !self.glClipControl_p.load(RELAX).is_null()
        }
        /// [glColorMask](http://docs.gl/gl4/glColorMask)(red, green, blue, alpha)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ColorMask(
            &self,
            red: GLboolean,
            green: GLboolean,
            blue: GLboolean,
            alpha: GLboolean,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ColorMask({:?}, {:?}, {:?}, {:?});",
                    red,
                    green,
                    blue,
                    alpha
                );
            }
            let out =
                call_atomic_ptr_4arg("glColorMask", &self.glColorMask_p, red, green, blue, alpha);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glColorMask");
            }
            out
        }

        pub unsafe fn ColorMask_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glColorMask\0", &self.glColorMask_p)
        }
        #[inline]

        pub fn ColorMask_is_loaded(&self) -> bool {
            !self.glColorMask_p.load(RELAX).is_null()
        }
        /// [glColorMaski](http://docs.gl/gl4/glColorMask)(index, r, g, b, a)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ColorMaski(
            &self,
            index: GLuint,
            r: GLboolean,
            g: GLboolean,
            b: GLboolean,
            a: GLboolean,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ColorMaski({:?}, {:?}, {:?}, {:?}, {:?});",
                    index,
                    r,
                    g,
                    b,
                    a
                );
            }
            let out = call_atomic_ptr_5arg("glColorMaski", &self.glColorMaski_p, index, r, g, b, a);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glColorMaski");
            }
            out
        }

        pub unsafe fn ColorMaski_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glColorMaski\0", &self.glColorMaski_p)
        }
        #[inline]

        pub fn ColorMaski_is_loaded(&self) -> bool {
            !self.glColorMaski_p.load(RELAX).is_null()
        }
        /// [glCompileShader](http://docs.gl/gl4/glCompileShader)(shader)
        /// * `shader` class: shader
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CompileShader(&self, shader: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CompileShader({:?});", shader);
            }
            let out = call_atomic_ptr_1arg("glCompileShader", &self.glCompileShader_p, shader);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCompileShader");
            }
            out
        }

        pub unsafe fn CompileShader_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCompileShader\0",
                &self.glCompileShader_p,
            )
        }
        #[inline]

        pub fn CompileShader_is_loaded(&self) -> bool {
            !self.glCompileShader_p.load(RELAX).is_null()
        }
        /// [glCompressedTexImage1D](http://docs.gl/gl4/glCompressedTexImage1D)(target, level, internalformat, width, border, imageSize, data)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `internalformat` group: InternalFormat
        /// * `border` group: CheckedInt32
        /// * `data` group: CompressedTextureARB
        /// * `data` len: imageSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CompressedTexImage1D(
            &self,
            target: GLenum,
            level: GLint,
            internalformat: GLenum,
            width: GLsizei,
            border: GLint,
            imageSize: GLsizei,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CompressedTexImage1D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:p});",
                    target,
                    level,
                    internalformat,
                    width,
                    border,
                    imageSize,
                    data
                );
            }
            let out = call_atomic_ptr_7arg(
                "glCompressedTexImage1D",
                &self.glCompressedTexImage1D_p,
                target,
                level,
                internalformat,
                width,
                border,
                imageSize,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCompressedTexImage1D");
            }
            out
        }

        pub unsafe fn CompressedTexImage1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCompressedTexImage1D\0",
                &self.glCompressedTexImage1D_p,
            )
        }
        #[inline]

        pub fn CompressedTexImage1D_is_loaded(&self) -> bool {
            !self.glCompressedTexImage1D_p.load(RELAX).is_null()
        }
        /// [glCompressedTexImage2D](http://docs.gl/gl4/glCompressedTexImage2D)(target, level, internalformat, width, height, border, imageSize, data)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `internalformat` group: InternalFormat
        /// * `border` group: CheckedInt32
        /// * `data` group: CompressedTextureARB
        /// * `data` len: imageSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CompressedTexImage2D(
            &self,
            target: GLenum,
            level: GLint,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
            border: GLint,
            imageSize: GLsizei,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CompressedTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, height, border, imageSize, data);
            }
            let out = call_atomic_ptr_8arg(
                "glCompressedTexImage2D",
                &self.glCompressedTexImage2D_p,
                target,
                level,
                internalformat,
                width,
                height,
                border,
                imageSize,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCompressedTexImage2D");
            }
            out
        }

        pub unsafe fn CompressedTexImage2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCompressedTexImage2D\0",
                &self.glCompressedTexImage2D_p,
            )
        }
        #[inline]

        pub fn CompressedTexImage2D_is_loaded(&self) -> bool {
            !self.glCompressedTexImage2D_p.load(RELAX).is_null()
        }
        /// [glCompressedTexImage3D](http://docs.gl/gl4/glCompressedTexImage3D)(target, level, internalformat, width, height, depth, border, imageSize, data)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `internalformat` group: InternalFormat
        /// * `border` group: CheckedInt32
        /// * `data` group: CompressedTextureARB
        /// * `data` len: imageSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CompressedTexImage3D(
            &self,
            target: GLenum,
            level: GLint,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            border: GLint,
            imageSize: GLsizei,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CompressedTexImage3D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, height, depth, border, imageSize, data);
            }
            let out = call_atomic_ptr_9arg(
                "glCompressedTexImage3D",
                &self.glCompressedTexImage3D_p,
                target,
                level,
                internalformat,
                width,
                height,
                depth,
                border,
                imageSize,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCompressedTexImage3D");
            }
            out
        }

        pub unsafe fn CompressedTexImage3D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCompressedTexImage3D\0",
                &self.glCompressedTexImage3D_p,
            )
        }
        #[inline]

        pub fn CompressedTexImage3D_is_loaded(&self) -> bool {
            !self.glCompressedTexImage3D_p.load(RELAX).is_null()
        }
        /// [glCompressedTexSubImage1D](http://docs.gl/gl4/glCompressedTexSubImage1D)(target, level, xoffset, width, format, imageSize, data)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `xoffset` group: CheckedInt32
        /// * `format` group: InternalFormat
        /// * `data` group: CompressedTextureARB
        /// * `data` len: imageSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CompressedTexSubImage1D(
            &self,
            target: GLenum,
            level: GLint,
            xoffset: GLint,
            width: GLsizei,
            format: GLenum,
            imageSize: GLsizei,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CompressedTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, width, format, imageSize, data);
            }
            let out = call_atomic_ptr_7arg(
                "glCompressedTexSubImage1D",
                &self.glCompressedTexSubImage1D_p,
                target,
                level,
                xoffset,
                width,
                format,
                imageSize,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCompressedTexSubImage1D");
            }
            out
        }

        pub unsafe fn CompressedTexSubImage1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCompressedTexSubImage1D\0",
                &self.glCompressedTexSubImage1D_p,
            )
        }
        #[inline]

        pub fn CompressedTexSubImage1D_is_loaded(&self) -> bool {
            !self.glCompressedTexSubImage1D_p.load(RELAX).is_null()
        }
        /// [glCompressedTexSubImage2D](http://docs.gl/gl4/glCompressedTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, imageSize, data)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `xoffset` group: CheckedInt32
        /// * `yoffset` group: CheckedInt32
        /// * `format` group: InternalFormat
        /// * `data` group: CompressedTextureARB
        /// * `data` len: imageSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CompressedTexSubImage2D(
            &self,
            target: GLenum,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            format: GLenum,
            imageSize: GLsizei,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CompressedTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, width, height, format, imageSize, data);
            }
            let out = call_atomic_ptr_9arg(
                "glCompressedTexSubImage2D",
                &self.glCompressedTexSubImage2D_p,
                target,
                level,
                xoffset,
                yoffset,
                width,
                height,
                format,
                imageSize,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCompressedTexSubImage2D");
            }
            out
        }

        pub unsafe fn CompressedTexSubImage2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCompressedTexSubImage2D\0",
                &self.glCompressedTexSubImage2D_p,
            )
        }
        #[inline]

        pub fn CompressedTexSubImage2D_is_loaded(&self) -> bool {
            !self.glCompressedTexSubImage2D_p.load(RELAX).is_null()
        }
        /// [glCompressedTexSubImage3D](http://docs.gl/gl4/glCompressedTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `xoffset` group: CheckedInt32
        /// * `yoffset` group: CheckedInt32
        /// * `zoffset` group: CheckedInt32
        /// * `format` group: InternalFormat
        /// * `data` group: CompressedTextureARB
        /// * `data` len: imageSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CompressedTexSubImage3D(
            &self,
            target: GLenum,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            zoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            format: GLenum,
            imageSize: GLsizei,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CompressedTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
            }
            let out = call_atomic_ptr_11arg(
                "glCompressedTexSubImage3D",
                &self.glCompressedTexSubImage3D_p,
                target,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                format,
                imageSize,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCompressedTexSubImage3D");
            }
            out
        }

        pub unsafe fn CompressedTexSubImage3D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCompressedTexSubImage3D\0",
                &self.glCompressedTexSubImage3D_p,
            )
        }
        #[inline]

        pub fn CompressedTexSubImage3D_is_loaded(&self) -> bool {
            !self.glCompressedTexSubImage3D_p.load(RELAX).is_null()
        }
        /// [glCompressedTextureSubImage1D](http://docs.gl/gl4/glCompressedTextureSubImage1D)(texture, level, xoffset, width, format, imageSize, data)
        /// * `texture` class: texture
        /// * `format` group: InternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CompressedTextureSubImage1D(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            width: GLsizei,
            format: GLenum,
            imageSize: GLsizei,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CompressedTextureSubImage1D({:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", texture, level, xoffset, width, format, imageSize, data);
            }
            let out = call_atomic_ptr_7arg(
                "glCompressedTextureSubImage1D",
                &self.glCompressedTextureSubImage1D_p,
                texture,
                level,
                xoffset,
                width,
                format,
                imageSize,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCompressedTextureSubImage1D");
            }
            out
        }

        pub unsafe fn CompressedTextureSubImage1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCompressedTextureSubImage1D\0",
                &self.glCompressedTextureSubImage1D_p,
            )
        }
        #[inline]

        pub fn CompressedTextureSubImage1D_is_loaded(&self) -> bool {
            !self.glCompressedTextureSubImage1D_p.load(RELAX).is_null()
        }
        /// [glCompressedTextureSubImage2D](http://docs.gl/gl4/glCompressedTextureSubImage2D)(texture, level, xoffset, yoffset, width, height, format, imageSize, data)
        /// * `texture` class: texture
        /// * `format` group: InternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CompressedTextureSubImage2D(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            format: GLenum,
            imageSize: GLsizei,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CompressedTextureSubImage2D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", texture, level, xoffset, yoffset, width, height, format, imageSize, data);
            }
            let out = call_atomic_ptr_9arg(
                "glCompressedTextureSubImage2D",
                &self.glCompressedTextureSubImage2D_p,
                texture,
                level,
                xoffset,
                yoffset,
                width,
                height,
                format,
                imageSize,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCompressedTextureSubImage2D");
            }
            out
        }

        pub unsafe fn CompressedTextureSubImage2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCompressedTextureSubImage2D\0",
                &self.glCompressedTextureSubImage2D_p,
            )
        }
        #[inline]

        pub fn CompressedTextureSubImage2D_is_loaded(&self) -> bool {
            !self.glCompressedTextureSubImage2D_p.load(RELAX).is_null()
        }
        /// [glCompressedTextureSubImage3D](http://docs.gl/gl4/glCompressedTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)
        /// * `texture` class: texture
        /// * `format` group: InternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CompressedTextureSubImage3D(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            zoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            format: GLenum,
            imageSize: GLsizei,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CompressedTextureSubImage3D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
            }
            let out = call_atomic_ptr_11arg(
                "glCompressedTextureSubImage3D",
                &self.glCompressedTextureSubImage3D_p,
                texture,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                format,
                imageSize,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCompressedTextureSubImage3D");
            }
            out
        }

        pub unsafe fn CompressedTextureSubImage3D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCompressedTextureSubImage3D\0",
                &self.glCompressedTextureSubImage3D_p,
            )
        }
        #[inline]

        pub fn CompressedTextureSubImage3D_is_loaded(&self) -> bool {
            !self.glCompressedTextureSubImage3D_p.load(RELAX).is_null()
        }
        /// [glCopyBufferSubData](http://docs.gl/gl4/glCopyBufferSubData)(readTarget, writeTarget, readOffset, writeOffset, size)
        /// * `readTarget` group: CopyBufferSubDataTarget
        /// * `writeTarget` group: CopyBufferSubDataTarget
        /// * `readOffset` group: BufferOffset
        /// * `writeOffset` group: BufferOffset
        /// * `size` group: BufferSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CopyBufferSubData(
            &self,
            readTarget: GLenum,
            writeTarget: GLenum,
            readOffset: GLintptr,
            writeOffset: GLintptr,
            size: GLsizeiptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CopyBufferSubData({:#X}, {:#X}, {:?}, {:?}, {:?});",
                    readTarget,
                    writeTarget,
                    readOffset,
                    writeOffset,
                    size
                );
            }
            let out = call_atomic_ptr_5arg(
                "glCopyBufferSubData",
                &self.glCopyBufferSubData_p,
                readTarget,
                writeTarget,
                readOffset,
                writeOffset,
                size,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCopyBufferSubData");
            }
            out
        }

        pub unsafe fn CopyBufferSubData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCopyBufferSubData\0",
                &self.glCopyBufferSubData_p,
            )
        }
        #[inline]

        pub fn CopyBufferSubData_is_loaded(&self) -> bool {
            !self.glCopyBufferSubData_p.load(RELAX).is_null()
        }
        /// [glCopyImageSubData](http://docs.gl/gl4/glCopyImageSubData)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)
        /// * `srcTarget` group: CopyImageSubDataTarget
        /// * `dstTarget` group: CopyImageSubDataTarget
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CopyImageSubData(
            &self,
            srcName: GLuint,
            srcTarget: GLenum,
            srcLevel: GLint,
            srcX: GLint,
            srcY: GLint,
            srcZ: GLint,
            dstName: GLuint,
            dstTarget: GLenum,
            dstLevel: GLint,
            dstX: GLint,
            dstY: GLint,
            dstZ: GLint,
            srcWidth: GLsizei,
            srcHeight: GLsizei,
            srcDepth: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CopyImageSubData({:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
            }
            let out = call_atomic_ptr_15arg(
                "glCopyImageSubData",
                &self.glCopyImageSubData_p,
                srcName,
                srcTarget,
                srcLevel,
                srcX,
                srcY,
                srcZ,
                dstName,
                dstTarget,
                dstLevel,
                dstX,
                dstY,
                dstZ,
                srcWidth,
                srcHeight,
                srcDepth,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCopyImageSubData");
            }
            out
        }

        pub unsafe fn CopyImageSubData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCopyImageSubData\0",
                &self.glCopyImageSubData_p,
            )
        }
        #[inline]

        pub fn CopyImageSubData_is_loaded(&self) -> bool {
            !self.glCopyImageSubData_p.load(RELAX).is_null()
        }
        /// [glCopyNamedBufferSubData](http://docs.gl/gl4/glCopyNamedBufferSubData)(readBuffer, writeBuffer, readOffset, writeOffset, size)
        /// * `readBuffer` class: buffer
        /// * `writeBuffer` class: buffer
        /// * `size` group: BufferSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CopyNamedBufferSubData(
            &self,
            readBuffer: GLuint,
            writeBuffer: GLuint,
            readOffset: GLintptr,
            writeOffset: GLintptr,
            size: GLsizeiptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CopyNamedBufferSubData({:?}, {:?}, {:?}, {:?}, {:?});",
                    readBuffer,
                    writeBuffer,
                    readOffset,
                    writeOffset,
                    size
                );
            }
            let out = call_atomic_ptr_5arg(
                "glCopyNamedBufferSubData",
                &self.glCopyNamedBufferSubData_p,
                readBuffer,
                writeBuffer,
                readOffset,
                writeOffset,
                size,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCopyNamedBufferSubData");
            }
            out
        }

        pub unsafe fn CopyNamedBufferSubData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCopyNamedBufferSubData\0",
                &self.glCopyNamedBufferSubData_p,
            )
        }
        #[inline]

        pub fn CopyNamedBufferSubData_is_loaded(&self) -> bool {
            !self.glCopyNamedBufferSubData_p.load(RELAX).is_null()
        }
        /// [glCopyTexImage1D](http://docs.gl/gl4/glCopyTexImage1D)(target, level, internalformat, x, y, width, border)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `internalformat` group: InternalFormat
        /// * `x` group: WinCoord
        /// * `y` group: WinCoord
        /// * `border` group: CheckedInt32
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CopyTexImage1D(
            &self,
            target: GLenum,
            level: GLint,
            internalformat: GLenum,
            x: GLint,
            y: GLint,
            width: GLsizei,
            border: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CopyTexImage1D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});",
                    target,
                    level,
                    internalformat,
                    x,
                    y,
                    width,
                    border
                );
            }
            let out = call_atomic_ptr_7arg(
                "glCopyTexImage1D",
                &self.glCopyTexImage1D_p,
                target,
                level,
                internalformat,
                x,
                y,
                width,
                border,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCopyTexImage1D");
            }
            out
        }

        pub unsafe fn CopyTexImage1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCopyTexImage1D\0",
                &self.glCopyTexImage1D_p,
            )
        }
        #[inline]

        pub fn CopyTexImage1D_is_loaded(&self) -> bool {
            !self.glCopyTexImage1D_p.load(RELAX).is_null()
        }
        /// [glCopyTexImage2D](http://docs.gl/gl4/glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `internalformat` group: InternalFormat
        /// * `x` group: WinCoord
        /// * `y` group: WinCoord
        /// * `border` group: CheckedInt32
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CopyTexImage2D(
            &self,
            target: GLenum,
            level: GLint,
            internalformat: GLenum,
            x: GLint,
            y: GLint,
            width: GLsizei,
            height: GLsizei,
            border: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CopyTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
                    target,
                    level,
                    internalformat,
                    x,
                    y,
                    width,
                    height,
                    border
                );
            }
            let out = call_atomic_ptr_8arg(
                "glCopyTexImage2D",
                &self.glCopyTexImage2D_p,
                target,
                level,
                internalformat,
                x,
                y,
                width,
                height,
                border,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCopyTexImage2D");
            }
            out
        }

        pub unsafe fn CopyTexImage2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCopyTexImage2D\0",
                &self.glCopyTexImage2D_p,
            )
        }
        #[inline]

        pub fn CopyTexImage2D_is_loaded(&self) -> bool {
            !self.glCopyTexImage2D_p.load(RELAX).is_null()
        }
        /// [glCopyTexSubImage1D](http://docs.gl/gl4/glCopyTexSubImage1D)(target, level, xoffset, x, y, width)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `xoffset` group: CheckedInt32
        /// * `x` group: WinCoord
        /// * `y` group: WinCoord
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CopyTexSubImage1D(
            &self,
            target: GLenum,
            level: GLint,
            xoffset: GLint,
            x: GLint,
            y: GLint,
            width: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CopyTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
                    target,
                    level,
                    xoffset,
                    x,
                    y,
                    width
                );
            }
            let out = call_atomic_ptr_6arg(
                "glCopyTexSubImage1D",
                &self.glCopyTexSubImage1D_p,
                target,
                level,
                xoffset,
                x,
                y,
                width,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCopyTexSubImage1D");
            }
            out
        }

        pub unsafe fn CopyTexSubImage1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCopyTexSubImage1D\0",
                &self.glCopyTexSubImage1D_p,
            )
        }
        #[inline]

        pub fn CopyTexSubImage1D_is_loaded(&self) -> bool {
            !self.glCopyTexSubImage1D_p.load(RELAX).is_null()
        }
        /// [glCopyTexSubImage2D](http://docs.gl/gl4/glCopyTexSubImage2D)(target, level, xoffset, yoffset, x, y, width, height)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `xoffset` group: CheckedInt32
        /// * `yoffset` group: CheckedInt32
        /// * `x` group: WinCoord
        /// * `y` group: WinCoord
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CopyTexSubImage2D(
            &self,
            target: GLenum,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            x: GLint,
            y: GLint,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CopyTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, xoffset, yoffset, x, y, width, height);
            }
            let out = call_atomic_ptr_8arg(
                "glCopyTexSubImage2D",
                &self.glCopyTexSubImage2D_p,
                target,
                level,
                xoffset,
                yoffset,
                x,
                y,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCopyTexSubImage2D");
            }
            out
        }

        pub unsafe fn CopyTexSubImage2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCopyTexSubImage2D\0",
                &self.glCopyTexSubImage2D_p,
            )
        }
        #[inline]

        pub fn CopyTexSubImage2D_is_loaded(&self) -> bool {
            !self.glCopyTexSubImage2D_p.load(RELAX).is_null()
        }
        /// [glCopyTexSubImage3D](http://docs.gl/gl4/glCopyTexSubImage3D)(target, level, xoffset, yoffset, zoffset, x, y, width, height)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `xoffset` group: CheckedInt32
        /// * `yoffset` group: CheckedInt32
        /// * `zoffset` group: CheckedInt32
        /// * `x` group: WinCoord
        /// * `y` group: WinCoord
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CopyTexSubImage3D(
            &self,
            target: GLenum,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            zoffset: GLint,
            x: GLint,
            y: GLint,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CopyTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, xoffset, yoffset, zoffset, x, y, width, height);
            }
            let out = call_atomic_ptr_9arg(
                "glCopyTexSubImage3D",
                &self.glCopyTexSubImage3D_p,
                target,
                level,
                xoffset,
                yoffset,
                zoffset,
                x,
                y,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCopyTexSubImage3D");
            }
            out
        }

        pub unsafe fn CopyTexSubImage3D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCopyTexSubImage3D\0",
                &self.glCopyTexSubImage3D_p,
            )
        }
        #[inline]

        pub fn CopyTexSubImage3D_is_loaded(&self) -> bool {
            !self.glCopyTexSubImage3D_p.load(RELAX).is_null()
        }
        /// [glCopyTextureSubImage1D](http://docs.gl/gl4/glCopyTextureSubImage1D)(texture, level, xoffset, x, y, width)
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CopyTextureSubImage1D(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            x: GLint,
            y: GLint,
            width: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CopyTextureSubImage1D({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                    texture,
                    level,
                    xoffset,
                    x,
                    y,
                    width
                );
            }
            let out = call_atomic_ptr_6arg(
                "glCopyTextureSubImage1D",
                &self.glCopyTextureSubImage1D_p,
                texture,
                level,
                xoffset,
                x,
                y,
                width,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCopyTextureSubImage1D");
            }
            out
        }

        pub unsafe fn CopyTextureSubImage1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCopyTextureSubImage1D\0",
                &self.glCopyTextureSubImage1D_p,
            )
        }
        #[inline]

        pub fn CopyTextureSubImage1D_is_loaded(&self) -> bool {
            !self.glCopyTextureSubImage1D_p.load(RELAX).is_null()
        }
        /// [glCopyTextureSubImage2D](http://docs.gl/gl4/glCopyTextureSubImage2D)(texture, level, xoffset, yoffset, x, y, width, height)
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CopyTextureSubImage2D(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            x: GLint,
            y: GLint,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CopyTextureSubImage2D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", texture, level, xoffset, yoffset, x, y, width, height);
            }
            let out = call_atomic_ptr_8arg(
                "glCopyTextureSubImage2D",
                &self.glCopyTextureSubImage2D_p,
                texture,
                level,
                xoffset,
                yoffset,
                x,
                y,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCopyTextureSubImage2D");
            }
            out
        }

        pub unsafe fn CopyTextureSubImage2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCopyTextureSubImage2D\0",
                &self.glCopyTextureSubImage2D_p,
            )
        }
        #[inline]

        pub fn CopyTextureSubImage2D_is_loaded(&self) -> bool {
            !self.glCopyTextureSubImage2D_p.load(RELAX).is_null()
        }
        /// [glCopyTextureSubImage3D](http://docs.gl/gl4/glCopyTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, x, y, width, height)
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CopyTextureSubImage3D(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            zoffset: GLint,
            x: GLint,
            y: GLint,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CopyTextureSubImage3D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", texture, level, xoffset, yoffset, zoffset, x, y, width, height);
            }
            let out = call_atomic_ptr_9arg(
                "glCopyTextureSubImage3D",
                &self.glCopyTextureSubImage3D_p,
                texture,
                level,
                xoffset,
                yoffset,
                zoffset,
                x,
                y,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCopyTextureSubImage3D");
            }
            out
        }

        pub unsafe fn CopyTextureSubImage3D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCopyTextureSubImage3D\0",
                &self.glCopyTextureSubImage3D_p,
            )
        }
        #[inline]

        pub fn CopyTextureSubImage3D_is_loaded(&self) -> bool {
            !self.glCopyTextureSubImage3D_p.load(RELAX).is_null()
        }
        /// [glCreateBuffers](http://docs.gl/gl4/glCreateBuffers)(n, buffers)
        /// * `buffers` len: n
        /// * `buffers` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateBuffers(&self, n: GLsizei, buffers: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CreateBuffers({:?}, {:p});", n, buffers);
            }
            let out = call_atomic_ptr_2arg("glCreateBuffers", &self.glCreateBuffers_p, n, buffers);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateBuffers");
            }
            out
        }

        pub unsafe fn CreateBuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateBuffers\0",
                &self.glCreateBuffers_p,
            )
        }
        #[inline]

        pub fn CreateBuffers_is_loaded(&self) -> bool {
            !self.glCreateBuffers_p.load(RELAX).is_null()
        }
        /// [glCreateFramebuffers](http://docs.gl/gl4/glCreateFramebuffers)(n, framebuffers)
        /// * `framebuffers` len: n
        /// * `framebuffers` class: framebuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CreateFramebuffers({:?}, {:p});",
                    n,
                    framebuffers
                );
            }
            let out = call_atomic_ptr_2arg(
                "glCreateFramebuffers",
                &self.glCreateFramebuffers_p,
                n,
                framebuffers,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateFramebuffers");
            }
            out
        }

        pub unsafe fn CreateFramebuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateFramebuffers\0",
                &self.glCreateFramebuffers_p,
            )
        }
        #[inline]

        pub fn CreateFramebuffers_is_loaded(&self) -> bool {
            !self.glCreateFramebuffers_p.load(RELAX).is_null()
        }
        /// [glCreateProgram](http://docs.gl/gl4/glCreateProgram)()
        /// * return value class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateProgram(&self) -> GLuint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CreateProgram();",);
            }
            let out = call_atomic_ptr_0arg("glCreateProgram", &self.glCreateProgram_p);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateProgram");
            }
            out
        }

        pub unsafe fn CreateProgram_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateProgram\0",
                &self.glCreateProgram_p,
            )
        }
        #[inline]

        pub fn CreateProgram_is_loaded(&self) -> bool {
            !self.glCreateProgram_p.load(RELAX).is_null()
        }
        /// [glCreateProgramPipelines](http://docs.gl/gl4/glCreateProgramPipelines)(n, pipelines)
        /// * `pipelines` len: n
        /// * `pipelines` class: program pipeline
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CreateProgramPipelines({:?}, {:p});",
                    n,
                    pipelines
                );
            }
            let out = call_atomic_ptr_2arg(
                "glCreateProgramPipelines",
                &self.glCreateProgramPipelines_p,
                n,
                pipelines,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateProgramPipelines");
            }
            out
        }

        pub unsafe fn CreateProgramPipelines_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateProgramPipelines\0",
                &self.glCreateProgramPipelines_p,
            )
        }
        #[inline]

        pub fn CreateProgramPipelines_is_loaded(&self) -> bool {
            !self.glCreateProgramPipelines_p.load(RELAX).is_null()
        }
        /// [glCreateQueries](http://docs.gl/gl4/glCreateQueries)(target, n, ids)
        /// * `target` group: QueryTarget
        /// * `ids` len: n
        /// * `ids` class: query
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateQueries(&self, target: GLenum, n: GLsizei, ids: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CreateQueries({:#X}, {:?}, {:p});",
                    target,
                    n,
                    ids
                );
            }
            let out =
                call_atomic_ptr_3arg("glCreateQueries", &self.glCreateQueries_p, target, n, ids);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateQueries");
            }
            out
        }

        pub unsafe fn CreateQueries_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateQueries\0",
                &self.glCreateQueries_p,
            )
        }
        #[inline]

        pub fn CreateQueries_is_loaded(&self) -> bool {
            !self.glCreateQueries_p.load(RELAX).is_null()
        }
        /// [glCreateRenderbuffers](http://docs.gl/gl4/glCreateRenderbuffers)(n, renderbuffers)
        /// * `renderbuffers` len: n
        /// * `renderbuffers` class: renderbuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CreateRenderbuffers({:?}, {:p});",
                    n,
                    renderbuffers
                );
            }
            let out = call_atomic_ptr_2arg(
                "glCreateRenderbuffers",
                &self.glCreateRenderbuffers_p,
                n,
                renderbuffers,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateRenderbuffers");
            }
            out
        }

        pub unsafe fn CreateRenderbuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateRenderbuffers\0",
                &self.glCreateRenderbuffers_p,
            )
        }
        #[inline]

        pub fn CreateRenderbuffers_is_loaded(&self) -> bool {
            !self.glCreateRenderbuffers_p.load(RELAX).is_null()
        }
        /// [glCreateSamplers](http://docs.gl/gl4/glCreateSamplers)(n, samplers)
        /// * `samplers` len: n
        /// * `samplers` class: sampler
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateSamplers(&self, n: GLsizei, samplers: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CreateSamplers({:?}, {:p});", n, samplers);
            }
            let out =
                call_atomic_ptr_2arg("glCreateSamplers", &self.glCreateSamplers_p, n, samplers);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateSamplers");
            }
            out
        }

        pub unsafe fn CreateSamplers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateSamplers\0",
                &self.glCreateSamplers_p,
            )
        }
        #[inline]

        pub fn CreateSamplers_is_loaded(&self) -> bool {
            !self.glCreateSamplers_p.load(RELAX).is_null()
        }
        /// [glCreateShader](http://docs.gl/gl4/glCreateShader)(type_)
        /// * `type_` group: ShaderType
        /// * return value class: shader
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateShader(&self, type_: GLenum) -> GLuint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CreateShader({:#X});", type_);
            }
            let out = call_atomic_ptr_1arg("glCreateShader", &self.glCreateShader_p, type_);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateShader");
            }
            out
        }

        pub unsafe fn CreateShader_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateShader\0",
                &self.glCreateShader_p,
            )
        }
        #[inline]

        pub fn CreateShader_is_loaded(&self) -> bool {
            !self.glCreateShader_p.load(RELAX).is_null()
        }
        /// [glCreateShaderProgramv](http://docs.gl/gl4/glCreateShaderProgramv)(type_, count, strings)
        /// * `type_` group: ShaderType
        /// * `strings` len: count
        /// * return value class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateShaderProgramv(
            &self,
            type_: GLenum,
            count: GLsizei,
            strings: *const *const GLchar,
        ) -> GLuint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CreateShaderProgramv({:#X}, {:?}, {:p});",
                    type_,
                    count,
                    strings
                );
            }
            let out = call_atomic_ptr_3arg(
                "glCreateShaderProgramv",
                &self.glCreateShaderProgramv_p,
                type_,
                count,
                strings,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateShaderProgramv");
            }
            out
        }

        pub unsafe fn CreateShaderProgramv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateShaderProgramv\0",
                &self.glCreateShaderProgramv_p,
            )
        }
        #[inline]

        pub fn CreateShaderProgramv_is_loaded(&self) -> bool {
            !self.glCreateShaderProgramv_p.load(RELAX).is_null()
        }
        /// [glCreateTextures](http://docs.gl/gl4/glCreateTextures)(target, n, textures)
        /// * `target` group: TextureTarget
        /// * `textures` len: n
        /// * `textures` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateTextures(&self, target: GLenum, n: GLsizei, textures: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.CreateTextures({:#X}, {:?}, {:p});",
                    target,
                    n,
                    textures
                );
            }
            let out = call_atomic_ptr_3arg(
                "glCreateTextures",
                &self.glCreateTextures_p,
                target,
                n,
                textures,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateTextures");
            }
            out
        }

        pub unsafe fn CreateTextures_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateTextures\0",
                &self.glCreateTextures_p,
            )
        }
        #[inline]

        pub fn CreateTextures_is_loaded(&self) -> bool {
            !self.glCreateTextures_p.load(RELAX).is_null()
        }
        /// [glCreateTransformFeedbacks](http://docs.gl/gl4/glCreateTransformFeedbacks)(n, ids)
        /// * `ids` len: n
        /// * `ids` class: transform feedback
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CreateTransformFeedbacks({:?}, {:p});", n, ids);
            }
            let out = call_atomic_ptr_2arg(
                "glCreateTransformFeedbacks",
                &self.glCreateTransformFeedbacks_p,
                n,
                ids,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateTransformFeedbacks");
            }
            out
        }

        pub unsafe fn CreateTransformFeedbacks_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateTransformFeedbacks\0",
                &self.glCreateTransformFeedbacks_p,
            )
        }
        #[inline]

        pub fn CreateTransformFeedbacks_is_loaded(&self) -> bool {
            !self.glCreateTransformFeedbacks_p.load(RELAX).is_null()
        }
        /// [glCreateVertexArrays](http://docs.gl/gl4/glCreateVertexArrays)(n, arrays)
        /// * `arrays` len: n
        /// * `arrays` class: vertex array
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CreateVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CreateVertexArrays({:?}, {:p});", n, arrays);
            }
            let out = call_atomic_ptr_2arg(
                "glCreateVertexArrays",
                &self.glCreateVertexArrays_p,
                n,
                arrays,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCreateVertexArrays");
            }
            out
        }

        pub unsafe fn CreateVertexArrays_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glCreateVertexArrays\0",
                &self.glCreateVertexArrays_p,
            )
        }
        #[inline]

        pub fn CreateVertexArrays_is_loaded(&self) -> bool {
            !self.glCreateVertexArrays_p.load(RELAX).is_null()
        }
        /// [glCullFace](http://docs.gl/gl4/glCullFace)(mode)
        /// * `mode` group: CullFaceMode
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn CullFace(&self, mode: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.CullFace({:#X});", mode);
            }
            let out = call_atomic_ptr_1arg("glCullFace", &self.glCullFace_p, mode);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glCullFace");
            }
            out
        }

        pub unsafe fn CullFace_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glCullFace\0", &self.glCullFace_p)
        }
        #[inline]

        pub fn CullFace_is_loaded(&self) -> bool {
            !self.glCullFace_p.load(RELAX).is_null()
        }
        /// [glDebugMessageCallback](http://docs.gl/gl4/glDebugMessageCallback)(callback, userParam)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DebugMessageCallback(&self, callback: GLDEBUGPROC, userParam: *const c_void) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DebugMessageCallback({:?}, {:p});",
                    transmute::<_, Option<fn()>>(callback),
                    userParam
                );
            }
            let out = call_atomic_ptr_2arg(
                "glDebugMessageCallback",
                &self.glDebugMessageCallback_p,
                callback,
                userParam,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDebugMessageCallback");
            }
            out
        }

        pub unsafe fn DebugMessageCallback_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDebugMessageCallback\0",
                &self.glDebugMessageCallback_p,
            )
        }
        #[inline]

        pub fn DebugMessageCallback_is_loaded(&self) -> bool {
            !self.glDebugMessageCallback_p.load(RELAX).is_null()
        }
        /// [glDebugMessageControl](http://docs.gl/gl4/glDebugMessageControl)(source, type_, severity, count, ids, enabled)
        /// * `source` group: DebugSource
        /// * `type_` group: DebugType
        /// * `severity` group: DebugSeverity
        /// * `ids` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DebugMessageControl(
            &self,
            source: GLenum,
            type_: GLenum,
            severity: GLenum,
            count: GLsizei,
            ids: *const GLuint,
            enabled: GLboolean,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DebugMessageControl({:#X}, {:#X}, {:#X}, {:?}, {:p}, {:?});",
                    source,
                    type_,
                    severity,
                    count,
                    ids,
                    enabled
                );
            }
            let out = call_atomic_ptr_6arg(
                "glDebugMessageControl",
                &self.glDebugMessageControl_p,
                source,
                type_,
                severity,
                count,
                ids,
                enabled,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDebugMessageControl");
            }
            out
        }

        pub unsafe fn DebugMessageControl_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDebugMessageControl\0",
                &self.glDebugMessageControl_p,
            )
        }
        #[inline]

        pub fn DebugMessageControl_is_loaded(&self) -> bool {
            !self.glDebugMessageControl_p.load(RELAX).is_null()
        }
        /// [glDebugMessageInsert](http://docs.gl/gl4/glDebugMessageInsert)(source, type_, id, severity, length, buf)
        /// * `source` group: DebugSource
        /// * `type_` group: DebugType
        /// * `severity` group: DebugSeverity
        /// * `buf` len: COMPSIZE(buf,length)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DebugMessageInsert(
            &self,
            source: GLenum,
            type_: GLenum,
            id: GLuint,
            severity: GLenum,
            length: GLsizei,
            buf: *const GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DebugMessageInsert({:#X}, {:#X}, {:?}, {:#X}, {:?}, {:p});",
                    source,
                    type_,
                    id,
                    severity,
                    length,
                    buf
                );
            }
            let out = call_atomic_ptr_6arg(
                "glDebugMessageInsert",
                &self.glDebugMessageInsert_p,
                source,
                type_,
                id,
                severity,
                length,
                buf,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDebugMessageInsert");
            }
            out
        }

        pub unsafe fn DebugMessageInsert_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDebugMessageInsert\0",
                &self.glDebugMessageInsert_p,
            )
        }
        #[inline]

        pub fn DebugMessageInsert_is_loaded(&self) -> bool {
            !self.glDebugMessageInsert_p.load(RELAX).is_null()
        }
        /// [glDeleteBuffers](http://docs.gl/gl4/glDeleteBuffers)(n, buffers)
        /// * `buffers` len: n
        /// * `buffers` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteBuffers(&self, n: GLsizei, buffers: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DeleteBuffers({:?}, {:p});", n, buffers);
            }
            let out = call_atomic_ptr_2arg("glDeleteBuffers", &self.glDeleteBuffers_p, n, buffers);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteBuffers");
            }
            out
        }

        pub unsafe fn DeleteBuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDeleteBuffers\0",
                &self.glDeleteBuffers_p,
            )
        }
        #[inline]

        pub fn DeleteBuffers_is_loaded(&self) -> bool {
            !self.glDeleteBuffers_p.load(RELAX).is_null()
        }
        /// [glDeleteFramebuffers](http://docs.gl/gl4/glDeleteFramebuffers)(n, framebuffers)
        /// * `framebuffers` len: n
        /// * `framebuffers` class: framebuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteFramebuffers(&self, n: GLsizei, framebuffers: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DeleteFramebuffers({:?}, {:p});",
                    n,
                    framebuffers
                );
            }
            let out = call_atomic_ptr_2arg(
                "glDeleteFramebuffers",
                &self.glDeleteFramebuffers_p,
                n,
                framebuffers,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteFramebuffers");
            }
            out
        }

        pub unsafe fn DeleteFramebuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDeleteFramebuffers\0",
                &self.glDeleteFramebuffers_p,
            )
        }
        #[inline]

        pub fn DeleteFramebuffers_is_loaded(&self) -> bool {
            !self.glDeleteFramebuffers_p.load(RELAX).is_null()
        }
        /// [glDeleteProgram](http://docs.gl/gl4/glDeleteProgram)(program)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteProgram(&self, program: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DeleteProgram({:?});", program);
            }
            let out = call_atomic_ptr_1arg("glDeleteProgram", &self.glDeleteProgram_p, program);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteProgram");
            }
            out
        }

        pub unsafe fn DeleteProgram_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDeleteProgram\0",
                &self.glDeleteProgram_p,
            )
        }
        #[inline]

        pub fn DeleteProgram_is_loaded(&self) -> bool {
            !self.glDeleteProgram_p.load(RELAX).is_null()
        }
        /// [glDeleteProgramPipelines](http://docs.gl/gl4/glDeleteProgramPipelines)(n, pipelines)
        /// * `pipelines` len: n
        /// * `pipelines` class: program pipeline
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteProgramPipelines(&self, n: GLsizei, pipelines: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DeleteProgramPipelines({:?}, {:p});",
                    n,
                    pipelines
                );
            }
            let out = call_atomic_ptr_2arg(
                "glDeleteProgramPipelines",
                &self.glDeleteProgramPipelines_p,
                n,
                pipelines,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteProgramPipelines");
            }
            out
        }

        pub unsafe fn DeleteProgramPipelines_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDeleteProgramPipelines\0",
                &self.glDeleteProgramPipelines_p,
            )
        }
        #[inline]

        pub fn DeleteProgramPipelines_is_loaded(&self) -> bool {
            !self.glDeleteProgramPipelines_p.load(RELAX).is_null()
        }
        /// [glDeleteQueries](http://docs.gl/gl4/glDeleteQueries)(n, ids)
        /// * `ids` len: n
        /// * `ids` class: query
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteQueries(&self, n: GLsizei, ids: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DeleteQueries({:?}, {:p});", n, ids);
            }
            let out = call_atomic_ptr_2arg("glDeleteQueries", &self.glDeleteQueries_p, n, ids);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteQueries");
            }
            out
        }

        pub unsafe fn DeleteQueries_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDeleteQueries\0",
                &self.glDeleteQueries_p,
            )
        }
        #[inline]

        pub fn DeleteQueries_is_loaded(&self) -> bool {
            !self.glDeleteQueries_p.load(RELAX).is_null()
        }
        /// [glDeleteRenderbuffers](http://docs.gl/gl4/glDeleteRenderbuffers)(n, renderbuffers)
        /// * `renderbuffers` len: n
        /// * `renderbuffers` class: renderbuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteRenderbuffers(&self, n: GLsizei, renderbuffers: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DeleteRenderbuffers({:?}, {:p});",
                    n,
                    renderbuffers
                );
            }
            let out = call_atomic_ptr_2arg(
                "glDeleteRenderbuffers",
                &self.glDeleteRenderbuffers_p,
                n,
                renderbuffers,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteRenderbuffers");
            }
            out
        }

        pub unsafe fn DeleteRenderbuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDeleteRenderbuffers\0",
                &self.glDeleteRenderbuffers_p,
            )
        }
        #[inline]

        pub fn DeleteRenderbuffers_is_loaded(&self) -> bool {
            !self.glDeleteRenderbuffers_p.load(RELAX).is_null()
        }
        /// [glDeleteSamplers](http://docs.gl/gl4/glDeleteSamplers)(count, samplers)
        /// * `samplers` len: count
        /// * `samplers` class: sampler
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteSamplers(&self, count: GLsizei, samplers: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DeleteSamplers({:?}, {:p});", count, samplers);
            }
            let out = call_atomic_ptr_2arg(
                "glDeleteSamplers",
                &self.glDeleteSamplers_p,
                count,
                samplers,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteSamplers");
            }
            out
        }

        pub unsafe fn DeleteSamplers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDeleteSamplers\0",
                &self.glDeleteSamplers_p,
            )
        }
        #[inline]

        pub fn DeleteSamplers_is_loaded(&self) -> bool {
            !self.glDeleteSamplers_p.load(RELAX).is_null()
        }
        /// [glDeleteShader](http://docs.gl/gl4/glDeleteShader)(shader)
        /// * `shader` class: shader
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteShader(&self, shader: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DeleteShader({:?});", shader);
            }
            let out = call_atomic_ptr_1arg("glDeleteShader", &self.glDeleteShader_p, shader);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteShader");
            }
            out
        }

        pub unsafe fn DeleteShader_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDeleteShader\0",
                &self.glDeleteShader_p,
            )
        }
        #[inline]

        pub fn DeleteShader_is_loaded(&self) -> bool {
            !self.glDeleteShader_p.load(RELAX).is_null()
        }
        /// [glDeleteSync](http://docs.gl/gl4/glDeleteSync)(sync)
        /// * `sync` group: sync
        /// * `sync` class: sync
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteSync(&self, sync: GLsync) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DeleteSync({:p});", sync);
            }
            let out = call_atomic_ptr_1arg("glDeleteSync", &self.glDeleteSync_p, sync);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteSync");
            }
            out
        }

        pub unsafe fn DeleteSync_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glDeleteSync\0", &self.glDeleteSync_p)
        }
        #[inline]

        pub fn DeleteSync_is_loaded(&self) -> bool {
            !self.glDeleteSync_p.load(RELAX).is_null()
        }
        /// [glDeleteTextures](http://docs.gl/gl4/glDeleteTextures)(n, textures)
        /// * `textures` group: Texture
        /// * `textures` len: n
        /// * `textures` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteTextures(&self, n: GLsizei, textures: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DeleteTextures({:?}, {:p});", n, textures);
            }
            let out =
                call_atomic_ptr_2arg("glDeleteTextures", &self.glDeleteTextures_p, n, textures);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteTextures");
            }
            out
        }

        pub unsafe fn DeleteTextures_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDeleteTextures\0",
                &self.glDeleteTextures_p,
            )
        }
        #[inline]

        pub fn DeleteTextures_is_loaded(&self) -> bool {
            !self.glDeleteTextures_p.load(RELAX).is_null()
        }
        /// [glDeleteTransformFeedbacks](http://docs.gl/gl4/glDeleteTransformFeedbacks)(n, ids)
        /// * `ids` len: n
        /// * `ids` class: transform feedback
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteTransformFeedbacks(&self, n: GLsizei, ids: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DeleteTransformFeedbacks({:?}, {:p});", n, ids);
            }
            let out = call_atomic_ptr_2arg(
                "glDeleteTransformFeedbacks",
                &self.glDeleteTransformFeedbacks_p,
                n,
                ids,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteTransformFeedbacks");
            }
            out
        }

        pub unsafe fn DeleteTransformFeedbacks_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDeleteTransformFeedbacks\0",
                &self.glDeleteTransformFeedbacks_p,
            )
        }
        #[inline]

        pub fn DeleteTransformFeedbacks_is_loaded(&self) -> bool {
            !self.glDeleteTransformFeedbacks_p.load(RELAX).is_null()
        }
        /// [glDeleteVertexArrays](http://docs.gl/gl4/glDeleteVertexArrays)(n, arrays)
        /// * `arrays` len: n
        /// * `arrays` class: vertex array
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DeleteVertexArrays(&self, n: GLsizei, arrays: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DeleteVertexArrays({:?}, {:p});", n, arrays);
            }
            let out = call_atomic_ptr_2arg(
                "glDeleteVertexArrays",
                &self.glDeleteVertexArrays_p,
                n,
                arrays,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDeleteVertexArrays");
            }
            out
        }

        pub unsafe fn DeleteVertexArrays_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDeleteVertexArrays\0",
                &self.glDeleteVertexArrays_p,
            )
        }
        #[inline]

        pub fn DeleteVertexArrays_is_loaded(&self) -> bool {
            !self.glDeleteVertexArrays_p.load(RELAX).is_null()
        }
        /// [glDepthFunc](http://docs.gl/gl4/glDepthFunc)(func)
        /// * `func` group: DepthFunction
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DepthFunc(&self, func: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DepthFunc({:#X});", func);
            }
            let out = call_atomic_ptr_1arg("glDepthFunc", &self.glDepthFunc_p, func);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDepthFunc");
            }
            out
        }

        pub unsafe fn DepthFunc_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glDepthFunc\0", &self.glDepthFunc_p)
        }
        #[inline]

        pub fn DepthFunc_is_loaded(&self) -> bool {
            !self.glDepthFunc_p.load(RELAX).is_null()
        }
        /// [glDepthMask](http://docs.gl/gl4/glDepthMask)(flag)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DepthMask(&self, flag: GLboolean) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DepthMask({:?});", flag);
            }
            let out = call_atomic_ptr_1arg("glDepthMask", &self.glDepthMask_p, flag);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDepthMask");
            }
            out
        }

        pub unsafe fn DepthMask_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glDepthMask\0", &self.glDepthMask_p)
        }
        #[inline]

        pub fn DepthMask_is_loaded(&self) -> bool {
            !self.glDepthMask_p.load(RELAX).is_null()
        }
        /// [glDepthRange](http://docs.gl/gl4/glDepthRange)(n, f)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DepthRange(&self, n: GLdouble, f: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DepthRange({:?}, {:?});", n, f);
            }
            let out = call_atomic_ptr_2arg("glDepthRange", &self.glDepthRange_p, n, f);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDepthRange");
            }
            out
        }

        pub unsafe fn DepthRange_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glDepthRange\0", &self.glDepthRange_p)
        }
        #[inline]

        pub fn DepthRange_is_loaded(&self) -> bool {
            !self.glDepthRange_p.load(RELAX).is_null()
        }
        /// [glDepthRangeArrayv](http://docs.gl/gl4/glDepthRangeArrayv)(first, count, v)
        /// * `v` len: COMPSIZE(count)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DepthRangeArrayv(&self, first: GLuint, count: GLsizei, v: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DepthRangeArrayv({:?}, {:?}, {:p});",
                    first,
                    count,
                    v
                );
            }
            let out = call_atomic_ptr_3arg(
                "glDepthRangeArrayv",
                &self.glDepthRangeArrayv_p,
                first,
                count,
                v,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDepthRangeArrayv");
            }
            out
        }

        pub unsafe fn DepthRangeArrayv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDepthRangeArrayv\0",
                &self.glDepthRangeArrayv_p,
            )
        }
        #[inline]

        pub fn DepthRangeArrayv_is_loaded(&self) -> bool {
            !self.glDepthRangeArrayv_p.load(RELAX).is_null()
        }
        /// [glDepthRangeIndexed](http://docs.gl/gl4/glDepthRangeIndexed)(index, n, f)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DepthRangeIndexed(&self, index: GLuint, n: GLdouble, f: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DepthRangeIndexed({:?}, {:?}, {:?});",
                    index,
                    n,
                    f
                );
            }
            let out = call_atomic_ptr_3arg(
                "glDepthRangeIndexed",
                &self.glDepthRangeIndexed_p,
                index,
                n,
                f,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDepthRangeIndexed");
            }
            out
        }

        pub unsafe fn DepthRangeIndexed_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDepthRangeIndexed\0",
                &self.glDepthRangeIndexed_p,
            )
        }
        #[inline]

        pub fn DepthRangeIndexed_is_loaded(&self) -> bool {
            !self.glDepthRangeIndexed_p.load(RELAX).is_null()
        }
        /// [glDepthRangef](http://docs.gl/gl4/glDepthRange)(n, f)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DepthRangef(&self, n: GLfloat, f: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DepthRangef({:?}, {:?});", n, f);
            }
            let out = call_atomic_ptr_2arg("glDepthRangef", &self.glDepthRangef_p, n, f);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDepthRangef");
            }
            out
        }

        pub unsafe fn DepthRangef_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glDepthRangef\0", &self.glDepthRangef_p)
        }
        #[inline]

        pub fn DepthRangef_is_loaded(&self) -> bool {
            !self.glDepthRangef_p.load(RELAX).is_null()
        }
        /// [glDetachShader](http://docs.gl/gl4/glDetachShader)(program, shader)
        /// * `program` class: program
        /// * `shader` class: shader
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DetachShader(&self, program: GLuint, shader: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DetachShader({:?}, {:?});", program, shader);
            }
            let out =
                call_atomic_ptr_2arg("glDetachShader", &self.glDetachShader_p, program, shader);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDetachShader");
            }
            out
        }

        pub unsafe fn DetachShader_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDetachShader\0",
                &self.glDetachShader_p,
            )
        }
        #[inline]

        pub fn DetachShader_is_loaded(&self) -> bool {
            !self.glDetachShader_p.load(RELAX).is_null()
        }
        /// [glDisable](http://docs.gl/gl4/glDisable)(cap)
        /// * `cap` group: EnableCap
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Disable(&self, cap: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Disable({:#X});", cap);
            }
            let out = call_atomic_ptr_1arg("glDisable", &self.glDisable_p, cap);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDisable");
            }
            out
        }

        pub unsafe fn Disable_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glDisable\0", &self.glDisable_p)
        }
        #[inline]

        pub fn Disable_is_loaded(&self) -> bool {
            !self.glDisable_p.load(RELAX).is_null()
        }
        /// [glDisableVertexArrayAttrib](http://docs.gl/gl4/glDisableVertexArrayAttrib)(vaobj, index)
        /// * `vaobj` class: vertex array
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DisableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DisableVertexArrayAttrib({:?}, {:?});",
                    vaobj,
                    index
                );
            }
            let out = call_atomic_ptr_2arg(
                "glDisableVertexArrayAttrib",
                &self.glDisableVertexArrayAttrib_p,
                vaobj,
                index,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDisableVertexArrayAttrib");
            }
            out
        }

        pub unsafe fn DisableVertexArrayAttrib_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDisableVertexArrayAttrib\0",
                &self.glDisableVertexArrayAttrib_p,
            )
        }
        #[inline]

        pub fn DisableVertexArrayAttrib_is_loaded(&self) -> bool {
            !self.glDisableVertexArrayAttrib_p.load(RELAX).is_null()
        }
        /// [glDisableVertexAttribArray](http://docs.gl/gl4/glDisableVertexAttribArray)(index)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DisableVertexAttribArray(&self, index: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DisableVertexAttribArray({:?});", index);
            }
            let out = call_atomic_ptr_1arg(
                "glDisableVertexAttribArray",
                &self.glDisableVertexAttribArray_p,
                index,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDisableVertexAttribArray");
            }
            out
        }

        pub unsafe fn DisableVertexAttribArray_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDisableVertexAttribArray\0",
                &self.glDisableVertexAttribArray_p,
            )
        }
        #[inline]

        pub fn DisableVertexAttribArray_is_loaded(&self) -> bool {
            !self.glDisableVertexAttribArray_p.load(RELAX).is_null()
        }
        /// [glDisablei](http://docs.gl/gl4/glDisable)(target, index)
        /// * `target` group: EnableCap
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Disablei(&self, target: GLenum, index: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Disablei({:#X}, {:?});", target, index);
            }
            let out = call_atomic_ptr_2arg("glDisablei", &self.glDisablei_p, target, index);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDisablei");
            }
            out
        }

        pub unsafe fn Disablei_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glDisablei\0", &self.glDisablei_p)
        }
        #[inline]

        pub fn Disablei_is_loaded(&self) -> bool {
            !self.glDisablei_p.load(RELAX).is_null()
        }
        /// [glDispatchCompute](http://docs.gl/gl4/glDispatchCompute)(num_groups_x, num_groups_y, num_groups_z)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DispatchCompute(
            &self,
            num_groups_x: GLuint,
            num_groups_y: GLuint,
            num_groups_z: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DispatchCompute({:?}, {:?}, {:?});",
                    num_groups_x,
                    num_groups_y,
                    num_groups_z
                );
            }
            let out = call_atomic_ptr_3arg(
                "glDispatchCompute",
                &self.glDispatchCompute_p,
                num_groups_x,
                num_groups_y,
                num_groups_z,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDispatchCompute");
            }
            out
        }

        pub unsafe fn DispatchCompute_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDispatchCompute\0",
                &self.glDispatchCompute_p,
            )
        }
        #[inline]

        pub fn DispatchCompute_is_loaded(&self) -> bool {
            !self.glDispatchCompute_p.load(RELAX).is_null()
        }
        /// [glDispatchComputeIndirect](http://docs.gl/gl4/glDispatchComputeIndirect)(indirect)
        /// * `indirect` group: BufferOffset
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DispatchComputeIndirect(&self, indirect: GLintptr) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DispatchComputeIndirect({:?});", indirect);
            }
            let out = call_atomic_ptr_1arg(
                "glDispatchComputeIndirect",
                &self.glDispatchComputeIndirect_p,
                indirect,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDispatchComputeIndirect");
            }
            out
        }

        pub unsafe fn DispatchComputeIndirect_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDispatchComputeIndirect\0",
                &self.glDispatchComputeIndirect_p,
            )
        }
        #[inline]

        pub fn DispatchComputeIndirect_is_loaded(&self) -> bool {
            !self.glDispatchComputeIndirect_p.load(RELAX).is_null()
        }
        /// [glDrawArrays](http://docs.gl/gl4/glDrawArrays)(mode, first, count)
        /// * `mode` group: PrimitiveType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawArrays(&self, mode: GLenum, first: GLint, count: GLsizei) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawArrays({:#X}, {:?}, {:?});",
                    mode,
                    first,
                    count
                );
            }
            let out =
                call_atomic_ptr_3arg("glDrawArrays", &self.glDrawArrays_p, mode, first, count);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawArrays");
            }
            out
        }

        pub unsafe fn DrawArrays_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glDrawArrays\0", &self.glDrawArrays_p)
        }
        #[inline]

        pub fn DrawArrays_is_loaded(&self) -> bool {
            !self.glDrawArrays_p.load(RELAX).is_null()
        }
        /// [glDrawArraysIndirect](http://docs.gl/gl4/glDrawArraysIndirect)(mode, indirect)
        /// * `mode` group: PrimitiveType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawArraysIndirect({:#X}, {:p});",
                    mode,
                    indirect
                );
            }
            let out = call_atomic_ptr_2arg(
                "glDrawArraysIndirect",
                &self.glDrawArraysIndirect_p,
                mode,
                indirect,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawArraysIndirect");
            }
            out
        }

        pub unsafe fn DrawArraysIndirect_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawArraysIndirect\0",
                &self.glDrawArraysIndirect_p,
            )
        }
        #[inline]

        pub fn DrawArraysIndirect_is_loaded(&self) -> bool {
            !self.glDrawArraysIndirect_p.load(RELAX).is_null()
        }
        /// [glDrawArraysInstanced](http://docs.gl/gl4/glDrawArraysInstanced)(mode, first, count, instancecount)
        /// * `mode` group: PrimitiveType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawArraysInstanced(
            &self,
            mode: GLenum,
            first: GLint,
            count: GLsizei,
            instancecount: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawArraysInstanced({:#X}, {:?}, {:?}, {:?});",
                    mode,
                    first,
                    count,
                    instancecount
                );
            }
            let out = call_atomic_ptr_4arg(
                "glDrawArraysInstanced",
                &self.glDrawArraysInstanced_p,
                mode,
                first,
                count,
                instancecount,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawArraysInstanced");
            }
            out
        }

        pub unsafe fn DrawArraysInstanced_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawArraysInstanced\0",
                &self.glDrawArraysInstanced_p,
            )
        }
        #[inline]

        pub fn DrawArraysInstanced_is_loaded(&self) -> bool {
            !self.glDrawArraysInstanced_p.load(RELAX).is_null()
        }
        /// [glDrawArraysInstancedBaseInstance](http://docs.gl/gl4/glDrawArraysInstancedBaseInstance)(mode, first, count, instancecount, baseinstance)
        /// * `mode` group: PrimitiveType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawArraysInstancedBaseInstance(
            &self,
            mode: GLenum,
            first: GLint,
            count: GLsizei,
            instancecount: GLsizei,
            baseinstance: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawArraysInstancedBaseInstance({:#X}, {:?}, {:?}, {:?}, {:?});",
                    mode,
                    first,
                    count,
                    instancecount,
                    baseinstance
                );
            }
            let out = call_atomic_ptr_5arg(
                "glDrawArraysInstancedBaseInstance",
                &self.glDrawArraysInstancedBaseInstance_p,
                mode,
                first,
                count,
                instancecount,
                baseinstance,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawArraysInstancedBaseInstance");
            }
            out
        }

        pub unsafe fn DrawArraysInstancedBaseInstance_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawArraysInstancedBaseInstance\0",
                &self.glDrawArraysInstancedBaseInstance_p,
            )
        }
        #[inline]

        pub fn DrawArraysInstancedBaseInstance_is_loaded(&self) -> bool {
            !self
                .glDrawArraysInstancedBaseInstance_p
                .load(RELAX)
                .is_null()
        }
        /// [glDrawBuffer](http://docs.gl/gl4/glDrawBuffer)(buf)
        /// * `buf` group: DrawBufferMode
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawBuffer(&self, buf: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DrawBuffer({:#X});", buf);
            }
            let out = call_atomic_ptr_1arg("glDrawBuffer", &self.glDrawBuffer_p, buf);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawBuffer");
            }
            out
        }

        pub unsafe fn DrawBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glDrawBuffer\0", &self.glDrawBuffer_p)
        }
        #[inline]

        pub fn DrawBuffer_is_loaded(&self) -> bool {
            !self.glDrawBuffer_p.load(RELAX).is_null()
        }
        /// [glDrawBuffers](http://docs.gl/gl4/glDrawBuffers)(n, bufs)
        /// * `bufs` group: DrawBufferMode
        /// * `bufs` len: n
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawBuffers(&self, n: GLsizei, bufs: *const GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DrawBuffers({:?}, {:p});", n, bufs);
            }
            let out = call_atomic_ptr_2arg("glDrawBuffers", &self.glDrawBuffers_p, n, bufs);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawBuffers");
            }
            out
        }

        pub unsafe fn DrawBuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glDrawBuffers\0", &self.glDrawBuffers_p)
        }
        #[inline]

        pub fn DrawBuffers_is_loaded(&self) -> bool {
            !self.glDrawBuffers_p.load(RELAX).is_null()
        }
        /// [glDrawElements](http://docs.gl/gl4/glDrawElements)(mode, count, type_, indices)
        /// * `mode` group: PrimitiveType
        /// * `type_` group: DrawElementsType
        /// * `indices` len: COMPSIZE(count,type)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawElements(
            &self,
            mode: GLenum,
            count: GLsizei,
            type_: GLenum,
            indices: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawElements({:#X}, {:?}, {:#X}, {:p});",
                    mode,
                    count,
                    type_,
                    indices
                );
            }
            let out = call_atomic_ptr_4arg(
                "glDrawElements",
                &self.glDrawElements_p,
                mode,
                count,
                type_,
                indices,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawElements");
            }
            out
        }

        pub unsafe fn DrawElements_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawElements\0",
                &self.glDrawElements_p,
            )
        }
        #[inline]

        pub fn DrawElements_is_loaded(&self) -> bool {
            !self.glDrawElements_p.load(RELAX).is_null()
        }
        /// [glDrawElementsBaseVertex](http://docs.gl/gl4/glDrawElementsBaseVertex)(mode, count, type_, indices, basevertex)
        /// * `mode` group: PrimitiveType
        /// * `type_` group: DrawElementsType
        /// * `indices` len: COMPSIZE(count,type)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawElementsBaseVertex(
            &self,
            mode: GLenum,
            count: GLsizei,
            type_: GLenum,
            indices: *const c_void,
            basevertex: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawElementsBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?});",
                    mode,
                    count,
                    type_,
                    indices,
                    basevertex
                );
            }
            let out = call_atomic_ptr_5arg(
                "glDrawElementsBaseVertex",
                &self.glDrawElementsBaseVertex_p,
                mode,
                count,
                type_,
                indices,
                basevertex,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawElementsBaseVertex");
            }
            out
        }

        pub unsafe fn DrawElementsBaseVertex_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawElementsBaseVertex\0",
                &self.glDrawElementsBaseVertex_p,
            )
        }
        #[inline]

        pub fn DrawElementsBaseVertex_is_loaded(&self) -> bool {
            !self.glDrawElementsBaseVertex_p.load(RELAX).is_null()
        }
        /// [glDrawElementsIndirect](http://docs.gl/gl4/glDrawElementsIndirect)(mode, type_, indirect)
        /// * `mode` group: PrimitiveType
        /// * `type_` group: DrawElementsType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawElementsIndirect(
            &self,
            mode: GLenum,
            type_: GLenum,
            indirect: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawElementsIndirect({:#X}, {:#X}, {:p});",
                    mode,
                    type_,
                    indirect
                );
            }
            let out = call_atomic_ptr_3arg(
                "glDrawElementsIndirect",
                &self.glDrawElementsIndirect_p,
                mode,
                type_,
                indirect,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawElementsIndirect");
            }
            out
        }

        pub unsafe fn DrawElementsIndirect_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawElementsIndirect\0",
                &self.glDrawElementsIndirect_p,
            )
        }
        #[inline]

        pub fn DrawElementsIndirect_is_loaded(&self) -> bool {
            !self.glDrawElementsIndirect_p.load(RELAX).is_null()
        }
        /// [glDrawElementsInstanced](http://docs.gl/gl4/glDrawElementsInstanced)(mode, count, type_, indices, instancecount)
        /// * `mode` group: PrimitiveType
        /// * `type_` group: DrawElementsType
        /// * `indices` len: COMPSIZE(count,type)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawElementsInstanced(
            &self,
            mode: GLenum,
            count: GLsizei,
            type_: GLenum,
            indices: *const c_void,
            instancecount: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawElementsInstanced({:#X}, {:?}, {:#X}, {:p}, {:?});",
                    mode,
                    count,
                    type_,
                    indices,
                    instancecount
                );
            }
            let out = call_atomic_ptr_5arg(
                "glDrawElementsInstanced",
                &self.glDrawElementsInstanced_p,
                mode,
                count,
                type_,
                indices,
                instancecount,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawElementsInstanced");
            }
            out
        }

        pub unsafe fn DrawElementsInstanced_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawElementsInstanced\0",
                &self.glDrawElementsInstanced_p,
            )
        }
        #[inline]

        pub fn DrawElementsInstanced_is_loaded(&self) -> bool {
            !self.glDrawElementsInstanced_p.load(RELAX).is_null()
        }
        /// [glDrawElementsInstancedBaseInstance](http://docs.gl/gl4/glDrawElementsInstancedBaseInstance)(mode, count, type_, indices, instancecount, baseinstance)
        /// * `mode` group: PrimitiveType
        /// * `type_` group: PrimitiveType
        /// * `indices` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawElementsInstancedBaseInstance(
            &self,
            mode: GLenum,
            count: GLsizei,
            type_: GLenum,
            indices: *const c_void,
            instancecount: GLsizei,
            baseinstance: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DrawElementsInstancedBaseInstance({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});", mode, count, type_, indices, instancecount, baseinstance);
            }
            let out = call_atomic_ptr_6arg(
                "glDrawElementsInstancedBaseInstance",
                &self.glDrawElementsInstancedBaseInstance_p,
                mode,
                count,
                type_,
                indices,
                instancecount,
                baseinstance,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawElementsInstancedBaseInstance");
            }
            out
        }

        pub unsafe fn DrawElementsInstancedBaseInstance_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawElementsInstancedBaseInstance\0",
                &self.glDrawElementsInstancedBaseInstance_p,
            )
        }
        #[inline]

        pub fn DrawElementsInstancedBaseInstance_is_loaded(&self) -> bool {
            !self
                .glDrawElementsInstancedBaseInstance_p
                .load(RELAX)
                .is_null()
        }
        /// [glDrawElementsInstancedBaseVertex](http://docs.gl/gl4/glDrawElementsInstancedBaseVertex)(mode, count, type_, indices, instancecount, basevertex)
        /// * `mode` group: PrimitiveType
        /// * `type_` group: DrawElementsType
        /// * `indices` len: COMPSIZE(count,type)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawElementsInstancedBaseVertex(
            &self,
            mode: GLenum,
            count: GLsizei,
            type_: GLenum,
            indices: *const c_void,
            instancecount: GLsizei,
            basevertex: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DrawElementsInstancedBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});", mode, count, type_, indices, instancecount, basevertex);
            }
            let out = call_atomic_ptr_6arg(
                "glDrawElementsInstancedBaseVertex",
                &self.glDrawElementsInstancedBaseVertex_p,
                mode,
                count,
                type_,
                indices,
                instancecount,
                basevertex,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawElementsInstancedBaseVertex");
            }
            out
        }

        pub unsafe fn DrawElementsInstancedBaseVertex_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawElementsInstancedBaseVertex\0",
                &self.glDrawElementsInstancedBaseVertex_p,
            )
        }
        #[inline]

        pub fn DrawElementsInstancedBaseVertex_is_loaded(&self) -> bool {
            !self
                .glDrawElementsInstancedBaseVertex_p
                .load(RELAX)
                .is_null()
        }
        /// [glDrawElementsInstancedBaseVertexBaseInstance](http://docs.gl/gl4/glDrawElementsInstancedBaseVertexBaseInstance)(mode, count, type_, indices, instancecount, basevertex, baseinstance)
        /// * `mode` group: PrimitiveType
        /// * `type_` group: DrawElementsType
        /// * `indices` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawElementsInstancedBaseVertexBaseInstance(
            &self,
            mode: GLenum,
            count: GLsizei,
            type_: GLenum,
            indices: *const c_void,
            instancecount: GLsizei,
            basevertex: GLint,
            baseinstance: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DrawElementsInstancedBaseVertexBaseInstance({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?}, {:?});", mode, count, type_, indices, instancecount, basevertex, baseinstance);
            }
            let out = call_atomic_ptr_7arg(
                "glDrawElementsInstancedBaseVertexBaseInstance",
                &self.glDrawElementsInstancedBaseVertexBaseInstance_p,
                mode,
                count,
                type_,
                indices,
                instancecount,
                basevertex,
                baseinstance,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawElementsInstancedBaseVertexBaseInstance");
            }
            out
        }

        pub unsafe fn DrawElementsInstancedBaseVertexBaseInstance_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawElementsInstancedBaseVertexBaseInstance\0",
                &self.glDrawElementsInstancedBaseVertexBaseInstance_p,
            )
        }
        #[inline]

        pub fn DrawElementsInstancedBaseVertexBaseInstance_is_loaded(&self) -> bool {
            !self
                .glDrawElementsInstancedBaseVertexBaseInstance_p
                .load(RELAX)
                .is_null()
        }
        /// [glDrawRangeElements](http://docs.gl/gl4/glDrawRangeElements)(mode, start, end, count, type_, indices)
        /// * `mode` group: PrimitiveType
        /// * `type_` group: DrawElementsType
        /// * `indices` len: COMPSIZE(count,type)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawRangeElements(
            &self,
            mode: GLenum,
            start: GLuint,
            end: GLuint,
            count: GLsizei,
            type_: GLenum,
            indices: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawRangeElements({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p});",
                    mode,
                    start,
                    end,
                    count,
                    type_,
                    indices
                );
            }
            let out = call_atomic_ptr_6arg(
                "glDrawRangeElements",
                &self.glDrawRangeElements_p,
                mode,
                start,
                end,
                count,
                type_,
                indices,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawRangeElements");
            }
            out
        }

        pub unsafe fn DrawRangeElements_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawRangeElements\0",
                &self.glDrawRangeElements_p,
            )
        }
        #[inline]

        pub fn DrawRangeElements_is_loaded(&self) -> bool {
            !self.glDrawRangeElements_p.load(RELAX).is_null()
        }
        /// [glDrawRangeElementsBaseVertex](http://docs.gl/gl4/glDrawRangeElementsBaseVertex)(mode, start, end, count, type_, indices, basevertex)
        /// * `mode` group: PrimitiveType
        /// * `type_` group: DrawElementsType
        /// * `indices` len: COMPSIZE(count,type)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawRangeElementsBaseVertex(
            &self,
            mode: GLenum,
            start: GLuint,
            end: GLuint,
            count: GLsizei,
            type_: GLenum,
            indices: *const c_void,
            basevertex: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DrawRangeElementsBaseVertex({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p}, {:?});", mode, start, end, count, type_, indices, basevertex);
            }
            let out = call_atomic_ptr_7arg(
                "glDrawRangeElementsBaseVertex",
                &self.glDrawRangeElementsBaseVertex_p,
                mode,
                start,
                end,
                count,
                type_,
                indices,
                basevertex,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawRangeElementsBaseVertex");
            }
            out
        }

        pub unsafe fn DrawRangeElementsBaseVertex_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawRangeElementsBaseVertex\0",
                &self.glDrawRangeElementsBaseVertex_p,
            )
        }
        #[inline]

        pub fn DrawRangeElementsBaseVertex_is_loaded(&self) -> bool {
            !self.glDrawRangeElementsBaseVertex_p.load(RELAX).is_null()
        }
        /// [glDrawTransformFeedback](http://docs.gl/gl4/glDrawTransformFeedback)(mode, id)
        /// * `mode` group: PrimitiveType
        /// * `id` class: transform feedback
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawTransformFeedback(&self, mode: GLenum, id: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.DrawTransformFeedback({:#X}, {:?});", mode, id);
            }
            let out = call_atomic_ptr_2arg(
                "glDrawTransformFeedback",
                &self.glDrawTransformFeedback_p,
                mode,
                id,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawTransformFeedback");
            }
            out
        }

        pub unsafe fn DrawTransformFeedback_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawTransformFeedback\0",
                &self.glDrawTransformFeedback_p,
            )
        }
        #[inline]

        pub fn DrawTransformFeedback_is_loaded(&self) -> bool {
            !self.glDrawTransformFeedback_p.load(RELAX).is_null()
        }
        /// [glDrawTransformFeedbackInstanced](http://docs.gl/gl4/glDrawTransformFeedbackInstanced)(mode, id, instancecount)
        /// * `mode` group: PrimitiveType
        /// * `id` class: transform feedback
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawTransformFeedbackInstanced(
            &self,
            mode: GLenum,
            id: GLuint,
            instancecount: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawTransformFeedbackInstanced({:#X}, {:?}, {:?});",
                    mode,
                    id,
                    instancecount
                );
            }
            let out = call_atomic_ptr_3arg(
                "glDrawTransformFeedbackInstanced",
                &self.glDrawTransformFeedbackInstanced_p,
                mode,
                id,
                instancecount,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawTransformFeedbackInstanced");
            }
            out
        }

        pub unsafe fn DrawTransformFeedbackInstanced_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawTransformFeedbackInstanced\0",
                &self.glDrawTransformFeedbackInstanced_p,
            )
        }
        #[inline]

        pub fn DrawTransformFeedbackInstanced_is_loaded(&self) -> bool {
            !self
                .glDrawTransformFeedbackInstanced_p
                .load(RELAX)
                .is_null()
        }
        /// [glDrawTransformFeedbackStream](http://docs.gl/gl4/glDrawTransformFeedbackStream)(mode, id, stream)
        /// * `mode` group: PrimitiveType
        /// * `id` class: transform feedback
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawTransformFeedbackStream(&self, mode: GLenum, id: GLuint, stream: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawTransformFeedbackStream({:#X}, {:?}, {:?});",
                    mode,
                    id,
                    stream
                );
            }
            let out = call_atomic_ptr_3arg(
                "glDrawTransformFeedbackStream",
                &self.glDrawTransformFeedbackStream_p,
                mode,
                id,
                stream,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawTransformFeedbackStream");
            }
            out
        }

        pub unsafe fn DrawTransformFeedbackStream_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawTransformFeedbackStream\0",
                &self.glDrawTransformFeedbackStream_p,
            )
        }
        #[inline]

        pub fn DrawTransformFeedbackStream_is_loaded(&self) -> bool {
            !self.glDrawTransformFeedbackStream_p.load(RELAX).is_null()
        }
        /// [glDrawTransformFeedbackStreamInstanced](http://docs.gl/gl4/glDrawTransformFeedbackStreamInstanced)(mode, id, stream, instancecount)
        /// * `mode` group: PrimitiveType
        /// * `id` class: transform feedback
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn DrawTransformFeedbackStreamInstanced(
            &self,
            mode: GLenum,
            id: GLuint,
            stream: GLuint,
            instancecount: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.DrawTransformFeedbackStreamInstanced({:#X}, {:?}, {:?}, {:?});",
                    mode,
                    id,
                    stream,
                    instancecount
                );
            }
            let out = call_atomic_ptr_4arg(
                "glDrawTransformFeedbackStreamInstanced",
                &self.glDrawTransformFeedbackStreamInstanced_p,
                mode,
                id,
                stream,
                instancecount,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glDrawTransformFeedbackStreamInstanced");
            }
            out
        }

        pub unsafe fn DrawTransformFeedbackStreamInstanced_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glDrawTransformFeedbackStreamInstanced\0",
                &self.glDrawTransformFeedbackStreamInstanced_p,
            )
        }
        #[inline]

        pub fn DrawTransformFeedbackStreamInstanced_is_loaded(&self) -> bool {
            !self
                .glDrawTransformFeedbackStreamInstanced_p
                .load(RELAX)
                .is_null()
        }
        /// [glEnable](http://docs.gl/gl4/glEnable)(cap)
        /// * `cap` group: EnableCap
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Enable(&self, cap: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Enable({:#X});", cap);
            }
            let out = call_atomic_ptr_1arg("glEnable", &self.glEnable_p, cap);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glEnable");
            }
            out
        }

        pub unsafe fn Enable_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glEnable\0", &self.glEnable_p)
        }
        #[inline]

        pub fn Enable_is_loaded(&self) -> bool {
            !self.glEnable_p.load(RELAX).is_null()
        }
        /// [glEnableVertexArrayAttrib](http://docs.gl/gl4/glEnableVertexArrayAttrib)(vaobj, index)
        /// * `vaobj` class: vertex array
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn EnableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.EnableVertexArrayAttrib({:?}, {:?});",
                    vaobj,
                    index
                );
            }
            let out = call_atomic_ptr_2arg(
                "glEnableVertexArrayAttrib",
                &self.glEnableVertexArrayAttrib_p,
                vaobj,
                index,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glEnableVertexArrayAttrib");
            }
            out
        }

        pub unsafe fn EnableVertexArrayAttrib_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glEnableVertexArrayAttrib\0",
                &self.glEnableVertexArrayAttrib_p,
            )
        }
        #[inline]

        pub fn EnableVertexArrayAttrib_is_loaded(&self) -> bool {
            !self.glEnableVertexArrayAttrib_p.load(RELAX).is_null()
        }
        /// [glEnableVertexAttribArray](http://docs.gl/gl4/glEnableVertexAttribArray)(index)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn EnableVertexAttribArray(&self, index: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.EnableVertexAttribArray({:?});", index);
            }
            let out = call_atomic_ptr_1arg(
                "glEnableVertexAttribArray",
                &self.glEnableVertexAttribArray_p,
                index,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glEnableVertexAttribArray");
            }
            out
        }

        pub unsafe fn EnableVertexAttribArray_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glEnableVertexAttribArray\0",
                &self.glEnableVertexAttribArray_p,
            )
        }
        #[inline]

        pub fn EnableVertexAttribArray_is_loaded(&self) -> bool {
            !self.glEnableVertexAttribArray_p.load(RELAX).is_null()
        }
        /// [glEnablei](http://docs.gl/gl4/glEnable)(target, index)
        /// * `target` group: EnableCap
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Enablei(&self, target: GLenum, index: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Enablei({:#X}, {:?});", target, index);
            }
            let out = call_atomic_ptr_2arg("glEnablei", &self.glEnablei_p, target, index);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glEnablei");
            }
            out
        }

        pub unsafe fn Enablei_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glEnablei\0", &self.glEnablei_p)
        }
        #[inline]

        pub fn Enablei_is_loaded(&self) -> bool {
            !self.glEnablei_p.load(RELAX).is_null()
        }
        /// [glEndConditionalRender](http://docs.gl/gl4/glEndConditionalRender)()
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn EndConditionalRender(&self) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.EndConditionalRender();",);
            }
            let out =
                call_atomic_ptr_0arg("glEndConditionalRender", &self.glEndConditionalRender_p);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glEndConditionalRender");
            }
            out
        }

        pub unsafe fn EndConditionalRender_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glEndConditionalRender\0",
                &self.glEndConditionalRender_p,
            )
        }
        #[inline]

        pub fn EndConditionalRender_is_loaded(&self) -> bool {
            !self.glEndConditionalRender_p.load(RELAX).is_null()
        }
        /// [glEndQuery](http://docs.gl/gl4/glEndQuery)(target)
        /// * `target` group: QueryTarget
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn EndQuery(&self, target: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.EndQuery({:#X});", target);
            }
            let out = call_atomic_ptr_1arg("glEndQuery", &self.glEndQuery_p, target);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glEndQuery");
            }
            out
        }

        pub unsafe fn EndQuery_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glEndQuery\0", &self.glEndQuery_p)
        }
        #[inline]

        pub fn EndQuery_is_loaded(&self) -> bool {
            !self.glEndQuery_p.load(RELAX).is_null()
        }
        /// [glEndQueryIndexed](http://docs.gl/gl4/glEndQueryIndexed)(target, index)
        /// * `target` group: QueryTarget
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn EndQueryIndexed(&self, target: GLenum, index: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.EndQueryIndexed({:#X}, {:?});", target, index);
            }
            let out = call_atomic_ptr_2arg(
                "glEndQueryIndexed",
                &self.glEndQueryIndexed_p,
                target,
                index,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glEndQueryIndexed");
            }
            out
        }

        pub unsafe fn EndQueryIndexed_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glEndQueryIndexed\0",
                &self.glEndQueryIndexed_p,
            )
        }
        #[inline]

        pub fn EndQueryIndexed_is_loaded(&self) -> bool {
            !self.glEndQueryIndexed_p.load(RELAX).is_null()
        }
        /// [glEndTransformFeedback](http://docs.gl/gl4/glEndTransformFeedback)()
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn EndTransformFeedback(&self) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.EndTransformFeedback();",);
            }
            let out =
                call_atomic_ptr_0arg("glEndTransformFeedback", &self.glEndTransformFeedback_p);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glEndTransformFeedback");
            }
            out
        }

        pub unsafe fn EndTransformFeedback_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glEndTransformFeedback\0",
                &self.glEndTransformFeedback_p,
            )
        }
        #[inline]

        pub fn EndTransformFeedback_is_loaded(&self) -> bool {
            !self.glEndTransformFeedback_p.load(RELAX).is_null()
        }
        /// [glFenceSync](http://docs.gl/gl4/glFenceSync)(condition, flags)
        /// * `condition` group: SyncCondition
        /// * `flags` group: SyncBehaviorFlags
        /// * return value group: sync
        /// * return value class: sync
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn FenceSync(&self, condition: GLenum, flags: GLbitfield) -> GLsync {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.FenceSync({:#X}, {:?});", condition, flags);
            }
            let out = call_atomic_ptr_2arg("glFenceSync", &self.glFenceSync_p, condition, flags);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFenceSync");
            }
            out
        }

        pub unsafe fn FenceSync_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glFenceSync\0", &self.glFenceSync_p)
        }
        #[inline]

        pub fn FenceSync_is_loaded(&self) -> bool {
            !self.glFenceSync_p.load(RELAX).is_null()
        }
        /// [glFinish](http://docs.gl/gl4/glFinish)()
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Finish(&self) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Finish();",);
            }
            let out = call_atomic_ptr_0arg("glFinish", &self.glFinish_p);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFinish");
            }
            out
        }

        pub unsafe fn Finish_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glFinish\0", &self.glFinish_p)
        }
        #[inline]

        pub fn Finish_is_loaded(&self) -> bool {
            !self.glFinish_p.load(RELAX).is_null()
        }
        /// [glFlush](http://docs.gl/gl4/glFlush)()
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Flush(&self) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Flush();",);
            }
            let out = call_atomic_ptr_0arg("glFlush", &self.glFlush_p);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFlush");
            }
            out
        }

        pub unsafe fn Flush_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glFlush\0", &self.glFlush_p)
        }
        #[inline]

        pub fn Flush_is_loaded(&self) -> bool {
            !self.glFlush_p.load(RELAX).is_null()
        }
        /// [glFlushMappedBufferRange](http://docs.gl/gl4/glFlushMappedBufferRange)(target, offset, length)
        /// * `target` group: BufferTargetARB
        /// * `offset` group: BufferOffset
        /// * `length` group: BufferSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn FlushMappedBufferRange(
            &self,
            target: GLenum,
            offset: GLintptr,
            length: GLsizeiptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.FlushMappedBufferRange({:#X}, {:?}, {:?});",
                    target,
                    offset,
                    length
                );
            }
            let out = call_atomic_ptr_3arg(
                "glFlushMappedBufferRange",
                &self.glFlushMappedBufferRange_p,
                target,
                offset,
                length,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFlushMappedBufferRange");
            }
            out
        }

        pub unsafe fn FlushMappedBufferRange_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glFlushMappedBufferRange\0",
                &self.glFlushMappedBufferRange_p,
            )
        }
        #[inline]

        pub fn FlushMappedBufferRange_is_loaded(&self) -> bool {
            !self.glFlushMappedBufferRange_p.load(RELAX).is_null()
        }
        /// [glFlushMappedNamedBufferRange](http://docs.gl/gl4/glFlushMappedNamedBufferRange)(buffer, offset, length)
        /// * `buffer` class: buffer
        /// * `length` group: BufferSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn FlushMappedNamedBufferRange(
            &self,
            buffer: GLuint,
            offset: GLintptr,
            length: GLsizeiptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.FlushMappedNamedBufferRange({:?}, {:?}, {:?});",
                    buffer,
                    offset,
                    length
                );
            }
            let out = call_atomic_ptr_3arg(
                "glFlushMappedNamedBufferRange",
                &self.glFlushMappedNamedBufferRange_p,
                buffer,
                offset,
                length,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFlushMappedNamedBufferRange");
            }
            out
        }

        pub unsafe fn FlushMappedNamedBufferRange_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glFlushMappedNamedBufferRange\0",
                &self.glFlushMappedNamedBufferRange_p,
            )
        }
        #[inline]

        pub fn FlushMappedNamedBufferRange_is_loaded(&self) -> bool {
            !self.glFlushMappedNamedBufferRange_p.load(RELAX).is_null()
        }
        /// [glFramebufferParameteri](http://docs.gl/gl4/glFramebufferParameter)(target, pname, param)
        /// * `target` group: FramebufferTarget
        /// * `pname` group: FramebufferParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn FramebufferParameteri(&self, target: GLenum, pname: GLenum, param: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.FramebufferParameteri({:#X}, {:#X}, {:?});",
                    target,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glFramebufferParameteri",
                &self.glFramebufferParameteri_p,
                target,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFramebufferParameteri");
            }
            out
        }

        pub unsafe fn FramebufferParameteri_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glFramebufferParameteri\0",
                &self.glFramebufferParameteri_p,
            )
        }
        #[inline]

        pub fn FramebufferParameteri_is_loaded(&self) -> bool {
            !self.glFramebufferParameteri_p.load(RELAX).is_null()
        }
        /// [glFramebufferRenderbuffer](http://docs.gl/gl4/glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer)
        /// * `target` group: FramebufferTarget
        /// * `attachment` group: FramebufferAttachment
        /// * `renderbuffertarget` group: RenderbufferTarget
        /// * `renderbuffer` class: renderbuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn FramebufferRenderbuffer(
            &self,
            target: GLenum,
            attachment: GLenum,
            renderbuffertarget: GLenum,
            renderbuffer: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.FramebufferRenderbuffer({:#X}, {:#X}, {:#X}, {:?});",
                    target,
                    attachment,
                    renderbuffertarget,
                    renderbuffer
                );
            }
            let out = call_atomic_ptr_4arg(
                "glFramebufferRenderbuffer",
                &self.glFramebufferRenderbuffer_p,
                target,
                attachment,
                renderbuffertarget,
                renderbuffer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFramebufferRenderbuffer");
            }
            out
        }

        pub unsafe fn FramebufferRenderbuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glFramebufferRenderbuffer\0",
                &self.glFramebufferRenderbuffer_p,
            )
        }
        #[inline]

        pub fn FramebufferRenderbuffer_is_loaded(&self) -> bool {
            !self.glFramebufferRenderbuffer_p.load(RELAX).is_null()
        }
        /// [glFramebufferTexture](http://docs.gl/gl4/glFramebufferTexture)(target, attachment, texture, level)
        /// * `target` group: FramebufferTarget
        /// * `attachment` group: FramebufferAttachment
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn FramebufferTexture(
            &self,
            target: GLenum,
            attachment: GLenum,
            texture: GLuint,
            level: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.FramebufferTexture({:#X}, {:#X}, {:?}, {:?});",
                    target,
                    attachment,
                    texture,
                    level
                );
            }
            let out = call_atomic_ptr_4arg(
                "glFramebufferTexture",
                &self.glFramebufferTexture_p,
                target,
                attachment,
                texture,
                level,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFramebufferTexture");
            }
            out
        }

        pub unsafe fn FramebufferTexture_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glFramebufferTexture\0",
                &self.glFramebufferTexture_p,
            )
        }
        #[inline]

        pub fn FramebufferTexture_is_loaded(&self) -> bool {
            !self.glFramebufferTexture_p.load(RELAX).is_null()
        }
        /// [glFramebufferTexture1D](http://docs.gl/gl4/glFramebufferTexture1D)(target, attachment, textarget, texture, level)
        /// * `target` group: FramebufferTarget
        /// * `attachment` group: FramebufferAttachment
        /// * `textarget` group: TextureTarget
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn FramebufferTexture1D(
            &self,
            target: GLenum,
            attachment: GLenum,
            textarget: GLenum,
            texture: GLuint,
            level: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.FramebufferTexture1D({:#X}, {:#X}, {:#X}, {:?}, {:?});",
                    target,
                    attachment,
                    textarget,
                    texture,
                    level
                );
            }
            let out = call_atomic_ptr_5arg(
                "glFramebufferTexture1D",
                &self.glFramebufferTexture1D_p,
                target,
                attachment,
                textarget,
                texture,
                level,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFramebufferTexture1D");
            }
            out
        }

        pub unsafe fn FramebufferTexture1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glFramebufferTexture1D\0",
                &self.glFramebufferTexture1D_p,
            )
        }
        #[inline]

        pub fn FramebufferTexture1D_is_loaded(&self) -> bool {
            !self.glFramebufferTexture1D_p.load(RELAX).is_null()
        }
        /// [glFramebufferTexture2D](http://docs.gl/gl4/glFramebufferTexture2D)(target, attachment, textarget, texture, level)
        /// * `target` group: FramebufferTarget
        /// * `attachment` group: FramebufferAttachment
        /// * `textarget` group: TextureTarget
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn FramebufferTexture2D(
            &self,
            target: GLenum,
            attachment: GLenum,
            textarget: GLenum,
            texture: GLuint,
            level: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.FramebufferTexture2D({:#X}, {:#X}, {:#X}, {:?}, {:?});",
                    target,
                    attachment,
                    textarget,
                    texture,
                    level
                );
            }
            let out = call_atomic_ptr_5arg(
                "glFramebufferTexture2D",
                &self.glFramebufferTexture2D_p,
                target,
                attachment,
                textarget,
                texture,
                level,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFramebufferTexture2D");
            }
            out
        }

        pub unsafe fn FramebufferTexture2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glFramebufferTexture2D\0",
                &self.glFramebufferTexture2D_p,
            )
        }
        #[inline]

        pub fn FramebufferTexture2D_is_loaded(&self) -> bool {
            !self.glFramebufferTexture2D_p.load(RELAX).is_null()
        }
        /// [glFramebufferTexture3D](http://docs.gl/gl4/glFramebufferTexture3D)(target, attachment, textarget, texture, level, zoffset)
        /// * `target` group: FramebufferTarget
        /// * `attachment` group: FramebufferAttachment
        /// * `textarget` group: TextureTarget
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn FramebufferTexture3D(
            &self,
            target: GLenum,
            attachment: GLenum,
            textarget: GLenum,
            texture: GLuint,
            level: GLint,
            zoffset: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.FramebufferTexture3D({:#X}, {:#X}, {:#X}, {:?}, {:?}, {:?});",
                    target,
                    attachment,
                    textarget,
                    texture,
                    level,
                    zoffset
                );
            }
            let out = call_atomic_ptr_6arg(
                "glFramebufferTexture3D",
                &self.glFramebufferTexture3D_p,
                target,
                attachment,
                textarget,
                texture,
                level,
                zoffset,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFramebufferTexture3D");
            }
            out
        }

        pub unsafe fn FramebufferTexture3D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glFramebufferTexture3D\0",
                &self.glFramebufferTexture3D_p,
            )
        }
        #[inline]

        pub fn FramebufferTexture3D_is_loaded(&self) -> bool {
            !self.glFramebufferTexture3D_p.load(RELAX).is_null()
        }
        /// [glFramebufferTextureLayer](http://docs.gl/gl4/glFramebufferTextureLayer)(target, attachment, texture, level, layer)
        /// * `target` group: FramebufferTarget
        /// * `attachment` group: FramebufferAttachment
        /// * `texture` group: Texture
        /// * `texture` class: texture
        /// * `level` group: CheckedInt32
        /// * `layer` group: CheckedInt32
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn FramebufferTextureLayer(
            &self,
            target: GLenum,
            attachment: GLenum,
            texture: GLuint,
            level: GLint,
            layer: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.FramebufferTextureLayer({:#X}, {:#X}, {:?}, {:?}, {:?});",
                    target,
                    attachment,
                    texture,
                    level,
                    layer
                );
            }
            let out = call_atomic_ptr_5arg(
                "glFramebufferTextureLayer",
                &self.glFramebufferTextureLayer_p,
                target,
                attachment,
                texture,
                level,
                layer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFramebufferTextureLayer");
            }
            out
        }

        pub unsafe fn FramebufferTextureLayer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glFramebufferTextureLayer\0",
                &self.glFramebufferTextureLayer_p,
            )
        }
        #[inline]

        pub fn FramebufferTextureLayer_is_loaded(&self) -> bool {
            !self.glFramebufferTextureLayer_p.load(RELAX).is_null()
        }
        /// [glFrontFace](http://docs.gl/gl4/glFrontFace)(mode)
        /// * `mode` group: FrontFaceDirection
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn FrontFace(&self, mode: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.FrontFace({:#X});", mode);
            }
            let out = call_atomic_ptr_1arg("glFrontFace", &self.glFrontFace_p, mode);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glFrontFace");
            }
            out
        }

        pub unsafe fn FrontFace_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glFrontFace\0", &self.glFrontFace_p)
        }
        #[inline]

        pub fn FrontFace_is_loaded(&self) -> bool {
            !self.glFrontFace_p.load(RELAX).is_null()
        }
        /// [glGenBuffers](http://docs.gl/gl4/glGenBuffers)(n, buffers)
        /// * `buffers` len: n
        /// * `buffers` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GenBuffers(&self, n: GLsizei, buffers: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GenBuffers({:?}, {:p});", n, buffers);
            }
            let out = call_atomic_ptr_2arg("glGenBuffers", &self.glGenBuffers_p, n, buffers);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGenBuffers");
            }
            out
        }

        pub unsafe fn GenBuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGenBuffers\0", &self.glGenBuffers_p)
        }
        #[inline]

        pub fn GenBuffers_is_loaded(&self) -> bool {
            !self.glGenBuffers_p.load(RELAX).is_null()
        }
        /// [glGenFramebuffers](http://docs.gl/gl4/glGenFramebuffers)(n, framebuffers)
        /// * `framebuffers` len: n
        /// * `framebuffers` class: framebuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GenFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GenFramebuffers({:?}, {:p});", n, framebuffers);
            }
            let out = call_atomic_ptr_2arg(
                "glGenFramebuffers",
                &self.glGenFramebuffers_p,
                n,
                framebuffers,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGenFramebuffers");
            }
            out
        }

        pub unsafe fn GenFramebuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGenFramebuffers\0",
                &self.glGenFramebuffers_p,
            )
        }
        #[inline]

        pub fn GenFramebuffers_is_loaded(&self) -> bool {
            !self.glGenFramebuffers_p.load(RELAX).is_null()
        }
        /// [glGenProgramPipelines](http://docs.gl/gl4/glGenProgramPipelines)(n, pipelines)
        /// * `pipelines` len: n
        /// * `pipelines` class: program pipeline
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GenProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GenProgramPipelines({:?}, {:p});", n, pipelines);
            }
            let out = call_atomic_ptr_2arg(
                "glGenProgramPipelines",
                &self.glGenProgramPipelines_p,
                n,
                pipelines,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGenProgramPipelines");
            }
            out
        }

        pub unsafe fn GenProgramPipelines_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGenProgramPipelines\0",
                &self.glGenProgramPipelines_p,
            )
        }
        #[inline]

        pub fn GenProgramPipelines_is_loaded(&self) -> bool {
            !self.glGenProgramPipelines_p.load(RELAX).is_null()
        }
        /// [glGenQueries](http://docs.gl/gl4/glGenQueries)(n, ids)
        /// * `ids` len: n
        /// * `ids` class: query
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GenQueries(&self, n: GLsizei, ids: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GenQueries({:?}, {:p});", n, ids);
            }
            let out = call_atomic_ptr_2arg("glGenQueries", &self.glGenQueries_p, n, ids);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGenQueries");
            }
            out
        }

        pub unsafe fn GenQueries_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGenQueries\0", &self.glGenQueries_p)
        }
        #[inline]

        pub fn GenQueries_is_loaded(&self) -> bool {
            !self.glGenQueries_p.load(RELAX).is_null()
        }
        /// [glGenRenderbuffers](http://docs.gl/gl4/glGenRenderbuffers)(n, renderbuffers)
        /// * `renderbuffers` len: n
        /// * `renderbuffers` class: renderbuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GenRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GenRenderbuffers({:?}, {:p});", n, renderbuffers);
            }
            let out = call_atomic_ptr_2arg(
                "glGenRenderbuffers",
                &self.glGenRenderbuffers_p,
                n,
                renderbuffers,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGenRenderbuffers");
            }
            out
        }

        pub unsafe fn GenRenderbuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGenRenderbuffers\0",
                &self.glGenRenderbuffers_p,
            )
        }
        #[inline]

        pub fn GenRenderbuffers_is_loaded(&self) -> bool {
            !self.glGenRenderbuffers_p.load(RELAX).is_null()
        }
        /// [glGenSamplers](http://docs.gl/gl4/glGenSamplers)(count, samplers)
        /// * `samplers` len: count
        /// * `samplers` class: sampler
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GenSamplers(&self, count: GLsizei, samplers: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GenSamplers({:?}, {:p});", count, samplers);
            }
            let out = call_atomic_ptr_2arg("glGenSamplers", &self.glGenSamplers_p, count, samplers);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGenSamplers");
            }
            out
        }

        pub unsafe fn GenSamplers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGenSamplers\0", &self.glGenSamplers_p)
        }
        #[inline]

        pub fn GenSamplers_is_loaded(&self) -> bool {
            !self.glGenSamplers_p.load(RELAX).is_null()
        }
        /// [glGenTextures](http://docs.gl/gl4/glGenTextures)(n, textures)
        /// * `textures` group: Texture
        /// * `textures` len: n
        /// * `textures` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GenTextures(&self, n: GLsizei, textures: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GenTextures({:?}, {:p});", n, textures);
            }
            let out = call_atomic_ptr_2arg("glGenTextures", &self.glGenTextures_p, n, textures);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGenTextures");
            }
            out
        }

        pub unsafe fn GenTextures_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGenTextures\0", &self.glGenTextures_p)
        }
        #[inline]

        pub fn GenTextures_is_loaded(&self) -> bool {
            !self.glGenTextures_p.load(RELAX).is_null()
        }
        /// [glGenTransformFeedbacks](http://docs.gl/gl4/glGenTransformFeedbacks)(n, ids)
        /// * `ids` len: n
        /// * `ids` class: transform feedback
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GenTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GenTransformFeedbacks({:?}, {:p});", n, ids);
            }
            let out = call_atomic_ptr_2arg(
                "glGenTransformFeedbacks",
                &self.glGenTransformFeedbacks_p,
                n,
                ids,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGenTransformFeedbacks");
            }
            out
        }

        pub unsafe fn GenTransformFeedbacks_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGenTransformFeedbacks\0",
                &self.glGenTransformFeedbacks_p,
            )
        }
        #[inline]

        pub fn GenTransformFeedbacks_is_loaded(&self) -> bool {
            !self.glGenTransformFeedbacks_p.load(RELAX).is_null()
        }
        /// [glGenVertexArrays](http://docs.gl/gl4/glGenVertexArrays)(n, arrays)
        /// * `arrays` len: n
        /// * `arrays` class: vertex array
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GenVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GenVertexArrays({:?}, {:p});", n, arrays);
            }
            let out =
                call_atomic_ptr_2arg("glGenVertexArrays", &self.glGenVertexArrays_p, n, arrays);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGenVertexArrays");
            }
            out
        }

        pub unsafe fn GenVertexArrays_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGenVertexArrays\0",
                &self.glGenVertexArrays_p,
            )
        }
        #[inline]

        pub fn GenVertexArrays_is_loaded(&self) -> bool {
            !self.glGenVertexArrays_p.load(RELAX).is_null()
        }
        /// [glGenerateMipmap](http://docs.gl/gl4/glGenerateMipmap)(target)
        /// * `target` group: TextureTarget
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GenerateMipmap(&self, target: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GenerateMipmap({:#X});", target);
            }
            let out = call_atomic_ptr_1arg("glGenerateMipmap", &self.glGenerateMipmap_p, target);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGenerateMipmap");
            }
            out
        }

        pub unsafe fn GenerateMipmap_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGenerateMipmap\0",
                &self.glGenerateMipmap_p,
            )
        }
        #[inline]

        pub fn GenerateMipmap_is_loaded(&self) -> bool {
            !self.glGenerateMipmap_p.load(RELAX).is_null()
        }
        /// [glGenerateTextureMipmap](http://docs.gl/gl4/glGenerateTextureMipmap)(texture)
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GenerateTextureMipmap(&self, texture: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GenerateTextureMipmap({:?});", texture);
            }
            let out = call_atomic_ptr_1arg(
                "glGenerateTextureMipmap",
                &self.glGenerateTextureMipmap_p,
                texture,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGenerateTextureMipmap");
            }
            out
        }

        pub unsafe fn GenerateTextureMipmap_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGenerateTextureMipmap\0",
                &self.glGenerateTextureMipmap_p,
            )
        }
        #[inline]

        pub fn GenerateTextureMipmap_is_loaded(&self) -> bool {
            !self.glGenerateTextureMipmap_p.load(RELAX).is_null()
        }
        /// [glGetActiveAtomicCounterBufferiv](http://docs.gl/gl4/glGetActiveAtomicCounterBuffer)(program, bufferIndex, pname, params)
        /// * `program` class: program
        /// * `pname` group: AtomicCounterBufferPName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetActiveAtomicCounterBufferiv(
            &self,
            program: GLuint,
            bufferIndex: GLuint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetActiveAtomicCounterBufferiv({:?}, {:?}, {:#X}, {:p});",
                    program,
                    bufferIndex,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetActiveAtomicCounterBufferiv",
                &self.glGetActiveAtomicCounterBufferiv_p,
                program,
                bufferIndex,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetActiveAtomicCounterBufferiv");
            }
            out
        }

        pub unsafe fn GetActiveAtomicCounterBufferiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetActiveAtomicCounterBufferiv\0",
                &self.glGetActiveAtomicCounterBufferiv_p,
            )
        }
        #[inline]

        pub fn GetActiveAtomicCounterBufferiv_is_loaded(&self) -> bool {
            !self
                .glGetActiveAtomicCounterBufferiv_p
                .load(RELAX)
                .is_null()
        }
        /// [glGetActiveAttrib](http://docs.gl/gl4/glGetActiveAttrib)(program, index, bufSize, length, size, type_, name)
        /// * `program` class: program
        /// * `length` len: 1
        /// * `size` len: 1
        /// * `type_` group: AttributeType
        /// * `type_` len: 1
        /// * `name` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetActiveAttrib(
            &self,
            program: GLuint,
            index: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            size: *mut GLint,
            type_: *mut GLenum,
            name: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetActiveAttrib({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});",
                    program,
                    index,
                    bufSize,
                    length,
                    size,
                    type_,
                    name
                );
            }
            let out = call_atomic_ptr_7arg(
                "glGetActiveAttrib",
                &self.glGetActiveAttrib_p,
                program,
                index,
                bufSize,
                length,
                size,
                type_,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetActiveAttrib");
            }
            out
        }

        pub unsafe fn GetActiveAttrib_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetActiveAttrib\0",
                &self.glGetActiveAttrib_p,
            )
        }
        #[inline]

        pub fn GetActiveAttrib_is_loaded(&self) -> bool {
            !self.glGetActiveAttrib_p.load(RELAX).is_null()
        }
        /// [glGetActiveSubroutineName](http://docs.gl/gl4/glGetActiveSubroutineName)(program, shadertype, index, bufSize, length, name)
        /// * `program` class: program
        /// * `shadertype` group: ShaderType
        /// * `length` len: 1
        /// * `name` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetActiveSubroutineName(
            &self,
            program: GLuint,
            shadertype: GLenum,
            index: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            name: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetActiveSubroutineName({:?}, {:#X}, {:?}, {:?}, {:p}, {:p});",
                    program,
                    shadertype,
                    index,
                    bufSize,
                    length,
                    name
                );
            }
            let out = call_atomic_ptr_6arg(
                "glGetActiveSubroutineName",
                &self.glGetActiveSubroutineName_p,
                program,
                shadertype,
                index,
                bufSize,
                length,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetActiveSubroutineName");
            }
            out
        }

        pub unsafe fn GetActiveSubroutineName_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetActiveSubroutineName\0",
                &self.glGetActiveSubroutineName_p,
            )
        }
        #[inline]

        pub fn GetActiveSubroutineName_is_loaded(&self) -> bool {
            !self.glGetActiveSubroutineName_p.load(RELAX).is_null()
        }
        /// [glGetActiveSubroutineUniformName](http://docs.gl/gl4/glGetActiveSubroutineUniformName)(program, shadertype, index, bufSize, length, name)
        /// * `program` class: program
        /// * `shadertype` group: ShaderType
        /// * `length` len: 1
        /// * `name` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetActiveSubroutineUniformName(
            &self,
            program: GLuint,
            shadertype: GLenum,
            index: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            name: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetActiveSubroutineUniformName({:?}, {:#X}, {:?}, {:?}, {:p}, {:p});", program, shadertype, index, bufSize, length, name);
            }
            let out = call_atomic_ptr_6arg(
                "glGetActiveSubroutineUniformName",
                &self.glGetActiveSubroutineUniformName_p,
                program,
                shadertype,
                index,
                bufSize,
                length,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetActiveSubroutineUniformName");
            }
            out
        }

        pub unsafe fn GetActiveSubroutineUniformName_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetActiveSubroutineUniformName\0",
                &self.glGetActiveSubroutineUniformName_p,
            )
        }
        #[inline]

        pub fn GetActiveSubroutineUniformName_is_loaded(&self) -> bool {
            !self
                .glGetActiveSubroutineUniformName_p
                .load(RELAX)
                .is_null()
        }
        /// [glGetActiveSubroutineUniformiv](http://docs.gl/gl4/glGetActiveSubroutineUniform)(program, shadertype, index, pname, values)
        /// * `program` class: program
        /// * `shadertype` group: ShaderType
        /// * `pname` group: SubroutineParameterName
        /// * `values` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetActiveSubroutineUniformiv(
            &self,
            program: GLuint,
            shadertype: GLenum,
            index: GLuint,
            pname: GLenum,
            values: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetActiveSubroutineUniformiv({:?}, {:#X}, {:?}, {:#X}, {:p});",
                    program,
                    shadertype,
                    index,
                    pname,
                    values
                );
            }
            let out = call_atomic_ptr_5arg(
                "glGetActiveSubroutineUniformiv",
                &self.glGetActiveSubroutineUniformiv_p,
                program,
                shadertype,
                index,
                pname,
                values,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetActiveSubroutineUniformiv");
            }
            out
        }

        pub unsafe fn GetActiveSubroutineUniformiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetActiveSubroutineUniformiv\0",
                &self.glGetActiveSubroutineUniformiv_p,
            )
        }
        #[inline]

        pub fn GetActiveSubroutineUniformiv_is_loaded(&self) -> bool {
            !self.glGetActiveSubroutineUniformiv_p.load(RELAX).is_null()
        }
        /// [glGetActiveUniform](http://docs.gl/gl4/glGetActiveUniform)(program, index, bufSize, length, size, type_, name)
        /// * `program` class: program
        /// * `length` len: 1
        /// * `size` len: 1
        /// * `type_` group: UniformType
        /// * `type_` len: 1
        /// * `name` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetActiveUniform(
            &self,
            program: GLuint,
            index: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            size: *mut GLint,
            type_: *mut GLenum,
            name: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetActiveUniform({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});",
                    program,
                    index,
                    bufSize,
                    length,
                    size,
                    type_,
                    name
                );
            }
            let out = call_atomic_ptr_7arg(
                "glGetActiveUniform",
                &self.glGetActiveUniform_p,
                program,
                index,
                bufSize,
                length,
                size,
                type_,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetActiveUniform");
            }
            out
        }

        pub unsafe fn GetActiveUniform_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetActiveUniform\0",
                &self.glGetActiveUniform_p,
            )
        }
        #[inline]

        pub fn GetActiveUniform_is_loaded(&self) -> bool {
            !self.glGetActiveUniform_p.load(RELAX).is_null()
        }
        /// [glGetActiveUniformBlockName](http://docs.gl/gl4/glGetActiveUniformBlockName)(program, uniformBlockIndex, bufSize, length, uniformBlockName)
        /// * `program` class: program
        /// * `length` len: 1
        /// * `uniformBlockName` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetActiveUniformBlockName(
            &self,
            program: GLuint,
            uniformBlockIndex: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            uniformBlockName: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetActiveUniformBlockName({:?}, {:?}, {:?}, {:p}, {:p});",
                    program,
                    uniformBlockIndex,
                    bufSize,
                    length,
                    uniformBlockName
                );
            }
            let out = call_atomic_ptr_5arg(
                "glGetActiveUniformBlockName",
                &self.glGetActiveUniformBlockName_p,
                program,
                uniformBlockIndex,
                bufSize,
                length,
                uniformBlockName,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetActiveUniformBlockName");
            }
            out
        }

        pub unsafe fn GetActiveUniformBlockName_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetActiveUniformBlockName\0",
                &self.glGetActiveUniformBlockName_p,
            )
        }
        #[inline]

        pub fn GetActiveUniformBlockName_is_loaded(&self) -> bool {
            !self.glGetActiveUniformBlockName_p.load(RELAX).is_null()
        }
        /// [glGetActiveUniformBlockiv](http://docs.gl/gl4/glGetActiveUniformBlockiv)(program, uniformBlockIndex, pname, params)
        /// * `program` class: program
        /// * `pname` group: UniformBlockPName
        /// * `params` len: COMPSIZE(program,uniformBlockIndex,pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetActiveUniformBlockiv(
            &self,
            program: GLuint,
            uniformBlockIndex: GLuint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetActiveUniformBlockiv({:?}, {:?}, {:#X}, {:p});",
                    program,
                    uniformBlockIndex,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetActiveUniformBlockiv",
                &self.glGetActiveUniformBlockiv_p,
                program,
                uniformBlockIndex,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetActiveUniformBlockiv");
            }
            out
        }

        pub unsafe fn GetActiveUniformBlockiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetActiveUniformBlockiv\0",
                &self.glGetActiveUniformBlockiv_p,
            )
        }
        #[inline]

        pub fn GetActiveUniformBlockiv_is_loaded(&self) -> bool {
            !self.glGetActiveUniformBlockiv_p.load(RELAX).is_null()
        }
        /// [glGetActiveUniformName](http://docs.gl/gl4/glGetActiveUniformName)(program, uniformIndex, bufSize, length, uniformName)
        /// * `program` class: program
        /// * `length` len: 1
        /// * `uniformName` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetActiveUniformName(
            &self,
            program: GLuint,
            uniformIndex: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            uniformName: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetActiveUniformName({:?}, {:?}, {:?}, {:p}, {:p});",
                    program,
                    uniformIndex,
                    bufSize,
                    length,
                    uniformName
                );
            }
            let out = call_atomic_ptr_5arg(
                "glGetActiveUniformName",
                &self.glGetActiveUniformName_p,
                program,
                uniformIndex,
                bufSize,
                length,
                uniformName,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetActiveUniformName");
            }
            out
        }

        pub unsafe fn GetActiveUniformName_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetActiveUniformName\0",
                &self.glGetActiveUniformName_p,
            )
        }
        #[inline]

        pub fn GetActiveUniformName_is_loaded(&self) -> bool {
            !self.glGetActiveUniformName_p.load(RELAX).is_null()
        }
        /// [glGetActiveUniformsiv](http://docs.gl/gl4/glGetActiveUniformsiv)(program, uniformCount, uniformIndices, pname, params)
        /// * `program` class: program
        /// * `uniformIndices` len: uniformCount
        /// * `pname` group: UniformPName
        /// * `params` len: COMPSIZE(uniformCount,pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetActiveUniformsiv(
            &self,
            program: GLuint,
            uniformCount: GLsizei,
            uniformIndices: *const GLuint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetActiveUniformsiv({:?}, {:?}, {:p}, {:#X}, {:p});",
                    program,
                    uniformCount,
                    uniformIndices,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_5arg(
                "glGetActiveUniformsiv",
                &self.glGetActiveUniformsiv_p,
                program,
                uniformCount,
                uniformIndices,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetActiveUniformsiv");
            }
            out
        }

        pub unsafe fn GetActiveUniformsiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetActiveUniformsiv\0",
                &self.glGetActiveUniformsiv_p,
            )
        }
        #[inline]

        pub fn GetActiveUniformsiv_is_loaded(&self) -> bool {
            !self.glGetActiveUniformsiv_p.load(RELAX).is_null()
        }
        /// [glGetAttachedShaders](http://docs.gl/gl4/glGetAttachedShaders)(program, maxCount, count, shaders)
        /// * `program` class: program
        /// * `count` len: 1
        /// * `shaders` len: maxCount
        /// * `shaders` class: shader
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetAttachedShaders(
            &self,
            program: GLuint,
            maxCount: GLsizei,
            count: *mut GLsizei,
            shaders: *mut GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetAttachedShaders({:?}, {:?}, {:p}, {:p});",
                    program,
                    maxCount,
                    count,
                    shaders
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetAttachedShaders",
                &self.glGetAttachedShaders_p,
                program,
                maxCount,
                count,
                shaders,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetAttachedShaders");
            }
            out
        }

        pub unsafe fn GetAttachedShaders_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetAttachedShaders\0",
                &self.glGetAttachedShaders_p,
            )
        }
        #[inline]

        pub fn GetAttachedShaders_is_loaded(&self) -> bool {
            !self.glGetAttachedShaders_p.load(RELAX).is_null()
        }
        /// [glGetAttribLocation](http://docs.gl/gl4/glGetAttribLocation)(program, name)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetAttribLocation(&self, program: GLuint, name: *const GLchar) -> GLint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetAttribLocation({:?}, {:p});", program, name);
            }
            let out = call_atomic_ptr_2arg(
                "glGetAttribLocation",
                &self.glGetAttribLocation_p,
                program,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetAttribLocation");
            }
            out
        }

        pub unsafe fn GetAttribLocation_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetAttribLocation\0",
                &self.glGetAttribLocation_p,
            )
        }
        #[inline]

        pub fn GetAttribLocation_is_loaded(&self) -> bool {
            !self.glGetAttribLocation_p.load(RELAX).is_null()
        }
        /// [glGetBooleani_v](http://docs.gl/gl4/glGet)(target, index, data)
        /// * `target` group: BufferTargetARB
        /// * `data` len: COMPSIZE(target)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetBooleani_v(&self, target: GLenum, index: GLuint, data: *mut GLboolean) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetBooleani_v({:#X}, {:?}, {:p});",
                    target,
                    index,
                    data
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetBooleani_v",
                &self.glGetBooleani_v_p,
                target,
                index,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetBooleani_v");
            }
            out
        }

        pub unsafe fn GetBooleani_v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetBooleani_v\0",
                &self.glGetBooleani_v_p,
            )
        }
        #[inline]

        pub fn GetBooleani_v_is_loaded(&self) -> bool {
            !self.glGetBooleani_v_p.load(RELAX).is_null()
        }
        /// [glGetBooleanv](http://docs.gl/gl4/glGet)(pname, data)
        /// * `pname` group: GetPName
        /// * `data` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetBooleanv(&self, pname: GLenum, data: *mut GLboolean) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetBooleanv({:#X}, {:p});", pname, data);
            }
            let out = call_atomic_ptr_2arg("glGetBooleanv", &self.glGetBooleanv_p, pname, data);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetBooleanv");
            }
            out
        }

        pub unsafe fn GetBooleanv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetBooleanv\0", &self.glGetBooleanv_p)
        }
        #[inline]

        pub fn GetBooleanv_is_loaded(&self) -> bool {
            !self.glGetBooleanv_p.load(RELAX).is_null()
        }
        /// [glGetBufferParameteri64v](http://docs.gl/gl4/glGetBufferParameter)(target, pname, params)
        /// * `target` group: BufferTargetARB
        /// * `pname` group: BufferPNameARB
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetBufferParameteri64v(
            &self,
            target: GLenum,
            pname: GLenum,
            params: *mut GLint64,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetBufferParameteri64v({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetBufferParameteri64v",
                &self.glGetBufferParameteri64v_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetBufferParameteri64v");
            }
            out
        }

        pub unsafe fn GetBufferParameteri64v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetBufferParameteri64v\0",
                &self.glGetBufferParameteri64v_p,
            )
        }
        #[inline]

        pub fn GetBufferParameteri64v_is_loaded(&self) -> bool {
            !self.glGetBufferParameteri64v_p.load(RELAX).is_null()
        }
        /// [glGetBufferParameteriv](http://docs.gl/gl4/glGetBufferParameter)(target, pname, params)
        /// * `target` group: BufferTargetARB
        /// * `pname` group: BufferPNameARB
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetBufferParameteriv(
            &self,
            target: GLenum,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetBufferParameteriv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetBufferParameteriv",
                &self.glGetBufferParameteriv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetBufferParameteriv");
            }
            out
        }

        pub unsafe fn GetBufferParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetBufferParameteriv\0",
                &self.glGetBufferParameteriv_p,
            )
        }
        #[inline]

        pub fn GetBufferParameteriv_is_loaded(&self) -> bool {
            !self.glGetBufferParameteriv_p.load(RELAX).is_null()
        }
        /// [glGetBufferPointerv](http://docs.gl/gl4/glGetBufferPointerv)(target, pname, params)
        /// * `target` group: BufferTargetARB
        /// * `pname` group: BufferPointerNameARB
        /// * `params` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetBufferPointerv(
            &self,
            target: GLenum,
            pname: GLenum,
            params: *mut *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetBufferPointerv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetBufferPointerv",
                &self.glGetBufferPointerv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetBufferPointerv");
            }
            out
        }

        pub unsafe fn GetBufferPointerv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetBufferPointerv\0",
                &self.glGetBufferPointerv_p,
            )
        }
        #[inline]

        pub fn GetBufferPointerv_is_loaded(&self) -> bool {
            !self.glGetBufferPointerv_p.load(RELAX).is_null()
        }
        /// [glGetBufferSubData](http://docs.gl/gl4/glGetBufferSubData)(target, offset, size, data)
        /// * `target` group: BufferTargetARB
        /// * `offset` group: BufferOffset
        /// * `size` group: BufferSize
        /// * `data` len: size
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetBufferSubData(
            &self,
            target: GLenum,
            offset: GLintptr,
            size: GLsizeiptr,
            data: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetBufferSubData({:#X}, {:?}, {:?}, {:p});",
                    target,
                    offset,
                    size,
                    data
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetBufferSubData",
                &self.glGetBufferSubData_p,
                target,
                offset,
                size,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetBufferSubData");
            }
            out
        }

        pub unsafe fn GetBufferSubData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetBufferSubData\0",
                &self.glGetBufferSubData_p,
            )
        }
        #[inline]

        pub fn GetBufferSubData_is_loaded(&self) -> bool {
            !self.glGetBufferSubData_p.load(RELAX).is_null()
        }
        /// [glGetCompressedTexImage](http://docs.gl/gl4/glGetCompressedTexImage)(target, level, img)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `img` group: CompressedTextureARB
        /// * `img` len: COMPSIZE(target,level)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetCompressedTexImage(&self, target: GLenum, level: GLint, img: *mut c_void) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetCompressedTexImage({:#X}, {:?}, {:p});",
                    target,
                    level,
                    img
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetCompressedTexImage",
                &self.glGetCompressedTexImage_p,
                target,
                level,
                img,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetCompressedTexImage");
            }
            out
        }

        pub unsafe fn GetCompressedTexImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetCompressedTexImage\0",
                &self.glGetCompressedTexImage_p,
            )
        }
        #[inline]

        pub fn GetCompressedTexImage_is_loaded(&self) -> bool {
            !self.glGetCompressedTexImage_p.load(RELAX).is_null()
        }
        /// [glGetCompressedTextureImage](http://docs.gl/gl4/glGetCompressedTextureImage)(texture, level, bufSize, pixels)
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetCompressedTextureImage(
            &self,
            texture: GLuint,
            level: GLint,
            bufSize: GLsizei,
            pixels: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetCompressedTextureImage({:?}, {:?}, {:?}, {:p});",
                    texture,
                    level,
                    bufSize,
                    pixels
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetCompressedTextureImage",
                &self.glGetCompressedTextureImage_p,
                texture,
                level,
                bufSize,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetCompressedTextureImage");
            }
            out
        }

        pub unsafe fn GetCompressedTextureImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetCompressedTextureImage\0",
                &self.glGetCompressedTextureImage_p,
            )
        }
        #[inline]

        pub fn GetCompressedTextureImage_is_loaded(&self) -> bool {
            !self.glGetCompressedTextureImage_p.load(RELAX).is_null()
        }
        /// [glGetCompressedTextureSubImage](http://docs.gl/gl4/glGetCompressedTextureSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels)
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetCompressedTextureSubImage(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            zoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            bufSize: GLsizei,
            pixels: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetCompressedTextureSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
            }
            let out = call_atomic_ptr_10arg(
                "glGetCompressedTextureSubImage",
                &self.glGetCompressedTextureSubImage_p,
                texture,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                bufSize,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetCompressedTextureSubImage");
            }
            out
        }

        pub unsafe fn GetCompressedTextureSubImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetCompressedTextureSubImage\0",
                &self.glGetCompressedTextureSubImage_p,
            )
        }
        #[inline]

        pub fn GetCompressedTextureSubImage_is_loaded(&self) -> bool {
            !self.glGetCompressedTextureSubImage_p.load(RELAX).is_null()
        }
        /// [glGetDebugMessageLog](http://docs.gl/gl4/glGetDebugMessageLog)(count, bufSize, sources, types, ids, severities, lengths, messageLog)
        /// * `sources` group: DebugSource
        /// * `sources` len: count
        /// * `types` group: DebugType
        /// * `types` len: count
        /// * `ids` len: count
        /// * `severities` group: DebugSeverity
        /// * `severities` len: count
        /// * `lengths` len: count
        /// * `messageLog` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetDebugMessageLog(
            &self,
            count: GLuint,
            bufSize: GLsizei,
            sources: *mut GLenum,
            types: *mut GLenum,
            ids: *mut GLuint,
            severities: *mut GLenum,
            lengths: *mut GLsizei,
            messageLog: *mut GLchar,
        ) -> GLuint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetDebugMessageLog({:?}, {:?}, {:p}, {:p}, {:p}, {:p}, {:p}, {:p});", count, bufSize, sources, types, ids, severities, lengths, messageLog);
            }
            let out = call_atomic_ptr_8arg(
                "glGetDebugMessageLog",
                &self.glGetDebugMessageLog_p,
                count,
                bufSize,
                sources,
                types,
                ids,
                severities,
                lengths,
                messageLog,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetDebugMessageLog");
            }
            out
        }

        pub unsafe fn GetDebugMessageLog_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetDebugMessageLog\0",
                &self.glGetDebugMessageLog_p,
            )
        }
        #[inline]

        pub fn GetDebugMessageLog_is_loaded(&self) -> bool {
            !self.glGetDebugMessageLog_p.load(RELAX).is_null()
        }
        /// [glGetDoublei_v](http://docs.gl/gl4/glGetDoublei_v)(target, index, data)
        /// * `target` group: GetPName
        /// * `data` len: COMPSIZE(target)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetDoublei_v(&self, target: GLenum, index: GLuint, data: *mut GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetDoublei_v({:#X}, {:?}, {:p});",
                    target,
                    index,
                    data
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetDoublei_v",
                &self.glGetDoublei_v_p,
                target,
                index,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetDoublei_v");
            }
            out
        }

        pub unsafe fn GetDoublei_v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetDoublei_v\0",
                &self.glGetDoublei_v_p,
            )
        }
        #[inline]

        pub fn GetDoublei_v_is_loaded(&self) -> bool {
            !self.glGetDoublei_v_p.load(RELAX).is_null()
        }
        /// [glGetDoublev](http://docs.gl/gl4/glGetDoublev)(pname, data)
        /// * `pname` group: GetPName
        /// * `data` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetDoublev(&self, pname: GLenum, data: *mut GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetDoublev({:#X}, {:p});", pname, data);
            }
            let out = call_atomic_ptr_2arg("glGetDoublev", &self.glGetDoublev_p, pname, data);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetDoublev");
            }
            out
        }

        pub unsafe fn GetDoublev_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetDoublev\0", &self.glGetDoublev_p)
        }
        #[inline]

        pub fn GetDoublev_is_loaded(&self) -> bool {
            !self.glGetDoublev_p.load(RELAX).is_null()
        }
        /// [glGetError](http://docs.gl/gl4/glGetError)()
        /// * return value group: ErrorCode
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetError(&self) -> GLenum {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetError();",);
            }
            let out = call_atomic_ptr_0arg("glGetError", &self.glGetError_p);

            out
        }

        pub unsafe fn GetError_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetError\0", &self.glGetError_p)
        }
        #[inline]

        pub fn GetError_is_loaded(&self) -> bool {
            !self.glGetError_p.load(RELAX).is_null()
        }
        /// [glGetFloati_v](http://docs.gl/gl4/glGetFloati_v)(target, index, data)
        /// * `target` group: GetPName
        /// * `data` len: COMPSIZE(target)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetFloati_v(&self, target: GLenum, index: GLuint, data: *mut GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetFloati_v({:#X}, {:?}, {:p});",
                    target,
                    index,
                    data
                );
            }
            let out =
                call_atomic_ptr_3arg("glGetFloati_v", &self.glGetFloati_v_p, target, index, data);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetFloati_v");
            }
            out
        }

        pub unsafe fn GetFloati_v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetFloati_v\0", &self.glGetFloati_v_p)
        }
        #[inline]

        pub fn GetFloati_v_is_loaded(&self) -> bool {
            !self.glGetFloati_v_p.load(RELAX).is_null()
        }
        /// [glGetFloatv](http://docs.gl/gl4/glGet)(pname, data)
        /// * `pname` group: GetPName
        /// * `data` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetFloatv(&self, pname: GLenum, data: *mut GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetFloatv({:#X}, {:p});", pname, data);
            }
            let out = call_atomic_ptr_2arg("glGetFloatv", &self.glGetFloatv_p, pname, data);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetFloatv");
            }
            out
        }

        pub unsafe fn GetFloatv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetFloatv\0", &self.glGetFloatv_p)
        }
        #[inline]

        pub fn GetFloatv_is_loaded(&self) -> bool {
            !self.glGetFloatv_p.load(RELAX).is_null()
        }
        /// [glGetFragDataIndex](http://docs.gl/gl4/glGetFragDataIndex)(program, name)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetFragDataIndex(&self, program: GLuint, name: *const GLchar) -> GLint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetFragDataIndex({:?}, {:p});", program, name);
            }
            let out = call_atomic_ptr_2arg(
                "glGetFragDataIndex",
                &self.glGetFragDataIndex_p,
                program,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetFragDataIndex");
            }
            out
        }

        pub unsafe fn GetFragDataIndex_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetFragDataIndex\0",
                &self.glGetFragDataIndex_p,
            )
        }
        #[inline]

        pub fn GetFragDataIndex_is_loaded(&self) -> bool {
            !self.glGetFragDataIndex_p.load(RELAX).is_null()
        }
        /// [glGetFragDataLocation](http://docs.gl/gl4/glGetFragDataLocation)(program, name)
        /// * `program` class: program
        /// * `name` len: COMPSIZE(name)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetFragDataLocation(&self, program: GLuint, name: *const GLchar) -> GLint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetFragDataLocation({:?}, {:p});", program, name);
            }
            let out = call_atomic_ptr_2arg(
                "glGetFragDataLocation",
                &self.glGetFragDataLocation_p,
                program,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetFragDataLocation");
            }
            out
        }

        pub unsafe fn GetFragDataLocation_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetFragDataLocation\0",
                &self.glGetFragDataLocation_p,
            )
        }
        #[inline]

        pub fn GetFragDataLocation_is_loaded(&self) -> bool {
            !self.glGetFragDataLocation_p.load(RELAX).is_null()
        }
        /// [glGetFramebufferAttachmentParameteriv](http://docs.gl/gl4/glGetFramebufferAttachmentParameter)(target, attachment, pname, params)
        /// * `target` group: FramebufferTarget
        /// * `attachment` group: FramebufferAttachment
        /// * `pname` group: FramebufferAttachmentParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetFramebufferAttachmentParameteriv(
            &self,
            target: GLenum,
            attachment: GLenum,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetFramebufferAttachmentParameteriv({:#X}, {:#X}, {:#X}, {:p});",
                    target,
                    attachment,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetFramebufferAttachmentParameteriv",
                &self.glGetFramebufferAttachmentParameteriv_p,
                target,
                attachment,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetFramebufferAttachmentParameteriv");
            }
            out
        }

        pub unsafe fn GetFramebufferAttachmentParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetFramebufferAttachmentParameteriv\0",
                &self.glGetFramebufferAttachmentParameteriv_p,
            )
        }
        #[inline]

        pub fn GetFramebufferAttachmentParameteriv_is_loaded(&self) -> bool {
            !self
                .glGetFramebufferAttachmentParameteriv_p
                .load(RELAX)
                .is_null()
        }
        /// [glGetFramebufferParameteriv](http://docs.gl/gl4/glGetFramebufferParameter)(target, pname, params)
        /// * `target` group: FramebufferTarget
        /// * `pname` group: FramebufferAttachmentParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetFramebufferParameteriv(
            &self,
            target: GLenum,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetFramebufferParameteriv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetFramebufferParameteriv",
                &self.glGetFramebufferParameteriv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetFramebufferParameteriv");
            }
            out
        }

        pub unsafe fn GetFramebufferParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetFramebufferParameteriv\0",
                &self.glGetFramebufferParameteriv_p,
            )
        }
        #[inline]

        pub fn GetFramebufferParameteriv_is_loaded(&self) -> bool {
            !self.glGetFramebufferParameteriv_p.load(RELAX).is_null()
        }
        /// [glGetGraphicsResetStatus](http://docs.gl/gl4/glGetGraphicsResetStatus)()
        /// * return value group: GraphicsResetStatus
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetGraphicsResetStatus(&self) -> GLenum {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetGraphicsResetStatus();",);
            }
            let out =
                call_atomic_ptr_0arg("glGetGraphicsResetStatus", &self.glGetGraphicsResetStatus_p);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetGraphicsResetStatus");
            }
            out
        }

        pub unsafe fn GetGraphicsResetStatus_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetGraphicsResetStatus\0",
                &self.glGetGraphicsResetStatus_p,
            )
        }
        #[inline]

        pub fn GetGraphicsResetStatus_is_loaded(&self) -> bool {
            !self.glGetGraphicsResetStatus_p.load(RELAX).is_null()
        }
        /// [glGetInteger64i_v](http://docs.gl/gl4/glGet)(target, index, data)
        /// * `target` group: GetPName
        /// * `data` len: COMPSIZE(target)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetInteger64i_v(&self, target: GLenum, index: GLuint, data: *mut GLint64) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetInteger64i_v({:#X}, {:?}, {:p});",
                    target,
                    index,
                    data
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetInteger64i_v",
                &self.glGetInteger64i_v_p,
                target,
                index,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetInteger64i_v");
            }
            out
        }

        pub unsafe fn GetInteger64i_v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetInteger64i_v\0",
                &self.glGetInteger64i_v_p,
            )
        }
        #[inline]

        pub fn GetInteger64i_v_is_loaded(&self) -> bool {
            !self.glGetInteger64i_v_p.load(RELAX).is_null()
        }
        /// [glGetInteger64v](http://docs.gl/gl4/glGet)(pname, data)
        /// * `pname` group: GetPName
        /// * `data` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetInteger64v(&self, pname: GLenum, data: *mut GLint64) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetInteger64v({:#X}, {:p});", pname, data);
            }
            let out = call_atomic_ptr_2arg("glGetInteger64v", &self.glGetInteger64v_p, pname, data);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetInteger64v");
            }
            out
        }

        pub unsafe fn GetInteger64v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetInteger64v\0",
                &self.glGetInteger64v_p,
            )
        }
        #[inline]

        pub fn GetInteger64v_is_loaded(&self) -> bool {
            !self.glGetInteger64v_p.load(RELAX).is_null()
        }
        /// [glGetIntegeri_v](http://docs.gl/gl4/glGet)(target, index, data)
        /// * `target` group: GetPName
        /// * `data` len: COMPSIZE(target)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetIntegeri_v(&self, target: GLenum, index: GLuint, data: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetIntegeri_v({:#X}, {:?}, {:p});",
                    target,
                    index,
                    data
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetIntegeri_v",
                &self.glGetIntegeri_v_p,
                target,
                index,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetIntegeri_v");
            }
            out
        }

        pub unsafe fn GetIntegeri_v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetIntegeri_v\0",
                &self.glGetIntegeri_v_p,
            )
        }
        #[inline]

        pub fn GetIntegeri_v_is_loaded(&self) -> bool {
            !self.glGetIntegeri_v_p.load(RELAX).is_null()
        }
        /// [glGetIntegerv](http://docs.gl/gl4/glGet)(pname, data)
        /// * `pname` group: GetPName
        /// * `data` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetIntegerv(&self, pname: GLenum, data: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetIntegerv({:#X}, {:p});", pname, data);
            }
            let out = call_atomic_ptr_2arg("glGetIntegerv", &self.glGetIntegerv_p, pname, data);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetIntegerv");
            }
            out
        }

        pub unsafe fn GetIntegerv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetIntegerv\0", &self.glGetIntegerv_p)
        }
        #[inline]

        pub fn GetIntegerv_is_loaded(&self) -> bool {
            !self.glGetIntegerv_p.load(RELAX).is_null()
        }
        /// [glGetInternalformati64v](http://docs.gl/gl4/glGetInternalformat)(target, internalformat, pname, count, params)
        /// * `target` group: TextureTarget
        /// * `internalformat` group: InternalFormat
        /// * `pname` group: InternalFormatPName
        /// * `params` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetInternalformati64v(
            &self,
            target: GLenum,
            internalformat: GLenum,
            pname: GLenum,
            count: GLsizei,
            params: *mut GLint64,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetInternalformati64v({:#X}, {:#X}, {:#X}, {:?}, {:p});",
                    target,
                    internalformat,
                    pname,
                    count,
                    params
                );
            }
            let out = call_atomic_ptr_5arg(
                "glGetInternalformati64v",
                &self.glGetInternalformati64v_p,
                target,
                internalformat,
                pname,
                count,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetInternalformati64v");
            }
            out
        }

        pub unsafe fn GetInternalformati64v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetInternalformati64v\0",
                &self.glGetInternalformati64v_p,
            )
        }
        #[inline]

        pub fn GetInternalformati64v_is_loaded(&self) -> bool {
            !self.glGetInternalformati64v_p.load(RELAX).is_null()
        }
        /// [glGetInternalformativ](http://docs.gl/gl4/glGetInternalformativ)(target, internalformat, pname, count, params)
        /// * `target` group: TextureTarget
        /// * `internalformat` group: InternalFormat
        /// * `pname` group: InternalFormatPName
        /// * `params` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetInternalformativ(
            &self,
            target: GLenum,
            internalformat: GLenum,
            pname: GLenum,
            count: GLsizei,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetInternalformativ({:#X}, {:#X}, {:#X}, {:?}, {:p});",
                    target,
                    internalformat,
                    pname,
                    count,
                    params
                );
            }
            let out = call_atomic_ptr_5arg(
                "glGetInternalformativ",
                &self.glGetInternalformativ_p,
                target,
                internalformat,
                pname,
                count,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetInternalformativ");
            }
            out
        }

        pub unsafe fn GetInternalformativ_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetInternalformativ\0",
                &self.glGetInternalformativ_p,
            )
        }
        #[inline]

        pub fn GetInternalformativ_is_loaded(&self) -> bool {
            !self.glGetInternalformativ_p.load(RELAX).is_null()
        }
        /// [glGetMultisamplefv](http://docs.gl/gl4/glGetMultisample)(pname, index, val)
        /// * `pname` group: GetMultisamplePNameNV
        /// * `val` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetMultisamplefv(&self, pname: GLenum, index: GLuint, val: *mut GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetMultisamplefv({:#X}, {:?}, {:p});",
                    pname,
                    index,
                    val
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetMultisamplefv",
                &self.glGetMultisamplefv_p,
                pname,
                index,
                val,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetMultisamplefv");
            }
            out
        }

        pub unsafe fn GetMultisamplefv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetMultisamplefv\0",
                &self.glGetMultisamplefv_p,
            )
        }
        #[inline]

        pub fn GetMultisamplefv_is_loaded(&self) -> bool {
            !self.glGetMultisamplefv_p.load(RELAX).is_null()
        }
        /// [glGetNamedBufferParameteri64v](http://docs.gl/gl4/glGetNamedBufferParameter)(buffer, pname, params)
        /// * `buffer` class: buffer
        /// * `pname` group: BufferPNameARB
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetNamedBufferParameteri64v(
            &self,
            buffer: GLuint,
            pname: GLenum,
            params: *mut GLint64,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetNamedBufferParameteri64v({:?}, {:#X}, {:p});",
                    buffer,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetNamedBufferParameteri64v",
                &self.glGetNamedBufferParameteri64v_p,
                buffer,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetNamedBufferParameteri64v");
            }
            out
        }

        pub unsafe fn GetNamedBufferParameteri64v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetNamedBufferParameteri64v\0",
                &self.glGetNamedBufferParameteri64v_p,
            )
        }
        #[inline]

        pub fn GetNamedBufferParameteri64v_is_loaded(&self) -> bool {
            !self.glGetNamedBufferParameteri64v_p.load(RELAX).is_null()
        }
        /// [glGetNamedBufferParameteriv](http://docs.gl/gl4/glGetNamedBufferParameter)(buffer, pname, params)
        /// * `buffer` class: buffer
        /// * `pname` group: BufferPNameARB
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetNamedBufferParameteriv(
            &self,
            buffer: GLuint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetNamedBufferParameteriv({:?}, {:#X}, {:p});",
                    buffer,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetNamedBufferParameteriv",
                &self.glGetNamedBufferParameteriv_p,
                buffer,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetNamedBufferParameteriv");
            }
            out
        }

        pub unsafe fn GetNamedBufferParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetNamedBufferParameteriv\0",
                &self.glGetNamedBufferParameteriv_p,
            )
        }
        #[inline]

        pub fn GetNamedBufferParameteriv_is_loaded(&self) -> bool {
            !self.glGetNamedBufferParameteriv_p.load(RELAX).is_null()
        }
        /// [glGetNamedBufferPointerv](http://docs.gl/gl4/glGetNamedBufferPointerv)(buffer, pname, params)
        /// * `buffer` class: buffer
        /// * `pname` group: BufferPointerNameARB
        /// * `params` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetNamedBufferPointerv(
            &self,
            buffer: GLuint,
            pname: GLenum,
            params: *mut *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetNamedBufferPointerv({:?}, {:#X}, {:p});",
                    buffer,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetNamedBufferPointerv",
                &self.glGetNamedBufferPointerv_p,
                buffer,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetNamedBufferPointerv");
            }
            out
        }

        pub unsafe fn GetNamedBufferPointerv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetNamedBufferPointerv\0",
                &self.glGetNamedBufferPointerv_p,
            )
        }
        #[inline]

        pub fn GetNamedBufferPointerv_is_loaded(&self) -> bool {
            !self.glGetNamedBufferPointerv_p.load(RELAX).is_null()
        }
        /// [glGetNamedBufferSubData](http://docs.gl/gl4/glGetNamedBufferSubData)(buffer, offset, size, data)
        /// * `buffer` class: buffer
        /// * `size` group: BufferSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetNamedBufferSubData(
            &self,
            buffer: GLuint,
            offset: GLintptr,
            size: GLsizeiptr,
            data: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetNamedBufferSubData({:?}, {:?}, {:?}, {:p});",
                    buffer,
                    offset,
                    size,
                    data
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetNamedBufferSubData",
                &self.glGetNamedBufferSubData_p,
                buffer,
                offset,
                size,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetNamedBufferSubData");
            }
            out
        }

        pub unsafe fn GetNamedBufferSubData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetNamedBufferSubData\0",
                &self.glGetNamedBufferSubData_p,
            )
        }
        #[inline]

        pub fn GetNamedBufferSubData_is_loaded(&self) -> bool {
            !self.glGetNamedBufferSubData_p.load(RELAX).is_null()
        }
        /// [glGetNamedFramebufferAttachmentParameteriv](http://docs.gl/gl4/glGetNamedFramebufferAttachmentParameter)(framebuffer, attachment, pname, params)
        /// * `framebuffer` class: framebuffer
        /// * `attachment` group: FramebufferAttachment
        /// * `pname` group: FramebufferAttachmentParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetNamedFramebufferAttachmentParameteriv(
            &self,
            framebuffer: GLuint,
            attachment: GLenum,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetNamedFramebufferAttachmentParameteriv({:?}, {:#X}, {:#X}, {:p});", framebuffer, attachment, pname, params);
            }
            let out = call_atomic_ptr_4arg(
                "glGetNamedFramebufferAttachmentParameteriv",
                &self.glGetNamedFramebufferAttachmentParameteriv_p,
                framebuffer,
                attachment,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetNamedFramebufferAttachmentParameteriv");
            }
            out
        }

        pub unsafe fn GetNamedFramebufferAttachmentParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetNamedFramebufferAttachmentParameteriv\0",
                &self.glGetNamedFramebufferAttachmentParameteriv_p,
            )
        }
        #[inline]

        pub fn GetNamedFramebufferAttachmentParameteriv_is_loaded(&self) -> bool {
            !self
                .glGetNamedFramebufferAttachmentParameteriv_p
                .load(RELAX)
                .is_null()
        }
        /// [glGetNamedFramebufferParameteriv](http://docs.gl/gl4/glGetNamedFramebufferParameter)(framebuffer, pname, param)
        /// * `framebuffer` class: framebuffer
        /// * `pname` group: GetFramebufferParameter
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetNamedFramebufferParameteriv(
            &self,
            framebuffer: GLuint,
            pname: GLenum,
            param: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetNamedFramebufferParameteriv({:?}, {:#X}, {:p});",
                    framebuffer,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetNamedFramebufferParameteriv",
                &self.glGetNamedFramebufferParameteriv_p,
                framebuffer,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetNamedFramebufferParameteriv");
            }
            out
        }

        pub unsafe fn GetNamedFramebufferParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetNamedFramebufferParameteriv\0",
                &self.glGetNamedFramebufferParameteriv_p,
            )
        }
        #[inline]

        pub fn GetNamedFramebufferParameteriv_is_loaded(&self) -> bool {
            !self
                .glGetNamedFramebufferParameteriv_p
                .load(RELAX)
                .is_null()
        }
        /// [glGetNamedRenderbufferParameteriv](http://docs.gl/gl4/glGetNamedRenderbufferParameter)(renderbuffer, pname, params)
        /// * `renderbuffer` class: renderbuffer
        /// * `pname` group: RenderbufferParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetNamedRenderbufferParameteriv(
            &self,
            renderbuffer: GLuint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetNamedRenderbufferParameteriv({:?}, {:#X}, {:p});",
                    renderbuffer,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetNamedRenderbufferParameteriv",
                &self.glGetNamedRenderbufferParameteriv_p,
                renderbuffer,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetNamedRenderbufferParameteriv");
            }
            out
        }

        pub unsafe fn GetNamedRenderbufferParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetNamedRenderbufferParameteriv\0",
                &self.glGetNamedRenderbufferParameteriv_p,
            )
        }
        #[inline]

        pub fn GetNamedRenderbufferParameteriv_is_loaded(&self) -> bool {
            !self
                .glGetNamedRenderbufferParameteriv_p
                .load(RELAX)
                .is_null()
        }
        /// [glGetObjectLabel](http://docs.gl/gl4/glGetObjectLabel)(identifier, name, bufSize, length, label)
        /// * `identifier` group: ObjectIdentifier
        /// * `length` len: 1
        /// * `label` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetObjectLabel(
            &self,
            identifier: GLenum,
            name: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            label: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetObjectLabel({:#X}, {:?}, {:?}, {:p}, {:p});",
                    identifier,
                    name,
                    bufSize,
                    length,
                    label
                );
            }
            let out = call_atomic_ptr_5arg(
                "glGetObjectLabel",
                &self.glGetObjectLabel_p,
                identifier,
                name,
                bufSize,
                length,
                label,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetObjectLabel");
            }
            out
        }

        pub unsafe fn GetObjectLabel_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetObjectLabel\0",
                &self.glGetObjectLabel_p,
            )
        }
        #[inline]

        pub fn GetObjectLabel_is_loaded(&self) -> bool {
            !self.glGetObjectLabel_p.load(RELAX).is_null()
        }
        /// [glGetObjectPtrLabel](http://docs.gl/gl4/glGetObjectPtrLabel)(ptr, bufSize, length, label)
        /// * `length` len: 1
        /// * `label` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetObjectPtrLabel(
            &self,
            ptr: *const c_void,
            bufSize: GLsizei,
            length: *mut GLsizei,
            label: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetObjectPtrLabel({:p}, {:?}, {:p}, {:p});",
                    ptr,
                    bufSize,
                    length,
                    label
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetObjectPtrLabel",
                &self.glGetObjectPtrLabel_p,
                ptr,
                bufSize,
                length,
                label,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetObjectPtrLabel");
            }
            out
        }

        pub unsafe fn GetObjectPtrLabel_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetObjectPtrLabel\0",
                &self.glGetObjectPtrLabel_p,
            )
        }
        #[inline]

        pub fn GetObjectPtrLabel_is_loaded(&self) -> bool {
            !self.glGetObjectPtrLabel_p.load(RELAX).is_null()
        }
        /// [glGetPointerv](http://docs.gl/gl4/glGetPointerv)(pname, params)
        /// * `pname` group: GetPointervPName
        /// * `params` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetPointerv(&self, pname: GLenum, params: *mut *mut c_void) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetPointerv({:#X}, {:p});", pname, params);
            }
            let out = call_atomic_ptr_2arg("glGetPointerv", &self.glGetPointerv_p, pname, params);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetPointerv");
            }
            out
        }

        pub unsafe fn GetPointerv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetPointerv\0", &self.glGetPointerv_p)
        }
        #[inline]

        pub fn GetPointerv_is_loaded(&self) -> bool {
            !self.glGetPointerv_p.load(RELAX).is_null()
        }
        /// [glGetProgramBinary](http://docs.gl/gl4/glGetProgramBinary)(program, bufSize, length, binaryFormat, binary)
        /// * `program` class: program
        /// * `length` len: 1
        /// * `binaryFormat` len: 1
        /// * `binary` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramBinary(
            &self,
            program: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            binaryFormat: *mut GLenum,
            binary: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetProgramBinary({:?}, {:?}, {:p}, {:p}, {:p});",
                    program,
                    bufSize,
                    length,
                    binaryFormat,
                    binary
                );
            }
            let out = call_atomic_ptr_5arg(
                "glGetProgramBinary",
                &self.glGetProgramBinary_p,
                program,
                bufSize,
                length,
                binaryFormat,
                binary,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramBinary");
            }
            out
        }

        pub unsafe fn GetProgramBinary_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramBinary\0",
                &self.glGetProgramBinary_p,
            )
        }
        #[inline]

        pub fn GetProgramBinary_is_loaded(&self) -> bool {
            !self.glGetProgramBinary_p.load(RELAX).is_null()
        }
        /// [glGetProgramInfoLog](http://docs.gl/gl4/glGetProgramInfoLog)(program, bufSize, length, infoLog)
        /// * `program` class: program
        /// * `length` len: 1
        /// * `infoLog` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramInfoLog(
            &self,
            program: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            infoLog: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetProgramInfoLog({:?}, {:?}, {:p}, {:p});",
                    program,
                    bufSize,
                    length,
                    infoLog
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetProgramInfoLog",
                &self.glGetProgramInfoLog_p,
                program,
                bufSize,
                length,
                infoLog,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramInfoLog");
            }
            out
        }

        pub unsafe fn GetProgramInfoLog_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramInfoLog\0",
                &self.glGetProgramInfoLog_p,
            )
        }
        #[inline]

        pub fn GetProgramInfoLog_is_loaded(&self) -> bool {
            !self.glGetProgramInfoLog_p.load(RELAX).is_null()
        }
        /// [glGetProgramInterfaceiv](http://docs.gl/gl4/glGetProgramInterface)(program, programInterface, pname, params)
        /// * `program` class: program
        /// * `programInterface` group: ProgramInterface
        /// * `pname` group: ProgramInterfacePName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramInterfaceiv(
            &self,
            program: GLuint,
            programInterface: GLenum,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetProgramInterfaceiv({:?}, {:#X}, {:#X}, {:p});",
                    program,
                    programInterface,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetProgramInterfaceiv",
                &self.glGetProgramInterfaceiv_p,
                program,
                programInterface,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramInterfaceiv");
            }
            out
        }

        pub unsafe fn GetProgramInterfaceiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramInterfaceiv\0",
                &self.glGetProgramInterfaceiv_p,
            )
        }
        #[inline]

        pub fn GetProgramInterfaceiv_is_loaded(&self) -> bool {
            !self.glGetProgramInterfaceiv_p.load(RELAX).is_null()
        }
        /// [glGetProgramPipelineInfoLog](http://docs.gl/gl4/glGetProgramPipelineInfoLog)(pipeline, bufSize, length, infoLog)
        /// * `pipeline` class: program pipeline
        /// * `length` len: 1
        /// * `infoLog` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramPipelineInfoLog(
            &self,
            pipeline: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            infoLog: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetProgramPipelineInfoLog({:?}, {:?}, {:p}, {:p});",
                    pipeline,
                    bufSize,
                    length,
                    infoLog
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetProgramPipelineInfoLog",
                &self.glGetProgramPipelineInfoLog_p,
                pipeline,
                bufSize,
                length,
                infoLog,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramPipelineInfoLog");
            }
            out
        }

        pub unsafe fn GetProgramPipelineInfoLog_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramPipelineInfoLog\0",
                &self.glGetProgramPipelineInfoLog_p,
            )
        }
        #[inline]

        pub fn GetProgramPipelineInfoLog_is_loaded(&self) -> bool {
            !self.glGetProgramPipelineInfoLog_p.load(RELAX).is_null()
        }
        /// [glGetProgramPipelineiv](http://docs.gl/gl4/glGetProgramPipeline)(pipeline, pname, params)
        /// * `pipeline` class: program pipeline
        /// * `pname` group: PipelineParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramPipelineiv(
            &self,
            pipeline: GLuint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetProgramPipelineiv({:?}, {:#X}, {:p});",
                    pipeline,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetProgramPipelineiv",
                &self.glGetProgramPipelineiv_p,
                pipeline,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramPipelineiv");
            }
            out
        }

        pub unsafe fn GetProgramPipelineiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramPipelineiv\0",
                &self.glGetProgramPipelineiv_p,
            )
        }
        #[inline]

        pub fn GetProgramPipelineiv_is_loaded(&self) -> bool {
            !self.glGetProgramPipelineiv_p.load(RELAX).is_null()
        }
        /// [glGetProgramResourceIndex](http://docs.gl/gl4/glGetProgramResourceIndex)(program, programInterface, name)
        /// * `program` class: program
        /// * `programInterface` group: ProgramInterface
        /// * `name` len: COMPSIZE(name)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramResourceIndex(
            &self,
            program: GLuint,
            programInterface: GLenum,
            name: *const GLchar,
        ) -> GLuint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetProgramResourceIndex({:?}, {:#X}, {:p});",
                    program,
                    programInterface,
                    name
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetProgramResourceIndex",
                &self.glGetProgramResourceIndex_p,
                program,
                programInterface,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramResourceIndex");
            }
            out
        }

        pub unsafe fn GetProgramResourceIndex_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramResourceIndex\0",
                &self.glGetProgramResourceIndex_p,
            )
        }
        #[inline]

        pub fn GetProgramResourceIndex_is_loaded(&self) -> bool {
            !self.glGetProgramResourceIndex_p.load(RELAX).is_null()
        }
        /// [glGetProgramResourceLocation](http://docs.gl/gl4/glGetProgramResourceLocation)(program, programInterface, name)
        /// * `program` class: program
        /// * `programInterface` group: ProgramInterface
        /// * `name` len: COMPSIZE(name)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramResourceLocation(
            &self,
            program: GLuint,
            programInterface: GLenum,
            name: *const GLchar,
        ) -> GLint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetProgramResourceLocation({:?}, {:#X}, {:p});",
                    program,
                    programInterface,
                    name
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetProgramResourceLocation",
                &self.glGetProgramResourceLocation_p,
                program,
                programInterface,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramResourceLocation");
            }
            out
        }

        pub unsafe fn GetProgramResourceLocation_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramResourceLocation\0",
                &self.glGetProgramResourceLocation_p,
            )
        }
        #[inline]

        pub fn GetProgramResourceLocation_is_loaded(&self) -> bool {
            !self.glGetProgramResourceLocation_p.load(RELAX).is_null()
        }
        /// [glGetProgramResourceLocationIndex](http://docs.gl/gl4/glGetProgramResourceLocationIndex)(program, programInterface, name)
        /// * `program` class: program
        /// * `programInterface` group: ProgramInterface
        /// * `name` len: COMPSIZE(name)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramResourceLocationIndex(
            &self,
            program: GLuint,
            programInterface: GLenum,
            name: *const GLchar,
        ) -> GLint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetProgramResourceLocationIndex({:?}, {:#X}, {:p});",
                    program,
                    programInterface,
                    name
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetProgramResourceLocationIndex",
                &self.glGetProgramResourceLocationIndex_p,
                program,
                programInterface,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramResourceLocationIndex");
            }
            out
        }

        pub unsafe fn GetProgramResourceLocationIndex_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramResourceLocationIndex\0",
                &self.glGetProgramResourceLocationIndex_p,
            )
        }
        #[inline]

        pub fn GetProgramResourceLocationIndex_is_loaded(&self) -> bool {
            !self
                .glGetProgramResourceLocationIndex_p
                .load(RELAX)
                .is_null()
        }
        /// [glGetProgramResourceName](http://docs.gl/gl4/glGetProgramResourceName)(program, programInterface, index, bufSize, length, name)
        /// * `program` class: program
        /// * `programInterface` group: ProgramInterface
        /// * `length` len: 1
        /// * `name` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramResourceName(
            &self,
            program: GLuint,
            programInterface: GLenum,
            index: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            name: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetProgramResourceName({:?}, {:#X}, {:?}, {:?}, {:p}, {:p});",
                    program,
                    programInterface,
                    index,
                    bufSize,
                    length,
                    name
                );
            }
            let out = call_atomic_ptr_6arg(
                "glGetProgramResourceName",
                &self.glGetProgramResourceName_p,
                program,
                programInterface,
                index,
                bufSize,
                length,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramResourceName");
            }
            out
        }

        pub unsafe fn GetProgramResourceName_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramResourceName\0",
                &self.glGetProgramResourceName_p,
            )
        }
        #[inline]

        pub fn GetProgramResourceName_is_loaded(&self) -> bool {
            !self.glGetProgramResourceName_p.load(RELAX).is_null()
        }
        /// [glGetProgramResourceiv](http://docs.gl/gl4/glGetProgramResource)(program, programInterface, index, propCount, props, count, length, params)
        /// * `program` class: program
        /// * `programInterface` group: ProgramInterface
        /// * `props` group: ProgramResourceProperty
        /// * `props` len: propCount
        /// * `length` len: 1
        /// * `params` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramResourceiv(
            &self,
            program: GLuint,
            programInterface: GLenum,
            index: GLuint,
            propCount: GLsizei,
            props: *const GLenum,
            count: GLsizei,
            length: *mut GLsizei,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetProgramResourceiv({:?}, {:#X}, {:?}, {:?}, {:p}, {:?}, {:p}, {:p});", program, programInterface, index, propCount, props, count, length, params);
            }
            let out = call_atomic_ptr_8arg(
                "glGetProgramResourceiv",
                &self.glGetProgramResourceiv_p,
                program,
                programInterface,
                index,
                propCount,
                props,
                count,
                length,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramResourceiv");
            }
            out
        }

        pub unsafe fn GetProgramResourceiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramResourceiv\0",
                &self.glGetProgramResourceiv_p,
            )
        }
        #[inline]

        pub fn GetProgramResourceiv_is_loaded(&self) -> bool {
            !self.glGetProgramResourceiv_p.load(RELAX).is_null()
        }
        /// [glGetProgramStageiv](http://docs.gl/gl4/glGetProgramStage)(program, shadertype, pname, values)
        /// * `program` class: program
        /// * `shadertype` group: ShaderType
        /// * `pname` group: ProgramStagePName
        /// * `values` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramStageiv(
            &self,
            program: GLuint,
            shadertype: GLenum,
            pname: GLenum,
            values: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetProgramStageiv({:?}, {:#X}, {:#X}, {:p});",
                    program,
                    shadertype,
                    pname,
                    values
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetProgramStageiv",
                &self.glGetProgramStageiv_p,
                program,
                shadertype,
                pname,
                values,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramStageiv");
            }
            out
        }

        pub unsafe fn GetProgramStageiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramStageiv\0",
                &self.glGetProgramStageiv_p,
            )
        }
        #[inline]

        pub fn GetProgramStageiv_is_loaded(&self) -> bool {
            !self.glGetProgramStageiv_p.load(RELAX).is_null()
        }
        /// [glGetProgramiv](http://docs.gl/gl4/glGetProgram)(program, pname, params)
        /// * `program` class: program
        /// * `pname` group: ProgramPropertyARB
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetProgramiv(&self, program: GLuint, pname: GLenum, params: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetProgramiv({:?}, {:#X}, {:p});",
                    program,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetProgramiv",
                &self.glGetProgramiv_p,
                program,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetProgramiv");
            }
            out
        }

        pub unsafe fn GetProgramiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetProgramiv\0",
                &self.glGetProgramiv_p,
            )
        }
        #[inline]

        pub fn GetProgramiv_is_loaded(&self) -> bool {
            !self.glGetProgramiv_p.load(RELAX).is_null()
        }
        /// [glGetQueryBufferObjecti64v](http://docs.gl/gl4/glGetQueryBufferObject)(id, buffer, pname, offset)
        /// * `id` class: query
        /// * `buffer` class: buffer
        /// * `pname` group: QueryObjectParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetQueryBufferObjecti64v(
            &self,
            id: GLuint,
            buffer: GLuint,
            pname: GLenum,
            offset: GLintptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetQueryBufferObjecti64v({:?}, {:?}, {:#X}, {:?});",
                    id,
                    buffer,
                    pname,
                    offset
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetQueryBufferObjecti64v",
                &self.glGetQueryBufferObjecti64v_p,
                id,
                buffer,
                pname,
                offset,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetQueryBufferObjecti64v");
            }
            out
        }

        pub unsafe fn GetQueryBufferObjecti64v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetQueryBufferObjecti64v\0",
                &self.glGetQueryBufferObjecti64v_p,
            )
        }
        #[inline]

        pub fn GetQueryBufferObjecti64v_is_loaded(&self) -> bool {
            !self.glGetQueryBufferObjecti64v_p.load(RELAX).is_null()
        }
        /// [glGetQueryBufferObjectiv](http://docs.gl/gl4/glGetQueryBufferObject)(id, buffer, pname, offset)
        /// * `id` class: query
        /// * `buffer` class: buffer
        /// * `pname` group: QueryObjectParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetQueryBufferObjectiv(
            &self,
            id: GLuint,
            buffer: GLuint,
            pname: GLenum,
            offset: GLintptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetQueryBufferObjectiv({:?}, {:?}, {:#X}, {:?});",
                    id,
                    buffer,
                    pname,
                    offset
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetQueryBufferObjectiv",
                &self.glGetQueryBufferObjectiv_p,
                id,
                buffer,
                pname,
                offset,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetQueryBufferObjectiv");
            }
            out
        }

        pub unsafe fn GetQueryBufferObjectiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetQueryBufferObjectiv\0",
                &self.glGetQueryBufferObjectiv_p,
            )
        }
        #[inline]

        pub fn GetQueryBufferObjectiv_is_loaded(&self) -> bool {
            !self.glGetQueryBufferObjectiv_p.load(RELAX).is_null()
        }
        /// [glGetQueryBufferObjectui64v](http://docs.gl/gl4/glGetQueryBufferObjectu)(id, buffer, pname, offset)
        /// * `id` class: query
        /// * `buffer` class: buffer
        /// * `pname` group: QueryObjectParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetQueryBufferObjectui64v(
            &self,
            id: GLuint,
            buffer: GLuint,
            pname: GLenum,
            offset: GLintptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetQueryBufferObjectui64v({:?}, {:?}, {:#X}, {:?});",
                    id,
                    buffer,
                    pname,
                    offset
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetQueryBufferObjectui64v",
                &self.glGetQueryBufferObjectui64v_p,
                id,
                buffer,
                pname,
                offset,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetQueryBufferObjectui64v");
            }
            out
        }

        pub unsafe fn GetQueryBufferObjectui64v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetQueryBufferObjectui64v\0",
                &self.glGetQueryBufferObjectui64v_p,
            )
        }
        #[inline]

        pub fn GetQueryBufferObjectui64v_is_loaded(&self) -> bool {
            !self.glGetQueryBufferObjectui64v_p.load(RELAX).is_null()
        }
        /// [glGetQueryBufferObjectuiv](http://docs.gl/gl4/glGetQueryBufferObject)(id, buffer, pname, offset)
        /// * `id` class: query
        /// * `buffer` class: buffer
        /// * `pname` group: QueryObjectParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetQueryBufferObjectuiv(
            &self,
            id: GLuint,
            buffer: GLuint,
            pname: GLenum,
            offset: GLintptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetQueryBufferObjectuiv({:?}, {:?}, {:#X}, {:?});",
                    id,
                    buffer,
                    pname,
                    offset
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetQueryBufferObjectuiv",
                &self.glGetQueryBufferObjectuiv_p,
                id,
                buffer,
                pname,
                offset,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetQueryBufferObjectuiv");
            }
            out
        }

        pub unsafe fn GetQueryBufferObjectuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetQueryBufferObjectuiv\0",
                &self.glGetQueryBufferObjectuiv_p,
            )
        }
        #[inline]

        pub fn GetQueryBufferObjectuiv_is_loaded(&self) -> bool {
            !self.glGetQueryBufferObjectuiv_p.load(RELAX).is_null()
        }
        /// [glGetQueryIndexediv](http://docs.gl/gl4/glGetQueryIndexed)(target, index, pname, params)
        /// * `target` group: QueryTarget
        /// * `pname` group: QueryParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetQueryIndexediv(
            &self,
            target: GLenum,
            index: GLuint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetQueryIndexediv({:#X}, {:?}, {:#X}, {:p});",
                    target,
                    index,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetQueryIndexediv",
                &self.glGetQueryIndexediv_p,
                target,
                index,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetQueryIndexediv");
            }
            out
        }

        pub unsafe fn GetQueryIndexediv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetQueryIndexediv\0",
                &self.glGetQueryIndexediv_p,
            )
        }
        #[inline]

        pub fn GetQueryIndexediv_is_loaded(&self) -> bool {
            !self.glGetQueryIndexediv_p.load(RELAX).is_null()
        }
        /// [glGetQueryObjecti64v](http://docs.gl/gl4/glGetQueryObject)(id, pname, params)
        /// * `id` class: query
        /// * `pname` group: QueryObjectParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetQueryObjecti64v(&self, id: GLuint, pname: GLenum, params: *mut GLint64) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetQueryObjecti64v({:?}, {:#X}, {:p});",
                    id,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetQueryObjecti64v",
                &self.glGetQueryObjecti64v_p,
                id,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetQueryObjecti64v");
            }
            out
        }

        pub unsafe fn GetQueryObjecti64v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetQueryObjecti64v\0",
                &self.glGetQueryObjecti64v_p,
            )
        }
        #[inline]

        pub fn GetQueryObjecti64v_is_loaded(&self) -> bool {
            !self.glGetQueryObjecti64v_p.load(RELAX).is_null()
        }
        /// [glGetQueryObjectiv](http://docs.gl/gl4/glGetQueryObject)(id, pname, params)
        /// * `id` class: query
        /// * `pname` group: QueryObjectParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetQueryObjectiv(&self, id: GLuint, pname: GLenum, params: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetQueryObjectiv({:?}, {:#X}, {:p});",
                    id,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetQueryObjectiv",
                &self.glGetQueryObjectiv_p,
                id,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetQueryObjectiv");
            }
            out
        }

        pub unsafe fn GetQueryObjectiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetQueryObjectiv\0",
                &self.glGetQueryObjectiv_p,
            )
        }
        #[inline]

        pub fn GetQueryObjectiv_is_loaded(&self) -> bool {
            !self.glGetQueryObjectiv_p.load(RELAX).is_null()
        }
        /// [glGetQueryObjectui64v](http://docs.gl/gl4/glGetQueryObjectu)(id, pname, params)
        /// * `id` class: query
        /// * `pname` group: QueryObjectParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetQueryObjectui64v(&self, id: GLuint, pname: GLenum, params: *mut GLuint64) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetQueryObjectui64v({:?}, {:#X}, {:p});",
                    id,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetQueryObjectui64v",
                &self.glGetQueryObjectui64v_p,
                id,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetQueryObjectui64v");
            }
            out
        }

        pub unsafe fn GetQueryObjectui64v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetQueryObjectui64v\0",
                &self.glGetQueryObjectui64v_p,
            )
        }
        #[inline]

        pub fn GetQueryObjectui64v_is_loaded(&self) -> bool {
            !self.glGetQueryObjectui64v_p.load(RELAX).is_null()
        }
        /// [glGetQueryObjectuiv](http://docs.gl/gl4/glGetQueryObject)(id, pname, params)
        /// * `id` class: query
        /// * `pname` group: QueryObjectParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetQueryObjectuiv(&self, id: GLuint, pname: GLenum, params: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetQueryObjectuiv({:?}, {:#X}, {:p});",
                    id,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetQueryObjectuiv",
                &self.glGetQueryObjectuiv_p,
                id,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetQueryObjectuiv");
            }
            out
        }

        pub unsafe fn GetQueryObjectuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetQueryObjectuiv\0",
                &self.glGetQueryObjectuiv_p,
            )
        }
        #[inline]

        pub fn GetQueryObjectuiv_is_loaded(&self) -> bool {
            !self.glGetQueryObjectuiv_p.load(RELAX).is_null()
        }
        /// [glGetQueryiv](http://docs.gl/gl4/glGetQuery)(target, pname, params)
        /// * `target` group: QueryTarget
        /// * `pname` group: QueryParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetQueryiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetQueryiv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out =
                call_atomic_ptr_3arg("glGetQueryiv", &self.glGetQueryiv_p, target, pname, params);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetQueryiv");
            }
            out
        }

        pub unsafe fn GetQueryiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetQueryiv\0", &self.glGetQueryiv_p)
        }
        #[inline]

        pub fn GetQueryiv_is_loaded(&self) -> bool {
            !self.glGetQueryiv_p.load(RELAX).is_null()
        }
        /// [glGetRenderbufferParameteriv](http://docs.gl/gl4/glGetRenderbufferParameter)(target, pname, params)
        /// * `target` group: RenderbufferTarget
        /// * `pname` group: RenderbufferParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetRenderbufferParameteriv(
            &self,
            target: GLenum,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetRenderbufferParameteriv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetRenderbufferParameteriv",
                &self.glGetRenderbufferParameteriv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetRenderbufferParameteriv");
            }
            out
        }

        pub unsafe fn GetRenderbufferParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetRenderbufferParameteriv\0",
                &self.glGetRenderbufferParameteriv_p,
            )
        }
        #[inline]

        pub fn GetRenderbufferParameteriv_is_loaded(&self) -> bool {
            !self.glGetRenderbufferParameteriv_p.load(RELAX).is_null()
        }
        /// [glGetSamplerParameterIiv](http://docs.gl/gl4/glGetSamplerParameter)(sampler, pname, params)
        /// * `sampler` class: sampler
        /// * `pname` group: SamplerParameterI
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetSamplerParameterIiv(
            &self,
            sampler: GLuint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetSamplerParameterIiv({:?}, {:#X}, {:p});",
                    sampler,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetSamplerParameterIiv",
                &self.glGetSamplerParameterIiv_p,
                sampler,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetSamplerParameterIiv");
            }
            out
        }

        pub unsafe fn GetSamplerParameterIiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetSamplerParameterIiv\0",
                &self.glGetSamplerParameterIiv_p,
            )
        }
        #[inline]

        pub fn GetSamplerParameterIiv_is_loaded(&self) -> bool {
            !self.glGetSamplerParameterIiv_p.load(RELAX).is_null()
        }
        /// [glGetSamplerParameterIuiv](http://docs.gl/gl4/glGetSamplerParameter)(sampler, pname, params)
        /// * `sampler` class: sampler
        /// * `pname` group: SamplerParameterI
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetSamplerParameterIuiv(
            &self,
            sampler: GLuint,
            pname: GLenum,
            params: *mut GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetSamplerParameterIuiv({:?}, {:#X}, {:p});",
                    sampler,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetSamplerParameterIuiv",
                &self.glGetSamplerParameterIuiv_p,
                sampler,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetSamplerParameterIuiv");
            }
            out
        }

        pub unsafe fn GetSamplerParameterIuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetSamplerParameterIuiv\0",
                &self.glGetSamplerParameterIuiv_p,
            )
        }
        #[inline]

        pub fn GetSamplerParameterIuiv_is_loaded(&self) -> bool {
            !self.glGetSamplerParameterIuiv_p.load(RELAX).is_null()
        }
        /// [glGetSamplerParameterfv](http://docs.gl/gl4/glGetSamplerParameter)(sampler, pname, params)
        /// * `sampler` class: sampler
        /// * `pname` group: SamplerParameterF
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetSamplerParameterfv(
            &self,
            sampler: GLuint,
            pname: GLenum,
            params: *mut GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetSamplerParameterfv({:?}, {:#X}, {:p});",
                    sampler,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetSamplerParameterfv",
                &self.glGetSamplerParameterfv_p,
                sampler,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetSamplerParameterfv");
            }
            out
        }

        pub unsafe fn GetSamplerParameterfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetSamplerParameterfv\0",
                &self.glGetSamplerParameterfv_p,
            )
        }
        #[inline]

        pub fn GetSamplerParameterfv_is_loaded(&self) -> bool {
            !self.glGetSamplerParameterfv_p.load(RELAX).is_null()
        }
        /// [glGetSamplerParameteriv](http://docs.gl/gl4/glGetSamplerParameter)(sampler, pname, params)
        /// * `sampler` class: sampler
        /// * `pname` group: SamplerParameterI
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetSamplerParameteriv(
            &self,
            sampler: GLuint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetSamplerParameteriv({:?}, {:#X}, {:p});",
                    sampler,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetSamplerParameteriv",
                &self.glGetSamplerParameteriv_p,
                sampler,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetSamplerParameteriv");
            }
            out
        }

        pub unsafe fn GetSamplerParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetSamplerParameteriv\0",
                &self.glGetSamplerParameteriv_p,
            )
        }
        #[inline]

        pub fn GetSamplerParameteriv_is_loaded(&self) -> bool {
            !self.glGetSamplerParameteriv_p.load(RELAX).is_null()
        }
        /// [glGetShaderInfoLog](http://docs.gl/gl4/glGetShaderInfoLog)(shader, bufSize, length, infoLog)
        /// * `shader` class: shader
        /// * `length` len: 1
        /// * `infoLog` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetShaderInfoLog(
            &self,
            shader: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            infoLog: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetShaderInfoLog({:?}, {:?}, {:p}, {:p});",
                    shader,
                    bufSize,
                    length,
                    infoLog
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetShaderInfoLog",
                &self.glGetShaderInfoLog_p,
                shader,
                bufSize,
                length,
                infoLog,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetShaderInfoLog");
            }
            out
        }

        pub unsafe fn GetShaderInfoLog_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetShaderInfoLog\0",
                &self.glGetShaderInfoLog_p,
            )
        }
        #[inline]

        pub fn GetShaderInfoLog_is_loaded(&self) -> bool {
            !self.glGetShaderInfoLog_p.load(RELAX).is_null()
        }
        /// [glGetShaderPrecisionFormat](http://docs.gl/gl4/glGetShaderPrecisionFormat)(shadertype, precisiontype, range, precision)
        /// * `shadertype` group: ShaderType
        /// * `precisiontype` group: PrecisionType
        /// * `range` len: 2
        /// * `precision` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetShaderPrecisionFormat(
            &self,
            shadertype: GLenum,
            precisiontype: GLenum,
            range: *mut GLint,
            precision: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetShaderPrecisionFormat({:#X}, {:#X}, {:p}, {:p});",
                    shadertype,
                    precisiontype,
                    range,
                    precision
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetShaderPrecisionFormat",
                &self.glGetShaderPrecisionFormat_p,
                shadertype,
                precisiontype,
                range,
                precision,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetShaderPrecisionFormat");
            }
            out
        }

        pub unsafe fn GetShaderPrecisionFormat_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetShaderPrecisionFormat\0",
                &self.glGetShaderPrecisionFormat_p,
            )
        }
        #[inline]

        pub fn GetShaderPrecisionFormat_is_loaded(&self) -> bool {
            !self.glGetShaderPrecisionFormat_p.load(RELAX).is_null()
        }
        /// [glGetShaderSource](http://docs.gl/gl4/glGetShaderSource)(shader, bufSize, length, source)
        /// * `shader` class: shader
        /// * `length` len: 1
        /// * `source` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetShaderSource(
            &self,
            shader: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            source: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetShaderSource({:?}, {:?}, {:p}, {:p});",
                    shader,
                    bufSize,
                    length,
                    source
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetShaderSource",
                &self.glGetShaderSource_p,
                shader,
                bufSize,
                length,
                source,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetShaderSource");
            }
            out
        }

        pub unsafe fn GetShaderSource_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetShaderSource\0",
                &self.glGetShaderSource_p,
            )
        }
        #[inline]

        pub fn GetShaderSource_is_loaded(&self) -> bool {
            !self.glGetShaderSource_p.load(RELAX).is_null()
        }
        /// [glGetShaderiv](http://docs.gl/gl4/glGetShaderiv)(shader, pname, params)
        /// * `shader` class: shader
        /// * `pname` group: ShaderParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetShaderiv(&self, shader: GLuint, pname: GLenum, params: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetShaderiv({:?}, {:#X}, {:p});",
                    shader,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetShaderiv",
                &self.glGetShaderiv_p,
                shader,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetShaderiv");
            }
            out
        }

        pub unsafe fn GetShaderiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetShaderiv\0", &self.glGetShaderiv_p)
        }
        #[inline]

        pub fn GetShaderiv_is_loaded(&self) -> bool {
            !self.glGetShaderiv_p.load(RELAX).is_null()
        }
        /// [glGetString](http://docs.gl/gl4/glGetString)(name)
        /// * `name` group: StringName
        /// * return value group: String
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetString(&self, name: GLenum) -> *const GLubyte {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetString({:#X});", name);
            }
            let out = call_atomic_ptr_1arg("glGetString", &self.glGetString_p, name);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetString");
            }
            out
        }

        pub unsafe fn GetString_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetString\0", &self.glGetString_p)
        }
        #[inline]

        pub fn GetString_is_loaded(&self) -> bool {
            !self.glGetString_p.load(RELAX).is_null()
        }
        /// [glGetStringi](http://docs.gl/gl4/glGetString)(name, index)
        /// * `name` group: StringName
        /// * return value group: String
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetStringi(&self, name: GLenum, index: GLuint) -> *const GLubyte {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetStringi({:#X}, {:?});", name, index);
            }
            let out = call_atomic_ptr_2arg("glGetStringi", &self.glGetStringi_p, name, index);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetStringi");
            }
            out
        }

        pub unsafe fn GetStringi_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetStringi\0", &self.glGetStringi_p)
        }
        #[inline]

        pub fn GetStringi_is_loaded(&self) -> bool {
            !self.glGetStringi_p.load(RELAX).is_null()
        }
        /// [glGetSubroutineIndex](http://docs.gl/gl4/glGetSubroutineIndex)(program, shadertype, name)
        /// * `program` class: program
        /// * `shadertype` group: ShaderType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetSubroutineIndex(
            &self,
            program: GLuint,
            shadertype: GLenum,
            name: *const GLchar,
        ) -> GLuint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetSubroutineIndex({:?}, {:#X}, {:p});",
                    program,
                    shadertype,
                    name
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetSubroutineIndex",
                &self.glGetSubroutineIndex_p,
                program,
                shadertype,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetSubroutineIndex");
            }
            out
        }

        pub unsafe fn GetSubroutineIndex_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetSubroutineIndex\0",
                &self.glGetSubroutineIndex_p,
            )
        }
        #[inline]

        pub fn GetSubroutineIndex_is_loaded(&self) -> bool {
            !self.glGetSubroutineIndex_p.load(RELAX).is_null()
        }
        /// [glGetSubroutineUniformLocation](http://docs.gl/gl4/glGetSubroutineUniformLocation)(program, shadertype, name)
        /// * `program` class: program
        /// * `shadertype` group: ShaderType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetSubroutineUniformLocation(
            &self,
            program: GLuint,
            shadertype: GLenum,
            name: *const GLchar,
        ) -> GLint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetSubroutineUniformLocation({:?}, {:#X}, {:p});",
                    program,
                    shadertype,
                    name
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetSubroutineUniformLocation",
                &self.glGetSubroutineUniformLocation_p,
                program,
                shadertype,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetSubroutineUniformLocation");
            }
            out
        }

        pub unsafe fn GetSubroutineUniformLocation_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetSubroutineUniformLocation\0",
                &self.glGetSubroutineUniformLocation_p,
            )
        }
        #[inline]

        pub fn GetSubroutineUniformLocation_is_loaded(&self) -> bool {
            !self.glGetSubroutineUniformLocation_p.load(RELAX).is_null()
        }
        /// [glGetSynciv](http://docs.gl/gl4/glGetSync)(sync, pname, count, length, values)
        /// * `sync` group: sync
        /// * `sync` class: sync
        /// * `pname` group: SyncParameterName
        /// * `length` len: 1
        /// * `values` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetSynciv(
            &self,
            sync: GLsync,
            pname: GLenum,
            count: GLsizei,
            length: *mut GLsizei,
            values: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetSynciv({:p}, {:#X}, {:?}, {:p}, {:p});",
                    sync,
                    pname,
                    count,
                    length,
                    values
                );
            }
            let out = call_atomic_ptr_5arg(
                "glGetSynciv",
                &self.glGetSynciv_p,
                sync,
                pname,
                count,
                length,
                values,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetSynciv");
            }
            out
        }

        pub unsafe fn GetSynciv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetSynciv\0", &self.glGetSynciv_p)
        }
        #[inline]

        pub fn GetSynciv_is_loaded(&self) -> bool {
            !self.glGetSynciv_p.load(RELAX).is_null()
        }
        /// [glGetTexImage](http://docs.gl/gl4/glGetTexImage)(target, level, format, type_, pixels)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `pixels` len: COMPSIZE(target,level,format,type)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTexImage(
            &self,
            target: GLenum,
            level: GLint,
            format: GLenum,
            type_: GLenum,
            pixels: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTexImage({:#X}, {:?}, {:#X}, {:#X}, {:p});",
                    target,
                    level,
                    format,
                    type_,
                    pixels
                );
            }
            let out = call_atomic_ptr_5arg(
                "glGetTexImage",
                &self.glGetTexImage_p,
                target,
                level,
                format,
                type_,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTexImage");
            }
            out
        }

        pub unsafe fn GetTexImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glGetTexImage\0", &self.glGetTexImage_p)
        }
        #[inline]

        pub fn GetTexImage_is_loaded(&self) -> bool {
            !self.glGetTexImage_p.load(RELAX).is_null()
        }
        /// [glGetTexLevelParameterfv](http://docs.gl/gl4/glGetTexLevelParameter)(target, level, pname, params)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `pname` group: GetTextureParameter
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTexLevelParameterfv(
            &self,
            target: GLenum,
            level: GLint,
            pname: GLenum,
            params: *mut GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTexLevelParameterfv({:#X}, {:?}, {:#X}, {:p});",
                    target,
                    level,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetTexLevelParameterfv",
                &self.glGetTexLevelParameterfv_p,
                target,
                level,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTexLevelParameterfv");
            }
            out
        }

        pub unsafe fn GetTexLevelParameterfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTexLevelParameterfv\0",
                &self.glGetTexLevelParameterfv_p,
            )
        }
        #[inline]

        pub fn GetTexLevelParameterfv_is_loaded(&self) -> bool {
            !self.glGetTexLevelParameterfv_p.load(RELAX).is_null()
        }
        /// [glGetTexLevelParameteriv](http://docs.gl/gl4/glGetTexLevelParameter)(target, level, pname, params)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `pname` group: GetTextureParameter
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTexLevelParameteriv(
            &self,
            target: GLenum,
            level: GLint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTexLevelParameteriv({:#X}, {:?}, {:#X}, {:p});",
                    target,
                    level,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetTexLevelParameteriv",
                &self.glGetTexLevelParameteriv_p,
                target,
                level,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTexLevelParameteriv");
            }
            out
        }

        pub unsafe fn GetTexLevelParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTexLevelParameteriv\0",
                &self.glGetTexLevelParameteriv_p,
            )
        }
        #[inline]

        pub fn GetTexLevelParameteriv_is_loaded(&self) -> bool {
            !self.glGetTexLevelParameteriv_p.load(RELAX).is_null()
        }
        /// [glGetTexParameterIiv](http://docs.gl/gl4/glGetTexParameter)(target, pname, params)
        /// * `target` group: TextureTarget
        /// * `pname` group: GetTextureParameter
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTexParameterIiv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetTexParameterIiv",
                &self.glGetTexParameterIiv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTexParameterIiv");
            }
            out
        }

        pub unsafe fn GetTexParameterIiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTexParameterIiv\0",
                &self.glGetTexParameterIiv_p,
            )
        }
        #[inline]

        pub fn GetTexParameterIiv_is_loaded(&self) -> bool {
            !self.glGetTexParameterIiv_p.load(RELAX).is_null()
        }
        /// [glGetTexParameterIuiv](http://docs.gl/gl4/glGetTexParameter)(target, pname, params)
        /// * `target` group: TextureTarget
        /// * `pname` group: GetTextureParameter
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTexParameterIuiv(
            &self,
            target: GLenum,
            pname: GLenum,
            params: *mut GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTexParameterIuiv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetTexParameterIuiv",
                &self.glGetTexParameterIuiv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTexParameterIuiv");
            }
            out
        }

        pub unsafe fn GetTexParameterIuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTexParameterIuiv\0",
                &self.glGetTexParameterIuiv_p,
            )
        }
        #[inline]

        pub fn GetTexParameterIuiv_is_loaded(&self) -> bool {
            !self.glGetTexParameterIuiv_p.load(RELAX).is_null()
        }
        /// [glGetTexParameterfv](http://docs.gl/gl4/glGetTexParameter)(target, pname, params)
        /// * `target` group: TextureTarget
        /// * `pname` group: GetTextureParameter
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTexParameterfv(
            &self,
            target: GLenum,
            pname: GLenum,
            params: *mut GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTexParameterfv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetTexParameterfv",
                &self.glGetTexParameterfv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTexParameterfv");
            }
            out
        }

        pub unsafe fn GetTexParameterfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTexParameterfv\0",
                &self.glGetTexParameterfv_p,
            )
        }
        #[inline]

        pub fn GetTexParameterfv_is_loaded(&self) -> bool {
            !self.glGetTexParameterfv_p.load(RELAX).is_null()
        }
        /// [glGetTexParameteriv](http://docs.gl/gl4/glGetTexParameter)(target, pname, params)
        /// * `target` group: TextureTarget
        /// * `pname` group: GetTextureParameter
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTexParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTexParameteriv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetTexParameteriv",
                &self.glGetTexParameteriv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTexParameteriv");
            }
            out
        }

        pub unsafe fn GetTexParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTexParameteriv\0",
                &self.glGetTexParameteriv_p,
            )
        }
        #[inline]

        pub fn GetTexParameteriv_is_loaded(&self) -> bool {
            !self.glGetTexParameteriv_p.load(RELAX).is_null()
        }
        /// [glGetTextureImage](http://docs.gl/gl4/glGetTextureImage)(texture, level, format, type_, bufSize, pixels)
        /// * `texture` class: texture
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTextureImage(
            &self,
            texture: GLuint,
            level: GLint,
            format: GLenum,
            type_: GLenum,
            bufSize: GLsizei,
            pixels: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTextureImage({:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});",
                    texture,
                    level,
                    format,
                    type_,
                    bufSize,
                    pixels
                );
            }
            let out = call_atomic_ptr_6arg(
                "glGetTextureImage",
                &self.glGetTextureImage_p,
                texture,
                level,
                format,
                type_,
                bufSize,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTextureImage");
            }
            out
        }

        pub unsafe fn GetTextureImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTextureImage\0",
                &self.glGetTextureImage_p,
            )
        }
        #[inline]

        pub fn GetTextureImage_is_loaded(&self) -> bool {
            !self.glGetTextureImage_p.load(RELAX).is_null()
        }
        /// [glGetTextureLevelParameterfv](http://docs.gl/gl4/glGetTextureLevelParameter)(texture, level, pname, params)
        /// * `texture` class: texture
        /// * `pname` group: GetTextureParameter
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTextureLevelParameterfv(
            &self,
            texture: GLuint,
            level: GLint,
            pname: GLenum,
            params: *mut GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTextureLevelParameterfv({:?}, {:?}, {:#X}, {:p});",
                    texture,
                    level,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetTextureLevelParameterfv",
                &self.glGetTextureLevelParameterfv_p,
                texture,
                level,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTextureLevelParameterfv");
            }
            out
        }

        pub unsafe fn GetTextureLevelParameterfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTextureLevelParameterfv\0",
                &self.glGetTextureLevelParameterfv_p,
            )
        }
        #[inline]

        pub fn GetTextureLevelParameterfv_is_loaded(&self) -> bool {
            !self.glGetTextureLevelParameterfv_p.load(RELAX).is_null()
        }
        /// [glGetTextureLevelParameteriv](http://docs.gl/gl4/glGetTextureLevelParameter)(texture, level, pname, params)
        /// * `texture` class: texture
        /// * `pname` group: GetTextureParameter
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTextureLevelParameteriv(
            &self,
            texture: GLuint,
            level: GLint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTextureLevelParameteriv({:?}, {:?}, {:#X}, {:p});",
                    texture,
                    level,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetTextureLevelParameteriv",
                &self.glGetTextureLevelParameteriv_p,
                texture,
                level,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTextureLevelParameteriv");
            }
            out
        }

        pub unsafe fn GetTextureLevelParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTextureLevelParameteriv\0",
                &self.glGetTextureLevelParameteriv_p,
            )
        }
        #[inline]

        pub fn GetTextureLevelParameteriv_is_loaded(&self) -> bool {
            !self.glGetTextureLevelParameteriv_p.load(RELAX).is_null()
        }
        /// [glGetTextureParameterIiv](http://docs.gl/gl4/glGetTextureParameter)(texture, pname, params)
        /// * `texture` class: texture
        /// * `pname` group: GetTextureParameter
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTextureParameterIiv(
            &self,
            texture: GLuint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTextureParameterIiv({:?}, {:#X}, {:p});",
                    texture,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetTextureParameterIiv",
                &self.glGetTextureParameterIiv_p,
                texture,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTextureParameterIiv");
            }
            out
        }

        pub unsafe fn GetTextureParameterIiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTextureParameterIiv\0",
                &self.glGetTextureParameterIiv_p,
            )
        }
        #[inline]

        pub fn GetTextureParameterIiv_is_loaded(&self) -> bool {
            !self.glGetTextureParameterIiv_p.load(RELAX).is_null()
        }
        /// [glGetTextureParameterIuiv](http://docs.gl/gl4/glGetTextureParameter)(texture, pname, params)
        /// * `texture` class: texture
        /// * `pname` group: GetTextureParameter
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTextureParameterIuiv(
            &self,
            texture: GLuint,
            pname: GLenum,
            params: *mut GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTextureParameterIuiv({:?}, {:#X}, {:p});",
                    texture,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetTextureParameterIuiv",
                &self.glGetTextureParameterIuiv_p,
                texture,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTextureParameterIuiv");
            }
            out
        }

        pub unsafe fn GetTextureParameterIuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTextureParameterIuiv\0",
                &self.glGetTextureParameterIuiv_p,
            )
        }
        #[inline]

        pub fn GetTextureParameterIuiv_is_loaded(&self) -> bool {
            !self.glGetTextureParameterIuiv_p.load(RELAX).is_null()
        }
        /// [glGetTextureParameterfv](http://docs.gl/gl4/glGetTextureParameter)(texture, pname, params)
        /// * `texture` class: texture
        /// * `pname` group: GetTextureParameter
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTextureParameterfv(
            &self,
            texture: GLuint,
            pname: GLenum,
            params: *mut GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTextureParameterfv({:?}, {:#X}, {:p});",
                    texture,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetTextureParameterfv",
                &self.glGetTextureParameterfv_p,
                texture,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTextureParameterfv");
            }
            out
        }

        pub unsafe fn GetTextureParameterfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTextureParameterfv\0",
                &self.glGetTextureParameterfv_p,
            )
        }
        #[inline]

        pub fn GetTextureParameterfv_is_loaded(&self) -> bool {
            !self.glGetTextureParameterfv_p.load(RELAX).is_null()
        }
        /// [glGetTextureParameteriv](http://docs.gl/gl4/glGetTextureParameter)(texture, pname, params)
        /// * `texture` class: texture
        /// * `pname` group: GetTextureParameter
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTextureParameteriv(
            &self,
            texture: GLuint,
            pname: GLenum,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTextureParameteriv({:?}, {:#X}, {:p});",
                    texture,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetTextureParameteriv",
                &self.glGetTextureParameteriv_p,
                texture,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTextureParameteriv");
            }
            out
        }

        pub unsafe fn GetTextureParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTextureParameteriv\0",
                &self.glGetTextureParameteriv_p,
            )
        }
        #[inline]

        pub fn GetTextureParameteriv_is_loaded(&self) -> bool {
            !self.glGetTextureParameteriv_p.load(RELAX).is_null()
        }
        /// [glGetTextureSubImage](http://docs.gl/gl4/glGetTextureSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, bufSize, pixels)
        /// * `texture` class: texture
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTextureSubImage(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            zoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            format: GLenum,
            type_: GLenum,
            bufSize: GLsizei,
            pixels: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetTextureSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, bufSize, pixels);
            }
            let out = call_atomic_ptr_12arg(
                "glGetTextureSubImage",
                &self.glGetTextureSubImage_p,
                texture,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                format,
                type_,
                bufSize,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTextureSubImage");
            }
            out
        }

        pub unsafe fn GetTextureSubImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTextureSubImage\0",
                &self.glGetTextureSubImage_p,
            )
        }
        #[inline]

        pub fn GetTextureSubImage_is_loaded(&self) -> bool {
            !self.glGetTextureSubImage_p.load(RELAX).is_null()
        }
        /// [glGetTransformFeedbackVarying](http://docs.gl/gl4/glGetTransformFeedbackVarying)(program, index, bufSize, length, size, type_, name)
        /// * `program` class: program
        /// * `length` len: 1
        /// * `size` len: 1
        /// * `type_` group: AttributeType
        /// * `type_` len: 1
        /// * `name` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTransformFeedbackVarying(
            &self,
            program: GLuint,
            index: GLuint,
            bufSize: GLsizei,
            length: *mut GLsizei,
            size: *mut GLsizei,
            type_: *mut GLenum,
            name: *mut GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetTransformFeedbackVarying({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});", program, index, bufSize, length, size, type_, name);
            }
            let out = call_atomic_ptr_7arg(
                "glGetTransformFeedbackVarying",
                &self.glGetTransformFeedbackVarying_p,
                program,
                index,
                bufSize,
                length,
                size,
                type_,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTransformFeedbackVarying");
            }
            out
        }

        pub unsafe fn GetTransformFeedbackVarying_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTransformFeedbackVarying\0",
                &self.glGetTransformFeedbackVarying_p,
            )
        }
        #[inline]

        pub fn GetTransformFeedbackVarying_is_loaded(&self) -> bool {
            !self.glGetTransformFeedbackVarying_p.load(RELAX).is_null()
        }
        /// [glGetTransformFeedbacki64_v](http://docs.gl/gl4/glGetTransformFeedbacki64_v)(xfb, pname, index, param)
        /// * `xfb` class: transform feedback
        /// * `pname` group: TransformFeedbackPName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTransformFeedbacki64_v(
            &self,
            xfb: GLuint,
            pname: GLenum,
            index: GLuint,
            param: *mut GLint64,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTransformFeedbacki64_v({:?}, {:#X}, {:?}, {:p});",
                    xfb,
                    pname,
                    index,
                    param
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetTransformFeedbacki64_v",
                &self.glGetTransformFeedbacki64_v_p,
                xfb,
                pname,
                index,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTransformFeedbacki64_v");
            }
            out
        }

        pub unsafe fn GetTransformFeedbacki64_v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTransformFeedbacki64_v\0",
                &self.glGetTransformFeedbacki64_v_p,
            )
        }
        #[inline]

        pub fn GetTransformFeedbacki64_v_is_loaded(&self) -> bool {
            !self.glGetTransformFeedbacki64_v_p.load(RELAX).is_null()
        }
        /// [glGetTransformFeedbacki_v](http://docs.gl/gl4/glGetTransformFeedbacki_v)(xfb, pname, index, param)
        /// * `xfb` class: transform feedback
        /// * `pname` group: TransformFeedbackPName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTransformFeedbacki_v(
            &self,
            xfb: GLuint,
            pname: GLenum,
            index: GLuint,
            param: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTransformFeedbacki_v({:?}, {:#X}, {:?}, {:p});",
                    xfb,
                    pname,
                    index,
                    param
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetTransformFeedbacki_v",
                &self.glGetTransformFeedbacki_v_p,
                xfb,
                pname,
                index,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTransformFeedbacki_v");
            }
            out
        }

        pub unsafe fn GetTransformFeedbacki_v_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTransformFeedbacki_v\0",
                &self.glGetTransformFeedbacki_v_p,
            )
        }
        #[inline]

        pub fn GetTransformFeedbacki_v_is_loaded(&self) -> bool {
            !self.glGetTransformFeedbacki_v_p.load(RELAX).is_null()
        }
        /// [glGetTransformFeedbackiv](http://docs.gl/gl4/glGetTransformFeedback)(xfb, pname, param)
        /// * `xfb` class: transform feedback
        /// * `pname` group: TransformFeedbackPName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetTransformFeedbackiv(&self, xfb: GLuint, pname: GLenum, param: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetTransformFeedbackiv({:?}, {:#X}, {:p});",
                    xfb,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetTransformFeedbackiv",
                &self.glGetTransformFeedbackiv_p,
                xfb,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetTransformFeedbackiv");
            }
            out
        }

        pub unsafe fn GetTransformFeedbackiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetTransformFeedbackiv\0",
                &self.glGetTransformFeedbackiv_p,
            )
        }
        #[inline]

        pub fn GetTransformFeedbackiv_is_loaded(&self) -> bool {
            !self.glGetTransformFeedbackiv_p.load(RELAX).is_null()
        }
        /// [glGetUniformBlockIndex](http://docs.gl/gl4/glGetUniformBlockIndex)(program, uniformBlockName)
        /// * `program` class: program
        /// * `uniformBlockName` len: COMPSIZE()
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetUniformBlockIndex(
            &self,
            program: GLuint,
            uniformBlockName: *const GLchar,
        ) -> GLuint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetUniformBlockIndex({:?}, {:p});",
                    program,
                    uniformBlockName
                );
            }
            let out = call_atomic_ptr_2arg(
                "glGetUniformBlockIndex",
                &self.glGetUniformBlockIndex_p,
                program,
                uniformBlockName,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetUniformBlockIndex");
            }
            out
        }

        pub unsafe fn GetUniformBlockIndex_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetUniformBlockIndex\0",
                &self.glGetUniformBlockIndex_p,
            )
        }
        #[inline]

        pub fn GetUniformBlockIndex_is_loaded(&self) -> bool {
            !self.glGetUniformBlockIndex_p.load(RELAX).is_null()
        }
        /// [glGetUniformIndices](http://docs.gl/gl4/glGetUniformIndices)(program, uniformCount, uniformNames, uniformIndices)
        /// * `program` class: program
        /// * `uniformNames` len: COMPSIZE(uniformCount)
        /// * `uniformIndices` len: COMPSIZE(uniformCount)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetUniformIndices(
            &self,
            program: GLuint,
            uniformCount: GLsizei,
            uniformNames: *const *const GLchar,
            uniformIndices: *mut GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetUniformIndices({:?}, {:?}, {:p}, {:p});",
                    program,
                    uniformCount,
                    uniformNames,
                    uniformIndices
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetUniformIndices",
                &self.glGetUniformIndices_p,
                program,
                uniformCount,
                uniformNames,
                uniformIndices,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetUniformIndices");
            }
            out
        }

        pub unsafe fn GetUniformIndices_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetUniformIndices\0",
                &self.glGetUniformIndices_p,
            )
        }
        #[inline]

        pub fn GetUniformIndices_is_loaded(&self) -> bool {
            !self.glGetUniformIndices_p.load(RELAX).is_null()
        }
        /// [glGetUniformLocation](http://docs.gl/gl4/glGetUniformLocation)(program, name)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetUniformLocation(&self, program: GLuint, name: *const GLchar) -> GLint {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.GetUniformLocation({:?}, {:p});", program, name);
            }
            let out = call_atomic_ptr_2arg(
                "glGetUniformLocation",
                &self.glGetUniformLocation_p,
                program,
                name,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetUniformLocation");
            }
            out
        }

        pub unsafe fn GetUniformLocation_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetUniformLocation\0",
                &self.glGetUniformLocation_p,
            )
        }
        #[inline]

        pub fn GetUniformLocation_is_loaded(&self) -> bool {
            !self.glGetUniformLocation_p.load(RELAX).is_null()
        }
        /// [glGetUniformSubroutineuiv](http://docs.gl/gl4/glGetUniformSubroutine)(shadertype, location, params)
        /// * `shadertype` group: ShaderType
        /// * `params` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetUniformSubroutineuiv(
            &self,
            shadertype: GLenum,
            location: GLint,
            params: *mut GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetUniformSubroutineuiv({:#X}, {:?}, {:p});",
                    shadertype,
                    location,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetUniformSubroutineuiv",
                &self.glGetUniformSubroutineuiv_p,
                shadertype,
                location,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetUniformSubroutineuiv");
            }
            out
        }

        pub unsafe fn GetUniformSubroutineuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetUniformSubroutineuiv\0",
                &self.glGetUniformSubroutineuiv_p,
            )
        }
        #[inline]

        pub fn GetUniformSubroutineuiv_is_loaded(&self) -> bool {
            !self.glGetUniformSubroutineuiv_p.load(RELAX).is_null()
        }
        /// [glGetUniformdv](http://docs.gl/gl4/glGetUniformdv)(program, location, params)
        /// * `program` class: program
        /// * `params` len: COMPSIZE(program,location)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetUniformdv(&self, program: GLuint, location: GLint, params: *mut GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetUniformdv({:?}, {:?}, {:p});",
                    program,
                    location,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetUniformdv",
                &self.glGetUniformdv_p,
                program,
                location,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetUniformdv");
            }
            out
        }

        pub unsafe fn GetUniformdv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetUniformdv\0",
                &self.glGetUniformdv_p,
            )
        }
        #[inline]

        pub fn GetUniformdv_is_loaded(&self) -> bool {
            !self.glGetUniformdv_p.load(RELAX).is_null()
        }
        /// [glGetUniformfv](http://docs.gl/gl4/glGetUniform)(program, location, params)
        /// * `program` class: program
        /// * `params` len: COMPSIZE(program,location)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetUniformfv(&self, program: GLuint, location: GLint, params: *mut GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetUniformfv({:?}, {:?}, {:p});",
                    program,
                    location,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetUniformfv",
                &self.glGetUniformfv_p,
                program,
                location,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetUniformfv");
            }
            out
        }

        pub unsafe fn GetUniformfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetUniformfv\0",
                &self.glGetUniformfv_p,
            )
        }
        #[inline]

        pub fn GetUniformfv_is_loaded(&self) -> bool {
            !self.glGetUniformfv_p.load(RELAX).is_null()
        }
        /// [glGetUniformiv](http://docs.gl/gl4/glGetUniform)(program, location, params)
        /// * `program` class: program
        /// * `params` len: COMPSIZE(program,location)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetUniformiv(&self, program: GLuint, location: GLint, params: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetUniformiv({:?}, {:?}, {:p});",
                    program,
                    location,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetUniformiv",
                &self.glGetUniformiv_p,
                program,
                location,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetUniformiv");
            }
            out
        }

        pub unsafe fn GetUniformiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetUniformiv\0",
                &self.glGetUniformiv_p,
            )
        }
        #[inline]

        pub fn GetUniformiv_is_loaded(&self) -> bool {
            !self.glGetUniformiv_p.load(RELAX).is_null()
        }
        /// [glGetUniformuiv](http://docs.gl/gl4/glGetUniform)(program, location, params)
        /// * `program` class: program
        /// * `params` len: COMPSIZE(program,location)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetUniformuiv(&self, program: GLuint, location: GLint, params: *mut GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetUniformuiv({:?}, {:?}, {:p});",
                    program,
                    location,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetUniformuiv",
                &self.glGetUniformuiv_p,
                program,
                location,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetUniformuiv");
            }
            out
        }

        pub unsafe fn GetUniformuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetUniformuiv\0",
                &self.glGetUniformuiv_p,
            )
        }
        #[inline]

        pub fn GetUniformuiv_is_loaded(&self) -> bool {
            !self.glGetUniformuiv_p.load(RELAX).is_null()
        }
        /// [glGetVertexArrayIndexed64iv](http://docs.gl/gl4/glGetVertexArrayIndexed6)(vaobj, index, pname, param)
        /// * `vaobj` class: vertex array
        /// * `pname` group: VertexArrayPName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetVertexArrayIndexed64iv(
            &self,
            vaobj: GLuint,
            index: GLuint,
            pname: GLenum,
            param: *mut GLint64,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetVertexArrayIndexed64iv({:?}, {:?}, {:#X}, {:p});",
                    vaobj,
                    index,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetVertexArrayIndexed64iv",
                &self.glGetVertexArrayIndexed64iv_p,
                vaobj,
                index,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetVertexArrayIndexed64iv");
            }
            out
        }

        pub unsafe fn GetVertexArrayIndexed64iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetVertexArrayIndexed64iv\0",
                &self.glGetVertexArrayIndexed64iv_p,
            )
        }
        #[inline]

        pub fn GetVertexArrayIndexed64iv_is_loaded(&self) -> bool {
            !self.glGetVertexArrayIndexed64iv_p.load(RELAX).is_null()
        }
        /// [glGetVertexArrayIndexediv](http://docs.gl/gl4/glGetVertexArrayIndexed)(vaobj, index, pname, param)
        /// * `vaobj` class: vertex array
        /// * `pname` group: VertexArrayPName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetVertexArrayIndexediv(
            &self,
            vaobj: GLuint,
            index: GLuint,
            pname: GLenum,
            param: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetVertexArrayIndexediv({:?}, {:?}, {:#X}, {:p});",
                    vaobj,
                    index,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetVertexArrayIndexediv",
                &self.glGetVertexArrayIndexediv_p,
                vaobj,
                index,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetVertexArrayIndexediv");
            }
            out
        }

        pub unsafe fn GetVertexArrayIndexediv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetVertexArrayIndexediv\0",
                &self.glGetVertexArrayIndexediv_p,
            )
        }
        #[inline]

        pub fn GetVertexArrayIndexediv_is_loaded(&self) -> bool {
            !self.glGetVertexArrayIndexediv_p.load(RELAX).is_null()
        }
        /// [glGetVertexArrayiv](http://docs.gl/gl4/glGetVertexArray)(vaobj, pname, param)
        /// * `vaobj` class: vertex array
        /// * `pname` group: VertexArrayPName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetVertexArrayiv(&self, vaobj: GLuint, pname: GLenum, param: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetVertexArrayiv({:?}, {:#X}, {:p});",
                    vaobj,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetVertexArrayiv",
                &self.glGetVertexArrayiv_p,
                vaobj,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetVertexArrayiv");
            }
            out
        }

        pub unsafe fn GetVertexArrayiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetVertexArrayiv\0",
                &self.glGetVertexArrayiv_p,
            )
        }
        #[inline]

        pub fn GetVertexArrayiv_is_loaded(&self) -> bool {
            !self.glGetVertexArrayiv_p.load(RELAX).is_null()
        }
        /// [glGetVertexAttribIiv](http://docs.gl/gl4/glGetVertexAttrib)(index, pname, params)
        /// * `pname` group: VertexAttribEnum
        /// * `params` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetVertexAttribIiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetVertexAttribIiv({:?}, {:#X}, {:p});",
                    index,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetVertexAttribIiv",
                &self.glGetVertexAttribIiv_p,
                index,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetVertexAttribIiv");
            }
            out
        }

        pub unsafe fn GetVertexAttribIiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetVertexAttribIiv\0",
                &self.glGetVertexAttribIiv_p,
            )
        }
        #[inline]

        pub fn GetVertexAttribIiv_is_loaded(&self) -> bool {
            !self.glGetVertexAttribIiv_p.load(RELAX).is_null()
        }
        /// [glGetVertexAttribIuiv](http://docs.gl/gl4/glGetVertexAttrib)(index, pname, params)
        /// * `pname` group: VertexAttribEnum
        /// * `params` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetVertexAttribIuiv(
            &self,
            index: GLuint,
            pname: GLenum,
            params: *mut GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetVertexAttribIuiv({:?}, {:#X}, {:p});",
                    index,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetVertexAttribIuiv",
                &self.glGetVertexAttribIuiv_p,
                index,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetVertexAttribIuiv");
            }
            out
        }

        pub unsafe fn GetVertexAttribIuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetVertexAttribIuiv\0",
                &self.glGetVertexAttribIuiv_p,
            )
        }
        #[inline]

        pub fn GetVertexAttribIuiv_is_loaded(&self) -> bool {
            !self.glGetVertexAttribIuiv_p.load(RELAX).is_null()
        }
        /// [glGetVertexAttribLdv](http://docs.gl/gl4/glGetVertexAttribLdv)(index, pname, params)
        /// * `pname` group: VertexAttribEnum
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetVertexAttribLdv(
            &self,
            index: GLuint,
            pname: GLenum,
            params: *mut GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetVertexAttribLdv({:?}, {:#X}, {:p});",
                    index,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetVertexAttribLdv",
                &self.glGetVertexAttribLdv_p,
                index,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetVertexAttribLdv");
            }
            out
        }

        pub unsafe fn GetVertexAttribLdv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetVertexAttribLdv\0",
                &self.glGetVertexAttribLdv_p,
            )
        }
        #[inline]

        pub fn GetVertexAttribLdv_is_loaded(&self) -> bool {
            !self.glGetVertexAttribLdv_p.load(RELAX).is_null()
        }
        /// [glGetVertexAttribPointerv](http://docs.gl/gl4/glGetVertexAttribPointerv)(index, pname, pointer)
        /// * `pname` group: VertexAttribPointerPropertyARB
        /// * `pointer` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetVertexAttribPointerv(
            &self,
            index: GLuint,
            pname: GLenum,
            pointer: *mut *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetVertexAttribPointerv({:?}, {:#X}, {:p});",
                    index,
                    pname,
                    pointer
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetVertexAttribPointerv",
                &self.glGetVertexAttribPointerv_p,
                index,
                pname,
                pointer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetVertexAttribPointerv");
            }
            out
        }

        pub unsafe fn GetVertexAttribPointerv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetVertexAttribPointerv\0",
                &self.glGetVertexAttribPointerv_p,
            )
        }
        #[inline]

        pub fn GetVertexAttribPointerv_is_loaded(&self) -> bool {
            !self.glGetVertexAttribPointerv_p.load(RELAX).is_null()
        }
        /// [glGetVertexAttribdv](http://docs.gl/gl4/glGetVertexAttribdv)(index, pname, params)
        /// * `pname` group: VertexAttribPropertyARB
        /// * `params` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetVertexAttribdv(
            &self,
            index: GLuint,
            pname: GLenum,
            params: *mut GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetVertexAttribdv({:?}, {:#X}, {:p});",
                    index,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetVertexAttribdv",
                &self.glGetVertexAttribdv_p,
                index,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetVertexAttribdv");
            }
            out
        }

        pub unsafe fn GetVertexAttribdv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetVertexAttribdv\0",
                &self.glGetVertexAttribdv_p,
            )
        }
        #[inline]

        pub fn GetVertexAttribdv_is_loaded(&self) -> bool {
            !self.glGetVertexAttribdv_p.load(RELAX).is_null()
        }
        /// [glGetVertexAttribfv](http://docs.gl/gl4/glGetVertexAttrib)(index, pname, params)
        /// * `pname` group: VertexAttribPropertyARB
        /// * `params` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetVertexAttribfv(&self, index: GLuint, pname: GLenum, params: *mut GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetVertexAttribfv({:?}, {:#X}, {:p});",
                    index,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetVertexAttribfv",
                &self.glGetVertexAttribfv_p,
                index,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetVertexAttribfv");
            }
            out
        }

        pub unsafe fn GetVertexAttribfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetVertexAttribfv\0",
                &self.glGetVertexAttribfv_p,
            )
        }
        #[inline]

        pub fn GetVertexAttribfv_is_loaded(&self) -> bool {
            !self.glGetVertexAttribfv_p.load(RELAX).is_null()
        }
        /// [glGetVertexAttribiv](http://docs.gl/gl4/glGetVertexAttrib)(index, pname, params)
        /// * `pname` group: VertexAttribPropertyARB
        /// * `params` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetVertexAttribiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetVertexAttribiv({:?}, {:#X}, {:p});",
                    index,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glGetVertexAttribiv",
                &self.glGetVertexAttribiv_p,
                index,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetVertexAttribiv");
            }
            out
        }

        pub unsafe fn GetVertexAttribiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetVertexAttribiv\0",
                &self.glGetVertexAttribiv_p,
            )
        }
        #[inline]

        pub fn GetVertexAttribiv_is_loaded(&self) -> bool {
            !self.glGetVertexAttribiv_p.load(RELAX).is_null()
        }
        /// [glGetnCompressedTexImage](http://docs.gl/gl4/glGetnCompressedTexImage)(target, lod, bufSize, pixels)
        /// * `target` group: TextureTarget
        /// * `pixels` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetnCompressedTexImage(
            &self,
            target: GLenum,
            lod: GLint,
            bufSize: GLsizei,
            pixels: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetnCompressedTexImage({:#X}, {:?}, {:?}, {:p});",
                    target,
                    lod,
                    bufSize,
                    pixels
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetnCompressedTexImage",
                &self.glGetnCompressedTexImage_p,
                target,
                lod,
                bufSize,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetnCompressedTexImage");
            }
            out
        }

        pub unsafe fn GetnCompressedTexImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetnCompressedTexImage\0",
                &self.glGetnCompressedTexImage_p,
            )
        }
        #[inline]

        pub fn GetnCompressedTexImage_is_loaded(&self) -> bool {
            !self.glGetnCompressedTexImage_p.load(RELAX).is_null()
        }
        /// [glGetnTexImage](http://docs.gl/gl4/glGetnTexImage)(target, level, format, type_, bufSize, pixels)
        /// * `target` group: TextureTarget
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `pixels` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetnTexImage(
            &self,
            target: GLenum,
            level: GLint,
            format: GLenum,
            type_: GLenum,
            bufSize: GLsizei,
            pixels: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetnTexImage({:#X}, {:?}, {:#X}, {:#X}, {:?}, {:p});",
                    target,
                    level,
                    format,
                    type_,
                    bufSize,
                    pixels
                );
            }
            let out = call_atomic_ptr_6arg(
                "glGetnTexImage",
                &self.glGetnTexImage_p,
                target,
                level,
                format,
                type_,
                bufSize,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetnTexImage");
            }
            out
        }

        pub unsafe fn GetnTexImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetnTexImage\0",
                &self.glGetnTexImage_p,
            )
        }
        #[inline]

        pub fn GetnTexImage_is_loaded(&self) -> bool {
            !self.glGetnTexImage_p.load(RELAX).is_null()
        }
        /// [glGetnUniformdv](http://docs.gl/gl4/glGetnUniformdv)(program, location, bufSize, params)
        /// * `program` class: program
        /// * `params` len: bufSize / 8
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetnUniformdv(
            &self,
            program: GLuint,
            location: GLint,
            bufSize: GLsizei,
            params: *mut GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetnUniformdv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    bufSize,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetnUniformdv",
                &self.glGetnUniformdv_p,
                program,
                location,
                bufSize,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetnUniformdv");
            }
            out
        }

        pub unsafe fn GetnUniformdv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetnUniformdv\0",
                &self.glGetnUniformdv_p,
            )
        }
        #[inline]

        pub fn GetnUniformdv_is_loaded(&self) -> bool {
            !self.glGetnUniformdv_p.load(RELAX).is_null()
        }
        /// [glGetnUniformfv](http://docs.gl/gl4/glGetnUniform)(program, location, bufSize, params)
        /// * `program` class: program
        /// * `params` len: bufSize / 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetnUniformfv(
            &self,
            program: GLuint,
            location: GLint,
            bufSize: GLsizei,
            params: *mut GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetnUniformfv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    bufSize,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetnUniformfv",
                &self.glGetnUniformfv_p,
                program,
                location,
                bufSize,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetnUniformfv");
            }
            out
        }

        pub unsafe fn GetnUniformfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetnUniformfv\0",
                &self.glGetnUniformfv_p,
            )
        }
        #[inline]

        pub fn GetnUniformfv_is_loaded(&self) -> bool {
            !self.glGetnUniformfv_p.load(RELAX).is_null()
        }
        /// [glGetnUniformiv](http://docs.gl/gl4/glGetnUniform)(program, location, bufSize, params)
        /// * `program` class: program
        /// * `params` len: bufSize / 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetnUniformiv(
            &self,
            program: GLuint,
            location: GLint,
            bufSize: GLsizei,
            params: *mut GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetnUniformiv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    bufSize,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetnUniformiv",
                &self.glGetnUniformiv_p,
                program,
                location,
                bufSize,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetnUniformiv");
            }
            out
        }

        pub unsafe fn GetnUniformiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetnUniformiv\0",
                &self.glGetnUniformiv_p,
            )
        }
        #[inline]

        pub fn GetnUniformiv_is_loaded(&self) -> bool {
            !self.glGetnUniformiv_p.load(RELAX).is_null()
        }
        /// [glGetnUniformuiv](http://docs.gl/gl4/glGetnUniform)(program, location, bufSize, params)
        /// * `program` class: program
        /// * `params` len: bufSize / 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn GetnUniformuiv(
            &self,
            program: GLuint,
            location: GLint,
            bufSize: GLsizei,
            params: *mut GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.GetnUniformuiv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    bufSize,
                    params
                );
            }
            let out = call_atomic_ptr_4arg(
                "glGetnUniformuiv",
                &self.glGetnUniformuiv_p,
                program,
                location,
                bufSize,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glGetnUniformuiv");
            }
            out
        }

        pub unsafe fn GetnUniformuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glGetnUniformuiv\0",
                &self.glGetnUniformuiv_p,
            )
        }
        #[inline]

        pub fn GetnUniformuiv_is_loaded(&self) -> bool {
            !self.glGetnUniformuiv_p.load(RELAX).is_null()
        }
        /// [glHint](http://docs.gl/gl4/glHint)(target, mode)
        /// * `target` group: HintTarget
        /// * `mode` group: HintMode
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Hint(&self, target: GLenum, mode: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Hint({:#X}, {:#X});", target, mode);
            }
            let out = call_atomic_ptr_2arg("glHint", &self.glHint_p, target, mode);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glHint");
            }
            out
        }

        pub unsafe fn Hint_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glHint\0", &self.glHint_p)
        }
        #[inline]

        pub fn Hint_is_loaded(&self) -> bool {
            !self.glHint_p.load(RELAX).is_null()
        }
        /// [glInvalidateBufferData](http://docs.gl/gl4/glInvalidateBufferData)(buffer)
        /// * `buffer` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn InvalidateBufferData(&self, buffer: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.InvalidateBufferData({:?});", buffer);
            }
            let out = call_atomic_ptr_1arg(
                "glInvalidateBufferData",
                &self.glInvalidateBufferData_p,
                buffer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glInvalidateBufferData");
            }
            out
        }

        pub unsafe fn InvalidateBufferData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glInvalidateBufferData\0",
                &self.glInvalidateBufferData_p,
            )
        }
        #[inline]

        pub fn InvalidateBufferData_is_loaded(&self) -> bool {
            !self.glInvalidateBufferData_p.load(RELAX).is_null()
        }
        /// [glInvalidateBufferSubData](http://docs.gl/gl4/glInvalidateBufferSubData)(buffer, offset, length)
        /// * `buffer` class: buffer
        /// * `offset` group: BufferOffset
        /// * `length` group: BufferSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn InvalidateBufferSubData(
            &self,
            buffer: GLuint,
            offset: GLintptr,
            length: GLsizeiptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.InvalidateBufferSubData({:?}, {:?}, {:?});",
                    buffer,
                    offset,
                    length
                );
            }
            let out = call_atomic_ptr_3arg(
                "glInvalidateBufferSubData",
                &self.glInvalidateBufferSubData_p,
                buffer,
                offset,
                length,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glInvalidateBufferSubData");
            }
            out
        }

        pub unsafe fn InvalidateBufferSubData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glInvalidateBufferSubData\0",
                &self.glInvalidateBufferSubData_p,
            )
        }
        #[inline]

        pub fn InvalidateBufferSubData_is_loaded(&self) -> bool {
            !self.glInvalidateBufferSubData_p.load(RELAX).is_null()
        }
        /// [glInvalidateFramebuffer](http://docs.gl/gl4/glInvalidateFramebuffer)(target, numAttachments, attachments)
        /// * `target` group: FramebufferTarget
        /// * `attachments` group: InvalidateFramebufferAttachment
        /// * `attachments` len: numAttachments
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn InvalidateFramebuffer(
            &self,
            target: GLenum,
            numAttachments: GLsizei,
            attachments: *const GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.InvalidateFramebuffer({:#X}, {:?}, {:p});",
                    target,
                    numAttachments,
                    attachments
                );
            }
            let out = call_atomic_ptr_3arg(
                "glInvalidateFramebuffer",
                &self.glInvalidateFramebuffer_p,
                target,
                numAttachments,
                attachments,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glInvalidateFramebuffer");
            }
            out
        }

        pub unsafe fn InvalidateFramebuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glInvalidateFramebuffer\0",
                &self.glInvalidateFramebuffer_p,
            )
        }
        #[inline]

        pub fn InvalidateFramebuffer_is_loaded(&self) -> bool {
            !self.glInvalidateFramebuffer_p.load(RELAX).is_null()
        }
        /// [glInvalidateNamedFramebufferData](http://docs.gl/gl4/glInvalidateNamedFramebufferData)(framebuffer, numAttachments, attachments)
        /// * `framebuffer` class: framebuffer
        /// * `attachments` group: FramebufferAttachment
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn InvalidateNamedFramebufferData(
            &self,
            framebuffer: GLuint,
            numAttachments: GLsizei,
            attachments: *const GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.InvalidateNamedFramebufferData({:?}, {:?}, {:p});",
                    framebuffer,
                    numAttachments,
                    attachments
                );
            }
            let out = call_atomic_ptr_3arg(
                "glInvalidateNamedFramebufferData",
                &self.glInvalidateNamedFramebufferData_p,
                framebuffer,
                numAttachments,
                attachments,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glInvalidateNamedFramebufferData");
            }
            out
        }

        pub unsafe fn InvalidateNamedFramebufferData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glInvalidateNamedFramebufferData\0",
                &self.glInvalidateNamedFramebufferData_p,
            )
        }
        #[inline]

        pub fn InvalidateNamedFramebufferData_is_loaded(&self) -> bool {
            !self
                .glInvalidateNamedFramebufferData_p
                .load(RELAX)
                .is_null()
        }
        /// [glInvalidateNamedFramebufferSubData](http://docs.gl/gl4/glInvalidateNamedFramebufferSubData)(framebuffer, numAttachments, attachments, x, y, width, height)
        /// * `framebuffer` class: framebuffer
        /// * `attachments` group: FramebufferAttachment
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn InvalidateNamedFramebufferSubData(
            &self,
            framebuffer: GLuint,
            numAttachments: GLsizei,
            attachments: *const GLenum,
            x: GLint,
            y: GLint,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.InvalidateNamedFramebufferSubData({:?}, {:?}, {:p}, {:?}, {:?}, {:?}, {:?});", framebuffer, numAttachments, attachments, x, y, width, height);
            }
            let out = call_atomic_ptr_7arg(
                "glInvalidateNamedFramebufferSubData",
                &self.glInvalidateNamedFramebufferSubData_p,
                framebuffer,
                numAttachments,
                attachments,
                x,
                y,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glInvalidateNamedFramebufferSubData");
            }
            out
        }

        pub unsafe fn InvalidateNamedFramebufferSubData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glInvalidateNamedFramebufferSubData\0",
                &self.glInvalidateNamedFramebufferSubData_p,
            )
        }
        #[inline]

        pub fn InvalidateNamedFramebufferSubData_is_loaded(&self) -> bool {
            !self
                .glInvalidateNamedFramebufferSubData_p
                .load(RELAX)
                .is_null()
        }
        /// [glInvalidateSubFramebuffer](http://docs.gl/gl4/glInvalidateSubFramebuffer)(target, numAttachments, attachments, x, y, width, height)
        /// * `target` group: FramebufferTarget
        /// * `attachments` group: InvalidateFramebufferAttachment
        /// * `attachments` len: numAttachments
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn InvalidateSubFramebuffer(
            &self,
            target: GLenum,
            numAttachments: GLsizei,
            attachments: *const GLenum,
            x: GLint,
            y: GLint,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.InvalidateSubFramebuffer({:#X}, {:?}, {:p}, {:?}, {:?}, {:?}, {:?});", target, numAttachments, attachments, x, y, width, height);
            }
            let out = call_atomic_ptr_7arg(
                "glInvalidateSubFramebuffer",
                &self.glInvalidateSubFramebuffer_p,
                target,
                numAttachments,
                attachments,
                x,
                y,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glInvalidateSubFramebuffer");
            }
            out
        }

        pub unsafe fn InvalidateSubFramebuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glInvalidateSubFramebuffer\0",
                &self.glInvalidateSubFramebuffer_p,
            )
        }
        #[inline]

        pub fn InvalidateSubFramebuffer_is_loaded(&self) -> bool {
            !self.glInvalidateSubFramebuffer_p.load(RELAX).is_null()
        }
        /// [glInvalidateTexImage](http://docs.gl/gl4/glInvalidateTexImage)(texture, level)
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn InvalidateTexImage(&self, texture: GLuint, level: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.InvalidateTexImage({:?}, {:?});", texture, level);
            }
            let out = call_atomic_ptr_2arg(
                "glInvalidateTexImage",
                &self.glInvalidateTexImage_p,
                texture,
                level,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glInvalidateTexImage");
            }
            out
        }

        pub unsafe fn InvalidateTexImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glInvalidateTexImage\0",
                &self.glInvalidateTexImage_p,
            )
        }
        #[inline]

        pub fn InvalidateTexImage_is_loaded(&self) -> bool {
            !self.glInvalidateTexImage_p.load(RELAX).is_null()
        }
        /// [glInvalidateTexSubImage](http://docs.gl/gl4/glInvalidateTexSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth)
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn InvalidateTexSubImage(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            zoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.InvalidateTexSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", texture, level, xoffset, yoffset, zoffset, width, height, depth);
            }
            let out = call_atomic_ptr_8arg(
                "glInvalidateTexSubImage",
                &self.glInvalidateTexSubImage_p,
                texture,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glInvalidateTexSubImage");
            }
            out
        }

        pub unsafe fn InvalidateTexSubImage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glInvalidateTexSubImage\0",
                &self.glInvalidateTexSubImage_p,
            )
        }
        #[inline]

        pub fn InvalidateTexSubImage_is_loaded(&self) -> bool {
            !self.glInvalidateTexSubImage_p.load(RELAX).is_null()
        }
        /// [glIsBuffer](http://docs.gl/gl4/glIsBuffer)(buffer)
        /// * `buffer` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsBuffer(&self, buffer: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsBuffer({:?});", buffer);
            }
            let out = call_atomic_ptr_1arg("glIsBuffer", &self.glIsBuffer_p, buffer);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsBuffer");
            }
            out
        }

        pub unsafe fn IsBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glIsBuffer\0", &self.glIsBuffer_p)
        }
        #[inline]

        pub fn IsBuffer_is_loaded(&self) -> bool {
            !self.glIsBuffer_p.load(RELAX).is_null()
        }
        /// [glIsEnabled](http://docs.gl/gl4/glIsEnabled)(cap)
        /// * `cap` group: EnableCap
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsEnabled(&self, cap: GLenum) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsEnabled({:#X});", cap);
            }
            let out = call_atomic_ptr_1arg("glIsEnabled", &self.glIsEnabled_p, cap);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsEnabled");
            }
            out
        }

        pub unsafe fn IsEnabled_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glIsEnabled\0", &self.glIsEnabled_p)
        }
        #[inline]

        pub fn IsEnabled_is_loaded(&self) -> bool {
            !self.glIsEnabled_p.load(RELAX).is_null()
        }
        /// [glIsEnabledi](http://docs.gl/gl4/glIsEnabled)(target, index)
        /// * `target` group: EnableCap
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsEnabledi(&self, target: GLenum, index: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsEnabledi({:#X}, {:?});", target, index);
            }
            let out = call_atomic_ptr_2arg("glIsEnabledi", &self.glIsEnabledi_p, target, index);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsEnabledi");
            }
            out
        }

        pub unsafe fn IsEnabledi_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glIsEnabledi\0", &self.glIsEnabledi_p)
        }
        #[inline]

        pub fn IsEnabledi_is_loaded(&self) -> bool {
            !self.glIsEnabledi_p.load(RELAX).is_null()
        }
        /// [glIsFramebuffer](http://docs.gl/gl4/glIsFramebuffer)(framebuffer)
        /// * `framebuffer` class: framebuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsFramebuffer(&self, framebuffer: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsFramebuffer({:?});", framebuffer);
            }
            let out = call_atomic_ptr_1arg("glIsFramebuffer", &self.glIsFramebuffer_p, framebuffer);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsFramebuffer");
            }
            out
        }

        pub unsafe fn IsFramebuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glIsFramebuffer\0",
                &self.glIsFramebuffer_p,
            )
        }
        #[inline]

        pub fn IsFramebuffer_is_loaded(&self) -> bool {
            !self.glIsFramebuffer_p.load(RELAX).is_null()
        }
        /// [glIsProgram](http://docs.gl/gl4/glIsProgram)(program)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsProgram(&self, program: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsProgram({:?});", program);
            }
            let out = call_atomic_ptr_1arg("glIsProgram", &self.glIsProgram_p, program);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsProgram");
            }
            out
        }

        pub unsafe fn IsProgram_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glIsProgram\0", &self.glIsProgram_p)
        }
        #[inline]

        pub fn IsProgram_is_loaded(&self) -> bool {
            !self.glIsProgram_p.load(RELAX).is_null()
        }
        /// [glIsProgramPipeline](http://docs.gl/gl4/glIsProgramPipeline)(pipeline)
        /// * `pipeline` class: program pipeline
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsProgramPipeline(&self, pipeline: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsProgramPipeline({:?});", pipeline);
            }
            let out =
                call_atomic_ptr_1arg("glIsProgramPipeline", &self.glIsProgramPipeline_p, pipeline);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsProgramPipeline");
            }
            out
        }

        pub unsafe fn IsProgramPipeline_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glIsProgramPipeline\0",
                &self.glIsProgramPipeline_p,
            )
        }
        #[inline]

        pub fn IsProgramPipeline_is_loaded(&self) -> bool {
            !self.glIsProgramPipeline_p.load(RELAX).is_null()
        }
        /// [glIsQuery](http://docs.gl/gl4/glIsQuery)(id)
        /// * `id` class: query
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsQuery(&self, id: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsQuery({:?});", id);
            }
            let out = call_atomic_ptr_1arg("glIsQuery", &self.glIsQuery_p, id);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsQuery");
            }
            out
        }

        pub unsafe fn IsQuery_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glIsQuery\0", &self.glIsQuery_p)
        }
        #[inline]

        pub fn IsQuery_is_loaded(&self) -> bool {
            !self.glIsQuery_p.load(RELAX).is_null()
        }
        /// [glIsRenderbuffer](http://docs.gl/gl4/glIsRenderbuffer)(renderbuffer)
        /// * `renderbuffer` class: renderbuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsRenderbuffer(&self, renderbuffer: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsRenderbuffer({:?});", renderbuffer);
            }
            let out =
                call_atomic_ptr_1arg("glIsRenderbuffer", &self.glIsRenderbuffer_p, renderbuffer);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsRenderbuffer");
            }
            out
        }

        pub unsafe fn IsRenderbuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glIsRenderbuffer\0",
                &self.glIsRenderbuffer_p,
            )
        }
        #[inline]

        pub fn IsRenderbuffer_is_loaded(&self) -> bool {
            !self.glIsRenderbuffer_p.load(RELAX).is_null()
        }
        /// [glIsSampler](http://docs.gl/gl4/glIsSampler)(sampler)
        /// * `sampler` class: sampler
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsSampler(&self, sampler: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsSampler({:?});", sampler);
            }
            let out = call_atomic_ptr_1arg("glIsSampler", &self.glIsSampler_p, sampler);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsSampler");
            }
            out
        }

        pub unsafe fn IsSampler_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glIsSampler\0", &self.glIsSampler_p)
        }
        #[inline]

        pub fn IsSampler_is_loaded(&self) -> bool {
            !self.glIsSampler_p.load(RELAX).is_null()
        }
        /// [glIsShader](http://docs.gl/gl4/glIsShader)(shader)
        /// * `shader` class: shader
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsShader(&self, shader: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsShader({:?});", shader);
            }
            let out = call_atomic_ptr_1arg("glIsShader", &self.glIsShader_p, shader);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsShader");
            }
            out
        }

        pub unsafe fn IsShader_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glIsShader\0", &self.glIsShader_p)
        }
        #[inline]

        pub fn IsShader_is_loaded(&self) -> bool {
            !self.glIsShader_p.load(RELAX).is_null()
        }
        /// [glIsSync](http://docs.gl/gl4/glIsSync)(sync)
        /// * `sync` group: sync
        /// * `sync` class: sync
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsSync(&self, sync: GLsync) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsSync({:p});", sync);
            }
            let out = call_atomic_ptr_1arg("glIsSync", &self.glIsSync_p, sync);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsSync");
            }
            out
        }

        pub unsafe fn IsSync_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glIsSync\0", &self.glIsSync_p)
        }
        #[inline]

        pub fn IsSync_is_loaded(&self) -> bool {
            !self.glIsSync_p.load(RELAX).is_null()
        }
        /// [glIsTexture](http://docs.gl/gl4/glIsTexture)(texture)
        /// * `texture` group: Texture
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsTexture(&self, texture: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsTexture({:?});", texture);
            }
            let out = call_atomic_ptr_1arg("glIsTexture", &self.glIsTexture_p, texture);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsTexture");
            }
            out
        }

        pub unsafe fn IsTexture_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glIsTexture\0", &self.glIsTexture_p)
        }
        #[inline]

        pub fn IsTexture_is_loaded(&self) -> bool {
            !self.glIsTexture_p.load(RELAX).is_null()
        }
        /// [glIsTransformFeedback](http://docs.gl/gl4/glIsTransformFeedback)(id)
        /// * `id` class: transform feedback
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsTransformFeedback(&self, id: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsTransformFeedback({:?});", id);
            }
            let out =
                call_atomic_ptr_1arg("glIsTransformFeedback", &self.glIsTransformFeedback_p, id);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsTransformFeedback");
            }
            out
        }

        pub unsafe fn IsTransformFeedback_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glIsTransformFeedback\0",
                &self.glIsTransformFeedback_p,
            )
        }
        #[inline]

        pub fn IsTransformFeedback_is_loaded(&self) -> bool {
            !self.glIsTransformFeedback_p.load(RELAX).is_null()
        }
        /// [glIsVertexArray](http://docs.gl/gl4/glIsVertexArray)(array)
        /// * `array` class: vertex array
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn IsVertexArray(&self, array: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.IsVertexArray({:?});", array);
            }
            let out = call_atomic_ptr_1arg("glIsVertexArray", &self.glIsVertexArray_p, array);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glIsVertexArray");
            }
            out
        }

        pub unsafe fn IsVertexArray_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glIsVertexArray\0",
                &self.glIsVertexArray_p,
            )
        }
        #[inline]

        pub fn IsVertexArray_is_loaded(&self) -> bool {
            !self.glIsVertexArray_p.load(RELAX).is_null()
        }
        /// [glLineWidth](http://docs.gl/gl4/glLineWidth)(width)
        /// * `width` group: CheckedFloat32
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn LineWidth(&self, width: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.LineWidth({:?});", width);
            }
            let out = call_atomic_ptr_1arg("glLineWidth", &self.glLineWidth_p, width);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glLineWidth");
            }
            out
        }

        pub unsafe fn LineWidth_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glLineWidth\0", &self.glLineWidth_p)
        }
        #[inline]

        pub fn LineWidth_is_loaded(&self) -> bool {
            !self.glLineWidth_p.load(RELAX).is_null()
        }
        /// [glLinkProgram](http://docs.gl/gl4/glLinkProgram)(program)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn LinkProgram(&self, program: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.LinkProgram({:?});", program);
            }
            let out = call_atomic_ptr_1arg("glLinkProgram", &self.glLinkProgram_p, program);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glLinkProgram");
            }
            out
        }

        pub unsafe fn LinkProgram_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glLinkProgram\0", &self.glLinkProgram_p)
        }
        #[inline]

        pub fn LinkProgram_is_loaded(&self) -> bool {
            !self.glLinkProgram_p.load(RELAX).is_null()
        }
        /// [glLogicOp](http://docs.gl/gl4/glLogicOp)(opcode)
        /// * `opcode` group: LogicOp
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn LogicOp(&self, opcode: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.LogicOp({:#X});", opcode);
            }
            let out = call_atomic_ptr_1arg("glLogicOp", &self.glLogicOp_p, opcode);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glLogicOp");
            }
            out
        }

        pub unsafe fn LogicOp_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glLogicOp\0", &self.glLogicOp_p)
        }
        #[inline]

        pub fn LogicOp_is_loaded(&self) -> bool {
            !self.glLogicOp_p.load(RELAX).is_null()
        }
        /// [glMapBuffer](http://docs.gl/gl4/glMapBuffer)(target, access)
        /// * `target` group: BufferTargetARB
        /// * `access` group: BufferAccessARB
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MapBuffer(&self, target: GLenum, access: GLenum) -> *mut c_void {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.MapBuffer({:#X}, {:#X});", target, access);
            }
            let out = call_atomic_ptr_2arg("glMapBuffer", &self.glMapBuffer_p, target, access);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMapBuffer");
            }
            out
        }

        pub unsafe fn MapBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glMapBuffer\0", &self.glMapBuffer_p)
        }
        #[inline]

        pub fn MapBuffer_is_loaded(&self) -> bool {
            !self.glMapBuffer_p.load(RELAX).is_null()
        }
        /// [glMapBufferRange](http://docs.gl/gl4/glMapBufferRange)(target, offset, length, access)
        /// * `target` group: BufferTargetARB
        /// * `offset` group: BufferOffset
        /// * `length` group: BufferSize
        /// * `access` group: MapBufferAccessMask
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MapBufferRange(
            &self,
            target: GLenum,
            offset: GLintptr,
            length: GLsizeiptr,
            access: GLbitfield,
        ) -> *mut c_void {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.MapBufferRange({:#X}, {:?}, {:?}, {:?});",
                    target,
                    offset,
                    length,
                    access
                );
            }
            let out = call_atomic_ptr_4arg(
                "glMapBufferRange",
                &self.glMapBufferRange_p,
                target,
                offset,
                length,
                access,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMapBufferRange");
            }
            out
        }

        pub unsafe fn MapBufferRange_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMapBufferRange\0",
                &self.glMapBufferRange_p,
            )
        }
        #[inline]

        pub fn MapBufferRange_is_loaded(&self) -> bool {
            !self.glMapBufferRange_p.load(RELAX).is_null()
        }
        /// [glMapNamedBuffer](http://docs.gl/gl4/glMapNamedBuffer)(buffer, access)
        /// * `buffer` class: buffer
        /// * `access` group: BufferAccessARB
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MapNamedBuffer(&self, buffer: GLuint, access: GLenum) -> *mut c_void {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.MapNamedBuffer({:?}, {:#X});", buffer, access);
            }
            let out =
                call_atomic_ptr_2arg("glMapNamedBuffer", &self.glMapNamedBuffer_p, buffer, access);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMapNamedBuffer");
            }
            out
        }

        pub unsafe fn MapNamedBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMapNamedBuffer\0",
                &self.glMapNamedBuffer_p,
            )
        }
        #[inline]

        pub fn MapNamedBuffer_is_loaded(&self) -> bool {
            !self.glMapNamedBuffer_p.load(RELAX).is_null()
        }
        /// [glMapNamedBufferRange](http://docs.gl/gl4/glMapNamedBufferRange)(buffer, offset, length, access)
        /// * `buffer` class: buffer
        /// * `length` group: BufferSize
        /// * `access` group: MapBufferAccessMask
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MapNamedBufferRange(
            &self,
            buffer: GLuint,
            offset: GLintptr,
            length: GLsizeiptr,
            access: GLbitfield,
        ) -> *mut c_void {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.MapNamedBufferRange({:?}, {:?}, {:?}, {:?});",
                    buffer,
                    offset,
                    length,
                    access
                );
            }
            let out = call_atomic_ptr_4arg(
                "glMapNamedBufferRange",
                &self.glMapNamedBufferRange_p,
                buffer,
                offset,
                length,
                access,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMapNamedBufferRange");
            }
            out
        }

        pub unsafe fn MapNamedBufferRange_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMapNamedBufferRange\0",
                &self.glMapNamedBufferRange_p,
            )
        }
        #[inline]

        pub fn MapNamedBufferRange_is_loaded(&self) -> bool {
            !self.glMapNamedBufferRange_p.load(RELAX).is_null()
        }
        /// [glMemoryBarrier](http://docs.gl/gl4/glMemoryBarrier)(barriers)
        /// * `barriers` group: MemoryBarrierMask
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MemoryBarrier(&self, barriers: GLbitfield) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.MemoryBarrier({:?});", barriers);
            }
            let out = call_atomic_ptr_1arg("glMemoryBarrier", &self.glMemoryBarrier_p, barriers);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMemoryBarrier");
            }
            out
        }

        pub unsafe fn MemoryBarrier_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMemoryBarrier\0",
                &self.glMemoryBarrier_p,
            )
        }
        #[inline]

        pub fn MemoryBarrier_is_loaded(&self) -> bool {
            !self.glMemoryBarrier_p.load(RELAX).is_null()
        }
        /// [glMemoryBarrierByRegion](http://docs.gl/gl4/glMemoryBarrierByRegion)(barriers)
        /// * `barriers` group: MemoryBarrierMask
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MemoryBarrierByRegion(&self, barriers: GLbitfield) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.MemoryBarrierByRegion({:?});", barriers);
            }
            let out = call_atomic_ptr_1arg(
                "glMemoryBarrierByRegion",
                &self.glMemoryBarrierByRegion_p,
                barriers,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMemoryBarrierByRegion");
            }
            out
        }

        pub unsafe fn MemoryBarrierByRegion_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMemoryBarrierByRegion\0",
                &self.glMemoryBarrierByRegion_p,
            )
        }
        #[inline]

        pub fn MemoryBarrierByRegion_is_loaded(&self) -> bool {
            !self.glMemoryBarrierByRegion_p.load(RELAX).is_null()
        }
        /// [glMinSampleShading](http://docs.gl/gl4/glMinSampleShading)(value)
        /// * `value` group: ColorF
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MinSampleShading(&self, value: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.MinSampleShading({:?});", value);
            }
            let out = call_atomic_ptr_1arg("glMinSampleShading", &self.glMinSampleShading_p, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMinSampleShading");
            }
            out
        }

        pub unsafe fn MinSampleShading_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMinSampleShading\0",
                &self.glMinSampleShading_p,
            )
        }
        #[inline]

        pub fn MinSampleShading_is_loaded(&self) -> bool {
            !self.glMinSampleShading_p.load(RELAX).is_null()
        }
        /// [glMultiDrawArrays](http://docs.gl/gl4/glMultiDrawArrays)(mode, first, count, drawcount)
        /// * `mode` group: PrimitiveType
        /// * `first` len: drawcount
        /// * `count` len: drawcount
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MultiDrawArrays(
            &self,
            mode: GLenum,
            first: *const GLint,
            count: *const GLsizei,
            drawcount: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.MultiDrawArrays({:#X}, {:p}, {:p}, {:?});",
                    mode,
                    first,
                    count,
                    drawcount
                );
            }
            let out = call_atomic_ptr_4arg(
                "glMultiDrawArrays",
                &self.glMultiDrawArrays_p,
                mode,
                first,
                count,
                drawcount,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMultiDrawArrays");
            }
            out
        }

        pub unsafe fn MultiDrawArrays_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMultiDrawArrays\0",
                &self.glMultiDrawArrays_p,
            )
        }
        #[inline]

        pub fn MultiDrawArrays_is_loaded(&self) -> bool {
            !self.glMultiDrawArrays_p.load(RELAX).is_null()
        }
        /// [glMultiDrawArraysIndirect](http://docs.gl/gl4/glMultiDrawArraysIndirect)(mode, indirect, drawcount, stride)
        /// * `mode` group: PrimitiveType
        /// * `indirect` len: COMPSIZE(drawcount,stride)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MultiDrawArraysIndirect(
            &self,
            mode: GLenum,
            indirect: *const c_void,
            drawcount: GLsizei,
            stride: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.MultiDrawArraysIndirect({:#X}, {:p}, {:?}, {:?});",
                    mode,
                    indirect,
                    drawcount,
                    stride
                );
            }
            let out = call_atomic_ptr_4arg(
                "glMultiDrawArraysIndirect",
                &self.glMultiDrawArraysIndirect_p,
                mode,
                indirect,
                drawcount,
                stride,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMultiDrawArraysIndirect");
            }
            out
        }

        pub unsafe fn MultiDrawArraysIndirect_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMultiDrawArraysIndirect\0",
                &self.glMultiDrawArraysIndirect_p,
            )
        }
        #[inline]

        pub fn MultiDrawArraysIndirect_is_loaded(&self) -> bool {
            !self.glMultiDrawArraysIndirect_p.load(RELAX).is_null()
        }
        /// [glMultiDrawArraysIndirectCount](http://docs.gl/gl4/glMultiDrawArraysIndirectCount)(mode, indirect, drawcount, maxdrawcount, stride)
        /// * `mode` group: PrimitiveType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MultiDrawArraysIndirectCount(
            &self,
            mode: GLenum,
            indirect: *const c_void,
            drawcount: GLintptr,
            maxdrawcount: GLsizei,
            stride: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.MultiDrawArraysIndirectCount({:#X}, {:p}, {:?}, {:?}, {:?});",
                    mode,
                    indirect,
                    drawcount,
                    maxdrawcount,
                    stride
                );
            }
            let out = call_atomic_ptr_5arg(
                "glMultiDrawArraysIndirectCount",
                &self.glMultiDrawArraysIndirectCount_p,
                mode,
                indirect,
                drawcount,
                maxdrawcount,
                stride,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMultiDrawArraysIndirectCount");
            }
            out
        }

        pub unsafe fn MultiDrawArraysIndirectCount_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMultiDrawArraysIndirectCount\0",
                &self.glMultiDrawArraysIndirectCount_p,
            )
        }
        #[inline]

        pub fn MultiDrawArraysIndirectCount_is_loaded(&self) -> bool {
            !self.glMultiDrawArraysIndirectCount_p.load(RELAX).is_null()
        }
        /// [glMultiDrawElements](http://docs.gl/gl4/glMultiDrawElements)(mode, count, type_, indices, drawcount)
        /// * `mode` group: PrimitiveType
        /// * `count` len: drawcount
        /// * `type_` group: DrawElementsType
        /// * `indices` len: drawcount
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MultiDrawElements(
            &self,
            mode: GLenum,
            count: *const GLsizei,
            type_: GLenum,
            indices: *const *const c_void,
            drawcount: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.MultiDrawElements({:#X}, {:p}, {:#X}, {:p}, {:?});",
                    mode,
                    count,
                    type_,
                    indices,
                    drawcount
                );
            }
            let out = call_atomic_ptr_5arg(
                "glMultiDrawElements",
                &self.glMultiDrawElements_p,
                mode,
                count,
                type_,
                indices,
                drawcount,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMultiDrawElements");
            }
            out
        }

        pub unsafe fn MultiDrawElements_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMultiDrawElements\0",
                &self.glMultiDrawElements_p,
            )
        }
        #[inline]

        pub fn MultiDrawElements_is_loaded(&self) -> bool {
            !self.glMultiDrawElements_p.load(RELAX).is_null()
        }
        /// [glMultiDrawElementsBaseVertex](http://docs.gl/gl4/glMultiDrawElementsBaseVertex)(mode, count, type_, indices, drawcount, basevertex)
        /// * `mode` group: PrimitiveType
        /// * `count` len: drawcount
        /// * `type_` group: DrawElementsType
        /// * `indices` len: drawcount
        /// * `basevertex` len: drawcount
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MultiDrawElementsBaseVertex(
            &self,
            mode: GLenum,
            count: *const GLsizei,
            type_: GLenum,
            indices: *const *const c_void,
            drawcount: GLsizei,
            basevertex: *const GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.MultiDrawElementsBaseVertex({:#X}, {:p}, {:#X}, {:p}, {:?}, {:p});",
                    mode,
                    count,
                    type_,
                    indices,
                    drawcount,
                    basevertex
                );
            }
            let out = call_atomic_ptr_6arg(
                "glMultiDrawElementsBaseVertex",
                &self.glMultiDrawElementsBaseVertex_p,
                mode,
                count,
                type_,
                indices,
                drawcount,
                basevertex,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMultiDrawElementsBaseVertex");
            }
            out
        }

        pub unsafe fn MultiDrawElementsBaseVertex_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMultiDrawElementsBaseVertex\0",
                &self.glMultiDrawElementsBaseVertex_p,
            )
        }
        #[inline]

        pub fn MultiDrawElementsBaseVertex_is_loaded(&self) -> bool {
            !self.glMultiDrawElementsBaseVertex_p.load(RELAX).is_null()
        }
        /// [glMultiDrawElementsIndirect](http://docs.gl/gl4/glMultiDrawElementsIndirect)(mode, type_, indirect, drawcount, stride)
        /// * `mode` group: PrimitiveType
        /// * `type_` group: DrawElementsType
        /// * `indirect` len: COMPSIZE(drawcount,stride)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MultiDrawElementsIndirect(
            &self,
            mode: GLenum,
            type_: GLenum,
            indirect: *const c_void,
            drawcount: GLsizei,
            stride: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.MultiDrawElementsIndirect({:#X}, {:#X}, {:p}, {:?}, {:?});",
                    mode,
                    type_,
                    indirect,
                    drawcount,
                    stride
                );
            }
            let out = call_atomic_ptr_5arg(
                "glMultiDrawElementsIndirect",
                &self.glMultiDrawElementsIndirect_p,
                mode,
                type_,
                indirect,
                drawcount,
                stride,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMultiDrawElementsIndirect");
            }
            out
        }

        pub unsafe fn MultiDrawElementsIndirect_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMultiDrawElementsIndirect\0",
                &self.glMultiDrawElementsIndirect_p,
            )
        }
        #[inline]

        pub fn MultiDrawElementsIndirect_is_loaded(&self) -> bool {
            !self.glMultiDrawElementsIndirect_p.load(RELAX).is_null()
        }
        /// [glMultiDrawElementsIndirectCount](http://docs.gl/gl4/glMultiDrawElementsIndirectCount)(mode, type_, indirect, drawcount, maxdrawcount, stride)
        /// * `mode` group: PrimitiveType
        /// * `type_` group: DrawElementsType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn MultiDrawElementsIndirectCount(
            &self,
            mode: GLenum,
            type_: GLenum,
            indirect: *const c_void,
            drawcount: GLintptr,
            maxdrawcount: GLsizei,
            stride: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.MultiDrawElementsIndirectCount({:#X}, {:#X}, {:p}, {:?}, {:?}, {:?});", mode, type_, indirect, drawcount, maxdrawcount, stride);
            }
            let out = call_atomic_ptr_6arg(
                "glMultiDrawElementsIndirectCount",
                &self.glMultiDrawElementsIndirectCount_p,
                mode,
                type_,
                indirect,
                drawcount,
                maxdrawcount,
                stride,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glMultiDrawElementsIndirectCount");
            }
            out
        }

        pub unsafe fn MultiDrawElementsIndirectCount_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glMultiDrawElementsIndirectCount\0",
                &self.glMultiDrawElementsIndirectCount_p,
            )
        }
        #[inline]

        pub fn MultiDrawElementsIndirectCount_is_loaded(&self) -> bool {
            !self
                .glMultiDrawElementsIndirectCount_p
                .load(RELAX)
                .is_null()
        }
        /// [glNamedBufferData](http://docs.gl/gl4/glNamedBufferData)(buffer, size, data, usage)
        /// * `buffer` class: buffer
        /// * `size` group: BufferSize
        /// * `usage` group: VertexBufferObjectUsage
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedBufferData(
            &self,
            buffer: GLuint,
            size: GLsizeiptr,
            data: *const c_void,
            usage: GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.NamedBufferData({:?}, {:?}, {:p}, {:#X});",
                    buffer,
                    size,
                    data,
                    usage
                );
            }
            let out = call_atomic_ptr_4arg(
                "glNamedBufferData",
                &self.glNamedBufferData_p,
                buffer,
                size,
                data,
                usage,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedBufferData");
            }
            out
        }

        pub unsafe fn NamedBufferData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedBufferData\0",
                &self.glNamedBufferData_p,
            )
        }
        #[inline]

        pub fn NamedBufferData_is_loaded(&self) -> bool {
            !self.glNamedBufferData_p.load(RELAX).is_null()
        }
        /// [glNamedBufferStorage](http://docs.gl/gl4/glNamedBufferStorage)(buffer, size, data, flags)
        /// * `buffer` class: buffer
        /// * `size` group: BufferSize
        /// * `data` len: size
        /// * `flags` group: BufferStorageMask
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedBufferStorage(
            &self,
            buffer: GLuint,
            size: GLsizeiptr,
            data: *const c_void,
            flags: GLbitfield,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.NamedBufferStorage({:?}, {:?}, {:p}, {:?});",
                    buffer,
                    size,
                    data,
                    flags
                );
            }
            let out = call_atomic_ptr_4arg(
                "glNamedBufferStorage",
                &self.glNamedBufferStorage_p,
                buffer,
                size,
                data,
                flags,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedBufferStorage");
            }
            out
        }

        pub unsafe fn NamedBufferStorage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedBufferStorage\0",
                &self.glNamedBufferStorage_p,
            )
        }
        #[inline]

        pub fn NamedBufferStorage_is_loaded(&self) -> bool {
            !self.glNamedBufferStorage_p.load(RELAX).is_null()
        }
        /// [glNamedBufferSubData](http://docs.gl/gl4/glNamedBufferSubData)(buffer, offset, size, data)
        /// * `buffer` class: buffer
        /// * `size` group: BufferSize
        /// * `data` len: COMPSIZE(size)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedBufferSubData(
            &self,
            buffer: GLuint,
            offset: GLintptr,
            size: GLsizeiptr,
            data: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.NamedBufferSubData({:?}, {:?}, {:?}, {:p});",
                    buffer,
                    offset,
                    size,
                    data
                );
            }
            let out = call_atomic_ptr_4arg(
                "glNamedBufferSubData",
                &self.glNamedBufferSubData_p,
                buffer,
                offset,
                size,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedBufferSubData");
            }
            out
        }

        pub unsafe fn NamedBufferSubData_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedBufferSubData\0",
                &self.glNamedBufferSubData_p,
            )
        }
        #[inline]

        pub fn NamedBufferSubData_is_loaded(&self) -> bool {
            !self.glNamedBufferSubData_p.load(RELAX).is_null()
        }
        /// [glNamedFramebufferDrawBuffer](http://docs.gl/gl4/glNamedFramebufferDrawBuffer)(framebuffer, buf)
        /// * `framebuffer` class: framebuffer
        /// * `buf` group: ColorBuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedFramebufferDrawBuffer(&self, framebuffer: GLuint, buf: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.NamedFramebufferDrawBuffer({:?}, {:#X});",
                    framebuffer,
                    buf
                );
            }
            let out = call_atomic_ptr_2arg(
                "glNamedFramebufferDrawBuffer",
                &self.glNamedFramebufferDrawBuffer_p,
                framebuffer,
                buf,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedFramebufferDrawBuffer");
            }
            out
        }

        pub unsafe fn NamedFramebufferDrawBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedFramebufferDrawBuffer\0",
                &self.glNamedFramebufferDrawBuffer_p,
            )
        }
        #[inline]

        pub fn NamedFramebufferDrawBuffer_is_loaded(&self) -> bool {
            !self.glNamedFramebufferDrawBuffer_p.load(RELAX).is_null()
        }
        /// [glNamedFramebufferDrawBuffers](http://docs.gl/gl4/glNamedFramebufferDrawBuffers)(framebuffer, n, bufs)
        /// * `framebuffer` class: framebuffer
        /// * `bufs` group: ColorBuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedFramebufferDrawBuffers(
            &self,
            framebuffer: GLuint,
            n: GLsizei,
            bufs: *const GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.NamedFramebufferDrawBuffers({:?}, {:?}, {:p});",
                    framebuffer,
                    n,
                    bufs
                );
            }
            let out = call_atomic_ptr_3arg(
                "glNamedFramebufferDrawBuffers",
                &self.glNamedFramebufferDrawBuffers_p,
                framebuffer,
                n,
                bufs,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedFramebufferDrawBuffers");
            }
            out
        }

        pub unsafe fn NamedFramebufferDrawBuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedFramebufferDrawBuffers\0",
                &self.glNamedFramebufferDrawBuffers_p,
            )
        }
        #[inline]

        pub fn NamedFramebufferDrawBuffers_is_loaded(&self) -> bool {
            !self.glNamedFramebufferDrawBuffers_p.load(RELAX).is_null()
        }
        /// [glNamedFramebufferParameteri](http://docs.gl/gl4/glNamedFramebufferParameter)(framebuffer, pname, param)
        /// * `framebuffer` class: framebuffer
        /// * `pname` group: FramebufferParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedFramebufferParameteri(
            &self,
            framebuffer: GLuint,
            pname: GLenum,
            param: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.NamedFramebufferParameteri({:?}, {:#X}, {:?});",
                    framebuffer,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glNamedFramebufferParameteri",
                &self.glNamedFramebufferParameteri_p,
                framebuffer,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedFramebufferParameteri");
            }
            out
        }

        pub unsafe fn NamedFramebufferParameteri_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedFramebufferParameteri\0",
                &self.glNamedFramebufferParameteri_p,
            )
        }
        #[inline]

        pub fn NamedFramebufferParameteri_is_loaded(&self) -> bool {
            !self.glNamedFramebufferParameteri_p.load(RELAX).is_null()
        }
        /// [glNamedFramebufferReadBuffer](http://docs.gl/gl4/glNamedFramebufferReadBuffer)(framebuffer, src)
        /// * `framebuffer` class: framebuffer
        /// * `src` group: ColorBuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedFramebufferReadBuffer(&self, framebuffer: GLuint, src: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.NamedFramebufferReadBuffer({:?}, {:#X});",
                    framebuffer,
                    src
                );
            }
            let out = call_atomic_ptr_2arg(
                "glNamedFramebufferReadBuffer",
                &self.glNamedFramebufferReadBuffer_p,
                framebuffer,
                src,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedFramebufferReadBuffer");
            }
            out
        }

        pub unsafe fn NamedFramebufferReadBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedFramebufferReadBuffer\0",
                &self.glNamedFramebufferReadBuffer_p,
            )
        }
        #[inline]

        pub fn NamedFramebufferReadBuffer_is_loaded(&self) -> bool {
            !self.glNamedFramebufferReadBuffer_p.load(RELAX).is_null()
        }
        /// [glNamedFramebufferRenderbuffer](http://docs.gl/gl4/glNamedFramebufferRenderbuffer)(framebuffer, attachment, renderbuffertarget, renderbuffer)
        /// * `framebuffer` class: framebuffer
        /// * `attachment` group: FramebufferAttachment
        /// * `renderbuffertarget` group: RenderbufferTarget
        /// * `renderbuffer` class: renderbuffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedFramebufferRenderbuffer(
            &self,
            framebuffer: GLuint,
            attachment: GLenum,
            renderbuffertarget: GLenum,
            renderbuffer: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.NamedFramebufferRenderbuffer({:?}, {:#X}, {:#X}, {:?});",
                    framebuffer,
                    attachment,
                    renderbuffertarget,
                    renderbuffer
                );
            }
            let out = call_atomic_ptr_4arg(
                "glNamedFramebufferRenderbuffer",
                &self.glNamedFramebufferRenderbuffer_p,
                framebuffer,
                attachment,
                renderbuffertarget,
                renderbuffer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedFramebufferRenderbuffer");
            }
            out
        }

        pub unsafe fn NamedFramebufferRenderbuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedFramebufferRenderbuffer\0",
                &self.glNamedFramebufferRenderbuffer_p,
            )
        }
        #[inline]

        pub fn NamedFramebufferRenderbuffer_is_loaded(&self) -> bool {
            !self.glNamedFramebufferRenderbuffer_p.load(RELAX).is_null()
        }
        /// [glNamedFramebufferTexture](http://docs.gl/gl4/glNamedFramebufferTexture)(framebuffer, attachment, texture, level)
        /// * `framebuffer` class: framebuffer
        /// * `attachment` group: FramebufferAttachment
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedFramebufferTexture(
            &self,
            framebuffer: GLuint,
            attachment: GLenum,
            texture: GLuint,
            level: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.NamedFramebufferTexture({:?}, {:#X}, {:?}, {:?});",
                    framebuffer,
                    attachment,
                    texture,
                    level
                );
            }
            let out = call_atomic_ptr_4arg(
                "glNamedFramebufferTexture",
                &self.glNamedFramebufferTexture_p,
                framebuffer,
                attachment,
                texture,
                level,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedFramebufferTexture");
            }
            out
        }

        pub unsafe fn NamedFramebufferTexture_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedFramebufferTexture\0",
                &self.glNamedFramebufferTexture_p,
            )
        }
        #[inline]

        pub fn NamedFramebufferTexture_is_loaded(&self) -> bool {
            !self.glNamedFramebufferTexture_p.load(RELAX).is_null()
        }
        /// [glNamedFramebufferTextureLayer](http://docs.gl/gl4/glNamedFramebufferTextureLayer)(framebuffer, attachment, texture, level, layer)
        /// * `framebuffer` class: framebuffer
        /// * `attachment` group: FramebufferAttachment
        /// * `texture` class: texture
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedFramebufferTextureLayer(
            &self,
            framebuffer: GLuint,
            attachment: GLenum,
            texture: GLuint,
            level: GLint,
            layer: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.NamedFramebufferTextureLayer({:?}, {:#X}, {:?}, {:?}, {:?});",
                    framebuffer,
                    attachment,
                    texture,
                    level,
                    layer
                );
            }
            let out = call_atomic_ptr_5arg(
                "glNamedFramebufferTextureLayer",
                &self.glNamedFramebufferTextureLayer_p,
                framebuffer,
                attachment,
                texture,
                level,
                layer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedFramebufferTextureLayer");
            }
            out
        }

        pub unsafe fn NamedFramebufferTextureLayer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedFramebufferTextureLayer\0",
                &self.glNamedFramebufferTextureLayer_p,
            )
        }
        #[inline]

        pub fn NamedFramebufferTextureLayer_is_loaded(&self) -> bool {
            !self.glNamedFramebufferTextureLayer_p.load(RELAX).is_null()
        }
        /// [glNamedRenderbufferStorage](http://docs.gl/gl4/glNamedRenderbufferStorage)(renderbuffer, internalformat, width, height)
        /// * `renderbuffer` class: renderbuffer
        /// * `internalformat` group: InternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedRenderbufferStorage(
            &self,
            renderbuffer: GLuint,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.NamedRenderbufferStorage({:?}, {:#X}, {:?}, {:?});",
                    renderbuffer,
                    internalformat,
                    width,
                    height
                );
            }
            let out = call_atomic_ptr_4arg(
                "glNamedRenderbufferStorage",
                &self.glNamedRenderbufferStorage_p,
                renderbuffer,
                internalformat,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedRenderbufferStorage");
            }
            out
        }

        pub unsafe fn NamedRenderbufferStorage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedRenderbufferStorage\0",
                &self.glNamedRenderbufferStorage_p,
            )
        }
        #[inline]

        pub fn NamedRenderbufferStorage_is_loaded(&self) -> bool {
            !self.glNamedRenderbufferStorage_p.load(RELAX).is_null()
        }
        /// [glNamedRenderbufferStorageMultisample](http://docs.gl/gl4/glNamedRenderbufferStorageMultisample)(renderbuffer, samples, internalformat, width, height)
        /// * `renderbuffer` class: renderbuffer
        /// * `internalformat` group: InternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn NamedRenderbufferStorageMultisample(
            &self,
            renderbuffer: GLuint,
            samples: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.NamedRenderbufferStorageMultisample({:?}, {:?}, {:#X}, {:?}, {:?});", renderbuffer, samples, internalformat, width, height);
            }
            let out = call_atomic_ptr_5arg(
                "glNamedRenderbufferStorageMultisample",
                &self.glNamedRenderbufferStorageMultisample_p,
                renderbuffer,
                samples,
                internalformat,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glNamedRenderbufferStorageMultisample");
            }
            out
        }

        pub unsafe fn NamedRenderbufferStorageMultisample_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glNamedRenderbufferStorageMultisample\0",
                &self.glNamedRenderbufferStorageMultisample_p,
            )
        }
        #[inline]

        pub fn NamedRenderbufferStorageMultisample_is_loaded(&self) -> bool {
            !self
                .glNamedRenderbufferStorageMultisample_p
                .load(RELAX)
                .is_null()
        }
        /// [glObjectLabel](http://docs.gl/gl4/glObjectLabel)(identifier, name, length, label)
        /// * `identifier` group: ObjectIdentifier
        /// * `label` len: COMPSIZE(label,length)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ObjectLabel(
            &self,
            identifier: GLenum,
            name: GLuint,
            length: GLsizei,
            label: *const GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ObjectLabel({:#X}, {:?}, {:?}, {:p});",
                    identifier,
                    name,
                    length,
                    label
                );
            }
            let out = call_atomic_ptr_4arg(
                "glObjectLabel",
                &self.glObjectLabel_p,
                identifier,
                name,
                length,
                label,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glObjectLabel");
            }
            out
        }

        pub unsafe fn ObjectLabel_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glObjectLabel\0", &self.glObjectLabel_p)
        }
        #[inline]

        pub fn ObjectLabel_is_loaded(&self) -> bool {
            !self.glObjectLabel_p.load(RELAX).is_null()
        }
        /// [glObjectPtrLabel](http://docs.gl/gl4/glObjectPtrLabel)(ptr, length, label)
        /// * `label` len: COMPSIZE(label,length)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ObjectPtrLabel(
            &self,
            ptr: *const c_void,
            length: GLsizei,
            label: *const GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ObjectPtrLabel({:p}, {:?}, {:p});",
                    ptr,
                    length,
                    label
                );
            }
            let out = call_atomic_ptr_3arg(
                "glObjectPtrLabel",
                &self.glObjectPtrLabel_p,
                ptr,
                length,
                label,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glObjectPtrLabel");
            }
            out
        }

        pub unsafe fn ObjectPtrLabel_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glObjectPtrLabel\0",
                &self.glObjectPtrLabel_p,
            )
        }
        #[inline]

        pub fn ObjectPtrLabel_is_loaded(&self) -> bool {
            !self.glObjectPtrLabel_p.load(RELAX).is_null()
        }
        /// [glPatchParameterfv](http://docs.gl/gl4/glPatchParameter)(pname, values)
        /// * `pname` group: PatchParameterName
        /// * `values` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PatchParameterfv(&self, pname: GLenum, values: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PatchParameterfv({:#X}, {:p});", pname, values);
            }
            let out = call_atomic_ptr_2arg(
                "glPatchParameterfv",
                &self.glPatchParameterfv_p,
                pname,
                values,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPatchParameterfv");
            }
            out
        }

        pub unsafe fn PatchParameterfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPatchParameterfv\0",
                &self.glPatchParameterfv_p,
            )
        }
        #[inline]

        pub fn PatchParameterfv_is_loaded(&self) -> bool {
            !self.glPatchParameterfv_p.load(RELAX).is_null()
        }
        /// [glPatchParameteri](http://docs.gl/gl4/glPatchParameter)(pname, value)
        /// * `pname` group: PatchParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PatchParameteri(&self, pname: GLenum, value: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PatchParameteri({:#X}, {:?});", pname, value);
            }
            let out =
                call_atomic_ptr_2arg("glPatchParameteri", &self.glPatchParameteri_p, pname, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPatchParameteri");
            }
            out
        }

        pub unsafe fn PatchParameteri_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPatchParameteri\0",
                &self.glPatchParameteri_p,
            )
        }
        #[inline]

        pub fn PatchParameteri_is_loaded(&self) -> bool {
            !self.glPatchParameteri_p.load(RELAX).is_null()
        }
        /// [glPauseTransformFeedback](http://docs.gl/gl4/glPauseTransformFeedback)()
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PauseTransformFeedback(&self) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PauseTransformFeedback();",);
            }
            let out =
                call_atomic_ptr_0arg("glPauseTransformFeedback", &self.glPauseTransformFeedback_p);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPauseTransformFeedback");
            }
            out
        }

        pub unsafe fn PauseTransformFeedback_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPauseTransformFeedback\0",
                &self.glPauseTransformFeedback_p,
            )
        }
        #[inline]

        pub fn PauseTransformFeedback_is_loaded(&self) -> bool {
            !self.glPauseTransformFeedback_p.load(RELAX).is_null()
        }
        /// [glPixelStoref](http://docs.gl/gl4/glPixelStore)(pname, param)
        /// * `pname` group: PixelStoreParameter
        /// * `param` group: CheckedFloat32
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PixelStoref(&self, pname: GLenum, param: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PixelStoref({:#X}, {:?});", pname, param);
            }
            let out = call_atomic_ptr_2arg("glPixelStoref", &self.glPixelStoref_p, pname, param);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPixelStoref");
            }
            out
        }

        pub unsafe fn PixelStoref_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glPixelStoref\0", &self.glPixelStoref_p)
        }
        #[inline]

        pub fn PixelStoref_is_loaded(&self) -> bool {
            !self.glPixelStoref_p.load(RELAX).is_null()
        }
        /// [glPixelStorei](http://docs.gl/gl4/glPixelStore)(pname, param)
        /// * `pname` group: PixelStoreParameter
        /// * `param` group: CheckedInt32
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PixelStorei(&self, pname: GLenum, param: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PixelStorei({:#X}, {:?});", pname, param);
            }
            let out = call_atomic_ptr_2arg("glPixelStorei", &self.glPixelStorei_p, pname, param);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPixelStorei");
            }
            out
        }

        pub unsafe fn PixelStorei_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glPixelStorei\0", &self.glPixelStorei_p)
        }
        #[inline]

        pub fn PixelStorei_is_loaded(&self) -> bool {
            !self.glPixelStorei_p.load(RELAX).is_null()
        }
        /// [glPointParameterf](http://docs.gl/gl4/glPointParameter)(pname, param)
        /// * `pname` group: PointParameterNameARB
        /// * `param` group: CheckedFloat32
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PointParameterf(&self, pname: GLenum, param: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PointParameterf({:#X}, {:?});", pname, param);
            }
            let out =
                call_atomic_ptr_2arg("glPointParameterf", &self.glPointParameterf_p, pname, param);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPointParameterf");
            }
            out
        }

        pub unsafe fn PointParameterf_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPointParameterf\0",
                &self.glPointParameterf_p,
            )
        }
        #[inline]

        pub fn PointParameterf_is_loaded(&self) -> bool {
            !self.glPointParameterf_p.load(RELAX).is_null()
        }
        /// [glPointParameterfv](http://docs.gl/gl4/glPointParameter)(pname, params)
        /// * `pname` group: PointParameterNameARB
        /// * `params` group: CheckedFloat32
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PointParameterfv(&self, pname: GLenum, params: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PointParameterfv({:#X}, {:p});", pname, params);
            }
            let out = call_atomic_ptr_2arg(
                "glPointParameterfv",
                &self.glPointParameterfv_p,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPointParameterfv");
            }
            out
        }

        pub unsafe fn PointParameterfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPointParameterfv\0",
                &self.glPointParameterfv_p,
            )
        }
        #[inline]

        pub fn PointParameterfv_is_loaded(&self) -> bool {
            !self.glPointParameterfv_p.load(RELAX).is_null()
        }
        /// [glPointParameteri](http://docs.gl/gl4/glPointParameter)(pname, param)
        /// * `pname` group: PointParameterNameARB
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PointParameteri(&self, pname: GLenum, param: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PointParameteri({:#X}, {:?});", pname, param);
            }
            let out =
                call_atomic_ptr_2arg("glPointParameteri", &self.glPointParameteri_p, pname, param);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPointParameteri");
            }
            out
        }

        pub unsafe fn PointParameteri_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPointParameteri\0",
                &self.glPointParameteri_p,
            )
        }
        #[inline]

        pub fn PointParameteri_is_loaded(&self) -> bool {
            !self.glPointParameteri_p.load(RELAX).is_null()
        }
        /// [glPointParameteriv](http://docs.gl/gl4/glPointParameter)(pname, params)
        /// * `pname` group: PointParameterNameARB
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PointParameteriv(&self, pname: GLenum, params: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PointParameteriv({:#X}, {:p});", pname, params);
            }
            let out = call_atomic_ptr_2arg(
                "glPointParameteriv",
                &self.glPointParameteriv_p,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPointParameteriv");
            }
            out
        }

        pub unsafe fn PointParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPointParameteriv\0",
                &self.glPointParameteriv_p,
            )
        }
        #[inline]

        pub fn PointParameteriv_is_loaded(&self) -> bool {
            !self.glPointParameteriv_p.load(RELAX).is_null()
        }
        /// [glPointSize](http://docs.gl/gl4/glPointSize)(size)
        /// * `size` group: CheckedFloat32
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PointSize(&self, size: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PointSize({:?});", size);
            }
            let out = call_atomic_ptr_1arg("glPointSize", &self.glPointSize_p, size);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPointSize");
            }
            out
        }

        pub unsafe fn PointSize_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glPointSize\0", &self.glPointSize_p)
        }
        #[inline]

        pub fn PointSize_is_loaded(&self) -> bool {
            !self.glPointSize_p.load(RELAX).is_null()
        }
        /// [glPolygonMode](http://docs.gl/gl4/glPolygonMode)(face, mode)
        /// * `face` group: MaterialFace
        /// * `mode` group: PolygonMode
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PolygonMode(&self, face: GLenum, mode: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PolygonMode({:#X}, {:#X});", face, mode);
            }
            let out = call_atomic_ptr_2arg("glPolygonMode", &self.glPolygonMode_p, face, mode);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPolygonMode");
            }
            out
        }

        pub unsafe fn PolygonMode_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glPolygonMode\0", &self.glPolygonMode_p)
        }
        #[inline]

        pub fn PolygonMode_is_loaded(&self) -> bool {
            !self.glPolygonMode_p.load(RELAX).is_null()
        }
        /// [glPolygonOffset](http://docs.gl/gl4/glPolygonOffset)(factor, units)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PolygonOffset(&self, factor: GLfloat, units: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PolygonOffset({:?}, {:?});", factor, units);
            }
            let out =
                call_atomic_ptr_2arg("glPolygonOffset", &self.glPolygonOffset_p, factor, units);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPolygonOffset");
            }
            out
        }

        pub unsafe fn PolygonOffset_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPolygonOffset\0",
                &self.glPolygonOffset_p,
            )
        }
        #[inline]

        pub fn PolygonOffset_is_loaded(&self) -> bool {
            !self.glPolygonOffset_p.load(RELAX).is_null()
        }
        /// [glPolygonOffsetClamp](http://docs.gl/gl4/glPolygonOffsetClamp)(factor, units, clamp)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PolygonOffsetClamp(&self, factor: GLfloat, units: GLfloat, clamp: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.PolygonOffsetClamp({:?}, {:?}, {:?});",
                    factor,
                    units,
                    clamp
                );
            }
            let out = call_atomic_ptr_3arg(
                "glPolygonOffsetClamp",
                &self.glPolygonOffsetClamp_p,
                factor,
                units,
                clamp,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPolygonOffsetClamp");
            }
            out
        }

        pub unsafe fn PolygonOffsetClamp_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPolygonOffsetClamp\0",
                &self.glPolygonOffsetClamp_p,
            )
        }
        #[inline]

        pub fn PolygonOffsetClamp_is_loaded(&self) -> bool {
            !self.glPolygonOffsetClamp_p.load(RELAX).is_null()
        }
        /// [glPopDebugGroup](http://docs.gl/gl4/glPopDebugGroup)()
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PopDebugGroup(&self) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PopDebugGroup();",);
            }
            let out = call_atomic_ptr_0arg("glPopDebugGroup", &self.glPopDebugGroup_p);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPopDebugGroup");
            }
            out
        }

        pub unsafe fn PopDebugGroup_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPopDebugGroup\0",
                &self.glPopDebugGroup_p,
            )
        }
        #[inline]

        pub fn PopDebugGroup_is_loaded(&self) -> bool {
            !self.glPopDebugGroup_p.load(RELAX).is_null()
        }
        /// [glPrimitiveRestartIndex](http://docs.gl/gl4/glPrimitiveRestartIndex)(index)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PrimitiveRestartIndex(&self, index: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.PrimitiveRestartIndex({:?});", index);
            }
            let out = call_atomic_ptr_1arg(
                "glPrimitiveRestartIndex",
                &self.glPrimitiveRestartIndex_p,
                index,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPrimitiveRestartIndex");
            }
            out
        }

        pub unsafe fn PrimitiveRestartIndex_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPrimitiveRestartIndex\0",
                &self.glPrimitiveRestartIndex_p,
            )
        }
        #[inline]

        pub fn PrimitiveRestartIndex_is_loaded(&self) -> bool {
            !self.glPrimitiveRestartIndex_p.load(RELAX).is_null()
        }
        /// [glProgramBinary](http://docs.gl/gl4/glProgramBinary)(program, binaryFormat, binary, length)
        /// * `program` class: program
        /// * `binary` len: length
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramBinary(
            &self,
            program: GLuint,
            binaryFormat: GLenum,
            binary: *const c_void,
            length: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramBinary({:?}, {:#X}, {:p}, {:?});",
                    program,
                    binaryFormat,
                    binary,
                    length
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramBinary",
                &self.glProgramBinary_p,
                program,
                binaryFormat,
                binary,
                length,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramBinary");
            }
            out
        }

        pub unsafe fn ProgramBinary_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramBinary\0",
                &self.glProgramBinary_p,
            )
        }
        #[inline]

        pub fn ProgramBinary_is_loaded(&self) -> bool {
            !self.glProgramBinary_p.load(RELAX).is_null()
        }
        /// [glProgramParameteri](http://docs.gl/gl4/glProgramParameteri)(program, pname, value)
        /// * `program` class: program
        /// * `pname` group: ProgramParameterPName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramParameteri(&self, program: GLuint, pname: GLenum, value: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramParameteri({:?}, {:#X}, {:?});",
                    program,
                    pname,
                    value
                );
            }
            let out = call_atomic_ptr_3arg(
                "glProgramParameteri",
                &self.glProgramParameteri_p,
                program,
                pname,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramParameteri");
            }
            out
        }

        pub unsafe fn ProgramParameteri_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramParameteri\0",
                &self.glProgramParameteri_p,
            )
        }
        #[inline]

        pub fn ProgramParameteri_is_loaded(&self) -> bool {
            !self.glProgramParameteri_p.load(RELAX).is_null()
        }
        /// [glProgramUniform1d](http://docs.gl/gl4/glProgramUniform1d)(program, location, v0)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform1d(&self, program: GLuint, location: GLint, v0: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform1d({:?}, {:?}, {:?});",
                    program,
                    location,
                    v0
                );
            }
            let out = call_atomic_ptr_3arg(
                "glProgramUniform1d",
                &self.glProgramUniform1d_p,
                program,
                location,
                v0,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform1d");
            }
            out
        }

        pub unsafe fn ProgramUniform1d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform1d\0",
                &self.glProgramUniform1d_p,
            )
        }
        #[inline]

        pub fn ProgramUniform1d_is_loaded(&self) -> bool {
            !self.glProgramUniform1d_p.load(RELAX).is_null()
        }
        /// [glProgramUniform1dv](http://docs.gl/gl4/glProgramUniform1dv)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform1dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform1dv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform1dv",
                &self.glProgramUniform1dv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform1dv");
            }
            out
        }

        pub unsafe fn ProgramUniform1dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform1dv\0",
                &self.glProgramUniform1dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform1dv_is_loaded(&self) -> bool {
            !self.glProgramUniform1dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform1f](http://docs.gl/gl4/glProgramUniform)(program, location, v0)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform1f(&self, program: GLuint, location: GLint, v0: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform1f({:?}, {:?}, {:?});",
                    program,
                    location,
                    v0
                );
            }
            let out = call_atomic_ptr_3arg(
                "glProgramUniform1f",
                &self.glProgramUniform1f_p,
                program,
                location,
                v0,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform1f");
            }
            out
        }

        pub unsafe fn ProgramUniform1f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform1f\0",
                &self.glProgramUniform1f_p,
            )
        }
        #[inline]

        pub fn ProgramUniform1f_is_loaded(&self) -> bool {
            !self.glProgramUniform1f_p.load(RELAX).is_null()
        }
        /// [glProgramUniform1fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform1fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform1fv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform1fv",
                &self.glProgramUniform1fv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform1fv");
            }
            out
        }

        pub unsafe fn ProgramUniform1fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform1fv\0",
                &self.glProgramUniform1fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform1fv_is_loaded(&self) -> bool {
            !self.glProgramUniform1fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform1i](http://docs.gl/gl4/glProgramUniform)(program, location, v0)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform1i(&self, program: GLuint, location: GLint, v0: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform1i({:?}, {:?}, {:?});",
                    program,
                    location,
                    v0
                );
            }
            let out = call_atomic_ptr_3arg(
                "glProgramUniform1i",
                &self.glProgramUniform1i_p,
                program,
                location,
                v0,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform1i");
            }
            out
        }

        pub unsafe fn ProgramUniform1i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform1i\0",
                &self.glProgramUniform1i_p,
            )
        }
        #[inline]

        pub fn ProgramUniform1i_is_loaded(&self) -> bool {
            !self.glProgramUniform1i_p.load(RELAX).is_null()
        }
        /// [glProgramUniform1iv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform1iv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform1iv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform1iv",
                &self.glProgramUniform1iv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform1iv");
            }
            out
        }

        pub unsafe fn ProgramUniform1iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform1iv\0",
                &self.glProgramUniform1iv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform1iv_is_loaded(&self) -> bool {
            !self.glProgramUniform1iv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform1ui](http://docs.gl/gl4/glProgramUniform)(program, location, v0)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform1ui(&self, program: GLuint, location: GLint, v0: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform1ui({:?}, {:?}, {:?});",
                    program,
                    location,
                    v0
                );
            }
            let out = call_atomic_ptr_3arg(
                "glProgramUniform1ui",
                &self.glProgramUniform1ui_p,
                program,
                location,
                v0,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform1ui");
            }
            out
        }

        pub unsafe fn ProgramUniform1ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform1ui\0",
                &self.glProgramUniform1ui_p,
            )
        }
        #[inline]

        pub fn ProgramUniform1ui_is_loaded(&self) -> bool {
            !self.glProgramUniform1ui_p.load(RELAX).is_null()
        }
        /// [glProgramUniform1uiv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform1uiv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform1uiv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform1uiv",
                &self.glProgramUniform1uiv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform1uiv");
            }
            out
        }

        pub unsafe fn ProgramUniform1uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform1uiv\0",
                &self.glProgramUniform1uiv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform1uiv_is_loaded(&self) -> bool {
            !self.glProgramUniform1uiv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform2d](http://docs.gl/gl4/glProgramUniform2d)(program, location, v0, v1)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform2d(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLdouble,
            v1: GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform2d({:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform2d",
                &self.glProgramUniform2d_p,
                program,
                location,
                v0,
                v1,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform2d");
            }
            out
        }

        pub unsafe fn ProgramUniform2d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform2d\0",
                &self.glProgramUniform2d_p,
            )
        }
        #[inline]

        pub fn ProgramUniform2d_is_loaded(&self) -> bool {
            !self.glProgramUniform2d_p.load(RELAX).is_null()
        }
        /// [glProgramUniform2dv](http://docs.gl/gl4/glProgramUniform2dv)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform2dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform2dv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform2dv",
                &self.glProgramUniform2dv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform2dv");
            }
            out
        }

        pub unsafe fn ProgramUniform2dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform2dv\0",
                &self.glProgramUniform2dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform2dv_is_loaded(&self) -> bool {
            !self.glProgramUniform2dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform2f](http://docs.gl/gl4/glProgramUniform)(program, location, v0, v1)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform2f(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLfloat,
            v1: GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform2f({:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform2f",
                &self.glProgramUniform2f_p,
                program,
                location,
                v0,
                v1,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform2f");
            }
            out
        }

        pub unsafe fn ProgramUniform2f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform2f\0",
                &self.glProgramUniform2f_p,
            )
        }
        #[inline]

        pub fn ProgramUniform2f_is_loaded(&self) -> bool {
            !self.glProgramUniform2f_p.load(RELAX).is_null()
        }
        /// [glProgramUniform2fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform2fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform2fv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform2fv",
                &self.glProgramUniform2fv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform2fv");
            }
            out
        }

        pub unsafe fn ProgramUniform2fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform2fv\0",
                &self.glProgramUniform2fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform2fv_is_loaded(&self) -> bool {
            !self.glProgramUniform2fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform2i](http://docs.gl/gl4/glProgramUniform)(program, location, v0, v1)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform2i(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLint,
            v1: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform2i({:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform2i",
                &self.glProgramUniform2i_p,
                program,
                location,
                v0,
                v1,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform2i");
            }
            out
        }

        pub unsafe fn ProgramUniform2i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform2i\0",
                &self.glProgramUniform2i_p,
            )
        }
        #[inline]

        pub fn ProgramUniform2i_is_loaded(&self) -> bool {
            !self.glProgramUniform2i_p.load(RELAX).is_null()
        }
        /// [glProgramUniform2iv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform2iv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform2iv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform2iv",
                &self.glProgramUniform2iv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform2iv");
            }
            out
        }

        pub unsafe fn ProgramUniform2iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform2iv\0",
                &self.glProgramUniform2iv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform2iv_is_loaded(&self) -> bool {
            !self.glProgramUniform2iv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform2ui](http://docs.gl/gl4/glProgramUniform)(program, location, v0, v1)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform2ui(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLuint,
            v1: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform2ui({:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform2ui",
                &self.glProgramUniform2ui_p,
                program,
                location,
                v0,
                v1,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform2ui");
            }
            out
        }

        pub unsafe fn ProgramUniform2ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform2ui\0",
                &self.glProgramUniform2ui_p,
            )
        }
        #[inline]

        pub fn ProgramUniform2ui_is_loaded(&self) -> bool {
            !self.glProgramUniform2ui_p.load(RELAX).is_null()
        }
        /// [glProgramUniform2uiv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform2uiv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform2uiv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform2uiv",
                &self.glProgramUniform2uiv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform2uiv");
            }
            out
        }

        pub unsafe fn ProgramUniform2uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform2uiv\0",
                &self.glProgramUniform2uiv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform2uiv_is_loaded(&self) -> bool {
            !self.glProgramUniform2uiv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform3d](http://docs.gl/gl4/glProgramUniform3d)(program, location, v0, v1, v2)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform3d(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLdouble,
            v1: GLdouble,
            v2: GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform3d({:?}, {:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1,
                    v2
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniform3d",
                &self.glProgramUniform3d_p,
                program,
                location,
                v0,
                v1,
                v2,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform3d");
            }
            out
        }

        pub unsafe fn ProgramUniform3d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform3d\0",
                &self.glProgramUniform3d_p,
            )
        }
        #[inline]

        pub fn ProgramUniform3d_is_loaded(&self) -> bool {
            !self.glProgramUniform3d_p.load(RELAX).is_null()
        }
        /// [glProgramUniform3dv](http://docs.gl/gl4/glProgramUniform3dv)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform3dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform3dv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform3dv",
                &self.glProgramUniform3dv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform3dv");
            }
            out
        }

        pub unsafe fn ProgramUniform3dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform3dv\0",
                &self.glProgramUniform3dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform3dv_is_loaded(&self) -> bool {
            !self.glProgramUniform3dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform3f](http://docs.gl/gl4/glProgramUniform)(program, location, v0, v1, v2)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform3f(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLfloat,
            v1: GLfloat,
            v2: GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform3f({:?}, {:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1,
                    v2
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniform3f",
                &self.glProgramUniform3f_p,
                program,
                location,
                v0,
                v1,
                v2,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform3f");
            }
            out
        }

        pub unsafe fn ProgramUniform3f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform3f\0",
                &self.glProgramUniform3f_p,
            )
        }
        #[inline]

        pub fn ProgramUniform3f_is_loaded(&self) -> bool {
            !self.glProgramUniform3f_p.load(RELAX).is_null()
        }
        /// [glProgramUniform3fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform3fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform3fv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform3fv",
                &self.glProgramUniform3fv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform3fv");
            }
            out
        }

        pub unsafe fn ProgramUniform3fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform3fv\0",
                &self.glProgramUniform3fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform3fv_is_loaded(&self) -> bool {
            !self.glProgramUniform3fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform3i](http://docs.gl/gl4/glProgramUniform)(program, location, v0, v1, v2)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform3i(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLint,
            v1: GLint,
            v2: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform3i({:?}, {:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1,
                    v2
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniform3i",
                &self.glProgramUniform3i_p,
                program,
                location,
                v0,
                v1,
                v2,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform3i");
            }
            out
        }

        pub unsafe fn ProgramUniform3i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform3i\0",
                &self.glProgramUniform3i_p,
            )
        }
        #[inline]

        pub fn ProgramUniform3i_is_loaded(&self) -> bool {
            !self.glProgramUniform3i_p.load(RELAX).is_null()
        }
        /// [glProgramUniform3iv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform3iv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform3iv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform3iv",
                &self.glProgramUniform3iv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform3iv");
            }
            out
        }

        pub unsafe fn ProgramUniform3iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform3iv\0",
                &self.glProgramUniform3iv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform3iv_is_loaded(&self) -> bool {
            !self.glProgramUniform3iv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform3ui](http://docs.gl/gl4/glProgramUniform)(program, location, v0, v1, v2)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform3ui(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLuint,
            v1: GLuint,
            v2: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform3ui({:?}, {:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1,
                    v2
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniform3ui",
                &self.glProgramUniform3ui_p,
                program,
                location,
                v0,
                v1,
                v2,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform3ui");
            }
            out
        }

        pub unsafe fn ProgramUniform3ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform3ui\0",
                &self.glProgramUniform3ui_p,
            )
        }
        #[inline]

        pub fn ProgramUniform3ui_is_loaded(&self) -> bool {
            !self.glProgramUniform3ui_p.load(RELAX).is_null()
        }
        /// [glProgramUniform3uiv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform3uiv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform3uiv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform3uiv",
                &self.glProgramUniform3uiv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform3uiv");
            }
            out
        }

        pub unsafe fn ProgramUniform3uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform3uiv\0",
                &self.glProgramUniform3uiv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform3uiv_is_loaded(&self) -> bool {
            !self.glProgramUniform3uiv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform4d](http://docs.gl/gl4/glProgramUniform4d)(program, location, v0, v1, v2, v3)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform4d(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLdouble,
            v1: GLdouble,
            v2: GLdouble,
            v3: GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform4d({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1,
                    v2,
                    v3
                );
            }
            let out = call_atomic_ptr_6arg(
                "glProgramUniform4d",
                &self.glProgramUniform4d_p,
                program,
                location,
                v0,
                v1,
                v2,
                v3,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform4d");
            }
            out
        }

        pub unsafe fn ProgramUniform4d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform4d\0",
                &self.glProgramUniform4d_p,
            )
        }
        #[inline]

        pub fn ProgramUniform4d_is_loaded(&self) -> bool {
            !self.glProgramUniform4d_p.load(RELAX).is_null()
        }
        /// [glProgramUniform4dv](http://docs.gl/gl4/glProgramUniform4dv)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform4dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform4dv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform4dv",
                &self.glProgramUniform4dv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform4dv");
            }
            out
        }

        pub unsafe fn ProgramUniform4dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform4dv\0",
                &self.glProgramUniform4dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform4dv_is_loaded(&self) -> bool {
            !self.glProgramUniform4dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform4f](http://docs.gl/gl4/glProgramUniform)(program, location, v0, v1, v2, v3)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform4f(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLfloat,
            v1: GLfloat,
            v2: GLfloat,
            v3: GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform4f({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1,
                    v2,
                    v3
                );
            }
            let out = call_atomic_ptr_6arg(
                "glProgramUniform4f",
                &self.glProgramUniform4f_p,
                program,
                location,
                v0,
                v1,
                v2,
                v3,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform4f");
            }
            out
        }

        pub unsafe fn ProgramUniform4f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform4f\0",
                &self.glProgramUniform4f_p,
            )
        }
        #[inline]

        pub fn ProgramUniform4f_is_loaded(&self) -> bool {
            !self.glProgramUniform4f_p.load(RELAX).is_null()
        }
        /// [glProgramUniform4fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform4fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform4fv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform4fv",
                &self.glProgramUniform4fv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform4fv");
            }
            out
        }

        pub unsafe fn ProgramUniform4fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform4fv\0",
                &self.glProgramUniform4fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform4fv_is_loaded(&self) -> bool {
            !self.glProgramUniform4fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform4i](http://docs.gl/gl4/glProgramUniform)(program, location, v0, v1, v2, v3)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform4i(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLint,
            v1: GLint,
            v2: GLint,
            v3: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform4i({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1,
                    v2,
                    v3
                );
            }
            let out = call_atomic_ptr_6arg(
                "glProgramUniform4i",
                &self.glProgramUniform4i_p,
                program,
                location,
                v0,
                v1,
                v2,
                v3,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform4i");
            }
            out
        }

        pub unsafe fn ProgramUniform4i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform4i\0",
                &self.glProgramUniform4i_p,
            )
        }
        #[inline]

        pub fn ProgramUniform4i_is_loaded(&self) -> bool {
            !self.glProgramUniform4i_p.load(RELAX).is_null()
        }
        /// [glProgramUniform4iv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform4iv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform4iv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform4iv",
                &self.glProgramUniform4iv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform4iv");
            }
            out
        }

        pub unsafe fn ProgramUniform4iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform4iv\0",
                &self.glProgramUniform4iv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform4iv_is_loaded(&self) -> bool {
            !self.glProgramUniform4iv_p.load(RELAX).is_null()
        }
        /// [glProgramUniform4ui](http://docs.gl/gl4/glProgramUniform)(program, location, v0, v1, v2, v3)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform4ui(
            &self,
            program: GLuint,
            location: GLint,
            v0: GLuint,
            v1: GLuint,
            v2: GLuint,
            v3: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform4ui({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                    program,
                    location,
                    v0,
                    v1,
                    v2,
                    v3
                );
            }
            let out = call_atomic_ptr_6arg(
                "glProgramUniform4ui",
                &self.glProgramUniform4ui_p,
                program,
                location,
                v0,
                v1,
                v2,
                v3,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform4ui");
            }
            out
        }

        pub unsafe fn ProgramUniform4ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform4ui\0",
                &self.glProgramUniform4ui_p,
            )
        }
        #[inline]

        pub fn ProgramUniform4ui_is_loaded(&self) -> bool {
            !self.glProgramUniform4ui_p.load(RELAX).is_null()
        }
        /// [glProgramUniform4uiv](http://docs.gl/gl4/glProgramUniform)(program, location, count, value)
        /// * `program` class: program
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniform4uiv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            value: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniform4uiv({:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glProgramUniform4uiv",
                &self.glProgramUniform4uiv_p,
                program,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniform4uiv");
            }
            out
        }

        pub unsafe fn ProgramUniform4uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniform4uiv\0",
                &self.glProgramUniform4uiv_p,
            )
        }
        #[inline]

        pub fn ProgramUniform4uiv_is_loaded(&self) -> bool {
            !self.glProgramUniform4uiv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix2dv](http://docs.gl/gl4/glProgramUniformMatrix2dv)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix2dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix2dv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix2dv",
                &self.glProgramUniformMatrix2dv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix2dv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix2dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix2dv\0",
                &self.glProgramUniformMatrix2dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix2dv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix2dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix2fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix2fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix2fv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix2fv",
                &self.glProgramUniformMatrix2fv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix2fv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix2fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix2fv\0",
                &self.glProgramUniformMatrix2fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix2fv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix2fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix2x3dv](http://docs.gl/gl4/glProgramUniformMatrix2x3dv)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*6
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix2x3dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix2x3dv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix2x3dv",
                &self.glProgramUniformMatrix2x3dv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix2x3dv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix2x3dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix2x3dv\0",
                &self.glProgramUniformMatrix2x3dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix2x3dv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix2x3dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix2x3fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*6
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix2x3fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix2x3fv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix2x3fv",
                &self.glProgramUniformMatrix2x3fv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix2x3fv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix2x3fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix2x3fv\0",
                &self.glProgramUniformMatrix2x3fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix2x3fv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix2x3fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix2x4dv](http://docs.gl/gl4/glProgramUniformMatrix2x4dv)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*8
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix2x4dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix2x4dv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix2x4dv",
                &self.glProgramUniformMatrix2x4dv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix2x4dv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix2x4dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix2x4dv\0",
                &self.glProgramUniformMatrix2x4dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix2x4dv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix2x4dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix2x4fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*8
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix2x4fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix2x4fv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix2x4fv",
                &self.glProgramUniformMatrix2x4fv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix2x4fv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix2x4fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix2x4fv\0",
                &self.glProgramUniformMatrix2x4fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix2x4fv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix2x4fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix3dv](http://docs.gl/gl4/glProgramUniformMatrix3dv)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*9
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix3dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix3dv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix3dv",
                &self.glProgramUniformMatrix3dv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix3dv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix3dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix3dv\0",
                &self.glProgramUniformMatrix3dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix3dv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix3dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix3fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*9
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix3fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix3fv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix3fv",
                &self.glProgramUniformMatrix3fv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix3fv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix3fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix3fv\0",
                &self.glProgramUniformMatrix3fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix3fv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix3fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix3x2dv](http://docs.gl/gl4/glProgramUniformMatrix3x2dv)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*6
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix3x2dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix3x2dv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix3x2dv",
                &self.glProgramUniformMatrix3x2dv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix3x2dv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix3x2dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix3x2dv\0",
                &self.glProgramUniformMatrix3x2dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix3x2dv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix3x2dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix3x2fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*6
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix3x2fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix3x2fv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix3x2fv",
                &self.glProgramUniformMatrix3x2fv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix3x2fv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix3x2fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix3x2fv\0",
                &self.glProgramUniformMatrix3x2fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix3x2fv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix3x2fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix3x4dv](http://docs.gl/gl4/glProgramUniformMatrix3x4dv)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*12
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix3x4dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix3x4dv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix3x4dv",
                &self.glProgramUniformMatrix3x4dv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix3x4dv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix3x4dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix3x4dv\0",
                &self.glProgramUniformMatrix3x4dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix3x4dv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix3x4dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix3x4fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*12
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix3x4fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix3x4fv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix3x4fv",
                &self.glProgramUniformMatrix3x4fv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix3x4fv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix3x4fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix3x4fv\0",
                &self.glProgramUniformMatrix3x4fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix3x4fv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix3x4fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix4dv](http://docs.gl/gl4/glProgramUniformMatrix4dv)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*16
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix4dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix4dv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix4dv",
                &self.glProgramUniformMatrix4dv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix4dv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix4dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix4dv\0",
                &self.glProgramUniformMatrix4dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix4dv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix4dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix4fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*16
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix4fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix4fv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix4fv",
                &self.glProgramUniformMatrix4fv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix4fv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix4fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix4fv\0",
                &self.glProgramUniformMatrix4fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix4fv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix4fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix4x2dv](http://docs.gl/gl4/glProgramUniformMatrix4x2dv)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*8
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix4x2dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix4x2dv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix4x2dv",
                &self.glProgramUniformMatrix4x2dv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix4x2dv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix4x2dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix4x2dv\0",
                &self.glProgramUniformMatrix4x2dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix4x2dv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix4x2dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix4x2fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*8
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix4x2fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix4x2fv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix4x2fv",
                &self.glProgramUniformMatrix4x2fv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix4x2fv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix4x2fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix4x2fv\0",
                &self.glProgramUniformMatrix4x2fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix4x2fv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix4x2fv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix4x3dv](http://docs.gl/gl4/glProgramUniformMatrix4x3dv)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*12
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix4x3dv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix4x3dv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix4x3dv",
                &self.glProgramUniformMatrix4x3dv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix4x3dv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix4x3dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix4x3dv\0",
                &self.glProgramUniformMatrix4x3dv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix4x3dv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix4x3dv_p.load(RELAX).is_null()
        }
        /// [glProgramUniformMatrix4x3fv](http://docs.gl/gl4/glProgramUniform)(program, location, count, transpose, value)
        /// * `program` class: program
        /// * `value` len: count*12
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProgramUniformMatrix4x3fv(
            &self,
            program: GLuint,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ProgramUniformMatrix4x3fv({:?}, {:?}, {:?}, {:?}, {:p});",
                    program,
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_5arg(
                "glProgramUniformMatrix4x3fv",
                &self.glProgramUniformMatrix4x3fv_p,
                program,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProgramUniformMatrix4x3fv");
            }
            out
        }

        pub unsafe fn ProgramUniformMatrix4x3fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProgramUniformMatrix4x3fv\0",
                &self.glProgramUniformMatrix4x3fv_p,
            )
        }
        #[inline]

        pub fn ProgramUniformMatrix4x3fv_is_loaded(&self) -> bool {
            !self.glProgramUniformMatrix4x3fv_p.load(RELAX).is_null()
        }
        /// [glProvokingVertex](http://docs.gl/gl4/glProvokingVertex)(mode)
        /// * `mode` group: VertexProvokingMode
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ProvokingVertex(&self, mode: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ProvokingVertex({:#X});", mode);
            }
            let out = call_atomic_ptr_1arg("glProvokingVertex", &self.glProvokingVertex_p, mode);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glProvokingVertex");
            }
            out
        }

        pub unsafe fn ProvokingVertex_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glProvokingVertex\0",
                &self.glProvokingVertex_p,
            )
        }
        #[inline]

        pub fn ProvokingVertex_is_loaded(&self) -> bool {
            !self.glProvokingVertex_p.load(RELAX).is_null()
        }
        /// [glPushDebugGroup](http://docs.gl/gl4/glPushDebugGroup)(source, id, length, message)
        /// * `source` group: DebugSource
        /// * `message` len: COMPSIZE(message,length)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn PushDebugGroup(
            &self,
            source: GLenum,
            id: GLuint,
            length: GLsizei,
            message: *const GLchar,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.PushDebugGroup({:#X}, {:?}, {:?}, {:p});",
                    source,
                    id,
                    length,
                    message
                );
            }
            let out = call_atomic_ptr_4arg(
                "glPushDebugGroup",
                &self.glPushDebugGroup_p,
                source,
                id,
                length,
                message,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glPushDebugGroup");
            }
            out
        }

        pub unsafe fn PushDebugGroup_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glPushDebugGroup\0",
                &self.glPushDebugGroup_p,
            )
        }
        #[inline]

        pub fn PushDebugGroup_is_loaded(&self) -> bool {
            !self.glPushDebugGroup_p.load(RELAX).is_null()
        }
        /// [glQueryCounter](http://docs.gl/gl4/glQueryCounter)(id, target)
        /// * `id` class: query
        /// * `target` group: QueryCounterTarget
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn QueryCounter(&self, id: GLuint, target: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.QueryCounter({:?}, {:#X});", id, target);
            }
            let out = call_atomic_ptr_2arg("glQueryCounter", &self.glQueryCounter_p, id, target);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glQueryCounter");
            }
            out
        }

        pub unsafe fn QueryCounter_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glQueryCounter\0",
                &self.glQueryCounter_p,
            )
        }
        #[inline]

        pub fn QueryCounter_is_loaded(&self) -> bool {
            !self.glQueryCounter_p.load(RELAX).is_null()
        }
        /// [glReadBuffer](http://docs.gl/gl4/glReadBuffer)(src)
        /// * `src` group: ReadBufferMode
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ReadBuffer(&self, src: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ReadBuffer({:#X});", src);
            }
            let out = call_atomic_ptr_1arg("glReadBuffer", &self.glReadBuffer_p, src);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glReadBuffer");
            }
            out
        }

        pub unsafe fn ReadBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glReadBuffer\0", &self.glReadBuffer_p)
        }
        #[inline]

        pub fn ReadBuffer_is_loaded(&self) -> bool {
            !self.glReadBuffer_p.load(RELAX).is_null()
        }
        /// [glReadPixels](http://docs.gl/gl4/glReadPixels)(x, y, width, height, format, type_, pixels)
        /// * `x` group: WinCoord
        /// * `y` group: WinCoord
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `pixels` len: COMPSIZE(format,type,width,height)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ReadPixels(
            &self,
            x: GLint,
            y: GLint,
            width: GLsizei,
            height: GLsizei,
            format: GLenum,
            type_: GLenum,
            pixels: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ReadPixels({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                    x,
                    y,
                    width,
                    height,
                    format,
                    type_,
                    pixels
                );
            }
            let out = call_atomic_ptr_7arg(
                "glReadPixels",
                &self.glReadPixels_p,
                x,
                y,
                width,
                height,
                format,
                type_,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glReadPixels");
            }
            out
        }

        pub unsafe fn ReadPixels_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glReadPixels\0", &self.glReadPixels_p)
        }
        #[inline]

        pub fn ReadPixels_is_loaded(&self) -> bool {
            !self.glReadPixels_p.load(RELAX).is_null()
        }
        /// [glReadnPixels](http://docs.gl/gl4/glReadnPixels)(x, y, width, height, format, type_, bufSize, data)
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `data` len: bufSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ReadnPixels(
            &self,
            x: GLint,
            y: GLint,
            width: GLsizei,
            height: GLsizei,
            format: GLenum,
            type_: GLenum,
            bufSize: GLsizei,
            data: *mut c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ReadnPixels({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});",
                    x,
                    y,
                    width,
                    height,
                    format,
                    type_,
                    bufSize,
                    data
                );
            }
            let out = call_atomic_ptr_8arg(
                "glReadnPixels",
                &self.glReadnPixels_p,
                x,
                y,
                width,
                height,
                format,
                type_,
                bufSize,
                data,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glReadnPixels");
            }
            out
        }

        pub unsafe fn ReadnPixels_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glReadnPixels\0", &self.glReadnPixels_p)
        }
        #[inline]

        pub fn ReadnPixels_is_loaded(&self) -> bool {
            !self.glReadnPixels_p.load(RELAX).is_null()
        }
        /// [glReleaseShaderCompiler](http://docs.gl/gl4/glReleaseShaderCompiler)()
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ReleaseShaderCompiler(&self) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ReleaseShaderCompiler();",);
            }
            let out =
                call_atomic_ptr_0arg("glReleaseShaderCompiler", &self.glReleaseShaderCompiler_p);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glReleaseShaderCompiler");
            }
            out
        }

        pub unsafe fn ReleaseShaderCompiler_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glReleaseShaderCompiler\0",
                &self.glReleaseShaderCompiler_p,
            )
        }
        #[inline]

        pub fn ReleaseShaderCompiler_is_loaded(&self) -> bool {
            !self.glReleaseShaderCompiler_p.load(RELAX).is_null()
        }
        /// [glRenderbufferStorage](http://docs.gl/gl4/glRenderbufferStorage)(target, internalformat, width, height)
        /// * `target` group: RenderbufferTarget
        /// * `internalformat` group: InternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn RenderbufferStorage(
            &self,
            target: GLenum,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.RenderbufferStorage({:#X}, {:#X}, {:?}, {:?});",
                    target,
                    internalformat,
                    width,
                    height
                );
            }
            let out = call_atomic_ptr_4arg(
                "glRenderbufferStorage",
                &self.glRenderbufferStorage_p,
                target,
                internalformat,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glRenderbufferStorage");
            }
            out
        }

        pub unsafe fn RenderbufferStorage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glRenderbufferStorage\0",
                &self.glRenderbufferStorage_p,
            )
        }
        #[inline]

        pub fn RenderbufferStorage_is_loaded(&self) -> bool {
            !self.glRenderbufferStorage_p.load(RELAX).is_null()
        }
        /// [glRenderbufferStorageMultisample](http://docs.gl/gl4/glRenderbufferStorageMultisample)(target, samples, internalformat, width, height)
        /// * `target` group: RenderbufferTarget
        /// * `internalformat` group: InternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn RenderbufferStorageMultisample(
            &self,
            target: GLenum,
            samples: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.RenderbufferStorageMultisample({:#X}, {:?}, {:#X}, {:?}, {:?});",
                    target,
                    samples,
                    internalformat,
                    width,
                    height
                );
            }
            let out = call_atomic_ptr_5arg(
                "glRenderbufferStorageMultisample",
                &self.glRenderbufferStorageMultisample_p,
                target,
                samples,
                internalformat,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glRenderbufferStorageMultisample");
            }
            out
        }

        pub unsafe fn RenderbufferStorageMultisample_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glRenderbufferStorageMultisample\0",
                &self.glRenderbufferStorageMultisample_p,
            )
        }
        #[inline]

        pub fn RenderbufferStorageMultisample_is_loaded(&self) -> bool {
            !self
                .glRenderbufferStorageMultisample_p
                .load(RELAX)
                .is_null()
        }
        /// [glResumeTransformFeedback](http://docs.gl/gl4/glResumeTransformFeedback)()
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ResumeTransformFeedback(&self) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ResumeTransformFeedback();",);
            }
            let out = call_atomic_ptr_0arg(
                "glResumeTransformFeedback",
                &self.glResumeTransformFeedback_p,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glResumeTransformFeedback");
            }
            out
        }

        pub unsafe fn ResumeTransformFeedback_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glResumeTransformFeedback\0",
                &self.glResumeTransformFeedback_p,
            )
        }
        #[inline]

        pub fn ResumeTransformFeedback_is_loaded(&self) -> bool {
            !self.glResumeTransformFeedback_p.load(RELAX).is_null()
        }
        /// [glSampleCoverage](http://docs.gl/gl4/glSampleCoverage)(value, invert)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn SampleCoverage(&self, value: GLfloat, invert: GLboolean) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.SampleCoverage({:?}, {:?});", value, invert);
            }
            let out =
                call_atomic_ptr_2arg("glSampleCoverage", &self.glSampleCoverage_p, value, invert);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glSampleCoverage");
            }
            out
        }

        pub unsafe fn SampleCoverage_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glSampleCoverage\0",
                &self.glSampleCoverage_p,
            )
        }
        #[inline]

        pub fn SampleCoverage_is_loaded(&self) -> bool {
            !self.glSampleCoverage_p.load(RELAX).is_null()
        }
        /// [glSampleMaski](http://docs.gl/gl4/glSampleMask)(maskNumber, mask)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn SampleMaski(&self, maskNumber: GLuint, mask: GLbitfield) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.SampleMaski({:?}, {:?});", maskNumber, mask);
            }
            let out =
                call_atomic_ptr_2arg("glSampleMaski", &self.glSampleMaski_p, maskNumber, mask);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glSampleMaski");
            }
            out
        }

        pub unsafe fn SampleMaski_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glSampleMaski\0", &self.glSampleMaski_p)
        }
        #[inline]

        pub fn SampleMaski_is_loaded(&self) -> bool {
            !self.glSampleMaski_p.load(RELAX).is_null()
        }
        /// [glSamplerParameterIiv](http://docs.gl/gl4/glSamplerParameter)(sampler, pname, param)
        /// * `sampler` class: sampler
        /// * `pname` group: SamplerParameterI
        /// * `param` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn SamplerParameterIiv(
            &self,
            sampler: GLuint,
            pname: GLenum,
            param: *const GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.SamplerParameterIiv({:?}, {:#X}, {:p});",
                    sampler,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glSamplerParameterIiv",
                &self.glSamplerParameterIiv_p,
                sampler,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glSamplerParameterIiv");
            }
            out
        }

        pub unsafe fn SamplerParameterIiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glSamplerParameterIiv\0",
                &self.glSamplerParameterIiv_p,
            )
        }
        #[inline]

        pub fn SamplerParameterIiv_is_loaded(&self) -> bool {
            !self.glSamplerParameterIiv_p.load(RELAX).is_null()
        }
        /// [glSamplerParameterIuiv](http://docs.gl/gl4/glSamplerParameter)(sampler, pname, param)
        /// * `sampler` class: sampler
        /// * `pname` group: SamplerParameterI
        /// * `param` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn SamplerParameterIuiv(
            &self,
            sampler: GLuint,
            pname: GLenum,
            param: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.SamplerParameterIuiv({:?}, {:#X}, {:p});",
                    sampler,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glSamplerParameterIuiv",
                &self.glSamplerParameterIuiv_p,
                sampler,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glSamplerParameterIuiv");
            }
            out
        }

        pub unsafe fn SamplerParameterIuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glSamplerParameterIuiv\0",
                &self.glSamplerParameterIuiv_p,
            )
        }
        #[inline]

        pub fn SamplerParameterIuiv_is_loaded(&self) -> bool {
            !self.glSamplerParameterIuiv_p.load(RELAX).is_null()
        }
        /// [glSamplerParameterf](http://docs.gl/gl4/glSamplerParameter)(sampler, pname, param)
        /// * `sampler` class: sampler
        /// * `pname` group: SamplerParameterF
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn SamplerParameterf(&self, sampler: GLuint, pname: GLenum, param: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.SamplerParameterf({:?}, {:#X}, {:?});",
                    sampler,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glSamplerParameterf",
                &self.glSamplerParameterf_p,
                sampler,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glSamplerParameterf");
            }
            out
        }

        pub unsafe fn SamplerParameterf_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glSamplerParameterf\0",
                &self.glSamplerParameterf_p,
            )
        }
        #[inline]

        pub fn SamplerParameterf_is_loaded(&self) -> bool {
            !self.glSamplerParameterf_p.load(RELAX).is_null()
        }
        /// [glSamplerParameterfv](http://docs.gl/gl4/glSamplerParameter)(sampler, pname, param)
        /// * `sampler` class: sampler
        /// * `pname` group: SamplerParameterF
        /// * `param` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn SamplerParameterfv(
            &self,
            sampler: GLuint,
            pname: GLenum,
            param: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.SamplerParameterfv({:?}, {:#X}, {:p});",
                    sampler,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glSamplerParameterfv",
                &self.glSamplerParameterfv_p,
                sampler,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glSamplerParameterfv");
            }
            out
        }

        pub unsafe fn SamplerParameterfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glSamplerParameterfv\0",
                &self.glSamplerParameterfv_p,
            )
        }
        #[inline]

        pub fn SamplerParameterfv_is_loaded(&self) -> bool {
            !self.glSamplerParameterfv_p.load(RELAX).is_null()
        }
        /// [glSamplerParameteri](http://docs.gl/gl4/glSamplerParameter)(sampler, pname, param)
        /// * `sampler` class: sampler
        /// * `pname` group: SamplerParameterI
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn SamplerParameteri(&self, sampler: GLuint, pname: GLenum, param: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.SamplerParameteri({:?}, {:#X}, {:?});",
                    sampler,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glSamplerParameteri",
                &self.glSamplerParameteri_p,
                sampler,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glSamplerParameteri");
            }
            out
        }

        pub unsafe fn SamplerParameteri_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glSamplerParameteri\0",
                &self.glSamplerParameteri_p,
            )
        }
        #[inline]

        pub fn SamplerParameteri_is_loaded(&self) -> bool {
            !self.glSamplerParameteri_p.load(RELAX).is_null()
        }
        /// [glSamplerParameteriv](http://docs.gl/gl4/glSamplerParameter)(sampler, pname, param)
        /// * `sampler` class: sampler
        /// * `pname` group: SamplerParameterI
        /// * `param` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn SamplerParameteriv(
            &self,
            sampler: GLuint,
            pname: GLenum,
            param: *const GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.SamplerParameteriv({:?}, {:#X}, {:p});",
                    sampler,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glSamplerParameteriv",
                &self.glSamplerParameteriv_p,
                sampler,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glSamplerParameteriv");
            }
            out
        }

        pub unsafe fn SamplerParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glSamplerParameteriv\0",
                &self.glSamplerParameteriv_p,
            )
        }
        #[inline]

        pub fn SamplerParameteriv_is_loaded(&self) -> bool {
            !self.glSamplerParameteriv_p.load(RELAX).is_null()
        }
        /// [glScissor](http://docs.gl/gl4/glScissor)(x, y, width, height)
        /// * `x` group: WinCoord
        /// * `y` group: WinCoord
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Scissor(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Scissor({:?}, {:?}, {:?}, {:?});",
                    x,
                    y,
                    width,
                    height
                );
            }
            let out = call_atomic_ptr_4arg("glScissor", &self.glScissor_p, x, y, width, height);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glScissor");
            }
            out
        }

        pub unsafe fn Scissor_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glScissor\0", &self.glScissor_p)
        }
        #[inline]

        pub fn Scissor_is_loaded(&self) -> bool {
            !self.glScissor_p.load(RELAX).is_null()
        }
        /// [glScissorArrayv](http://docs.gl/gl4/glScissorArrayv)(first, count, v)
        /// * `v` len: COMPSIZE(count)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ScissorArrayv(&self, first: GLuint, count: GLsizei, v: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ScissorArrayv({:?}, {:?}, {:p});",
                    first,
                    count,
                    v
                );
            }
            let out =
                call_atomic_ptr_3arg("glScissorArrayv", &self.glScissorArrayv_p, first, count, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glScissorArrayv");
            }
            out
        }

        pub unsafe fn ScissorArrayv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glScissorArrayv\0",
                &self.glScissorArrayv_p,
            )
        }
        #[inline]

        pub fn ScissorArrayv_is_loaded(&self) -> bool {
            !self.glScissorArrayv_p.load(RELAX).is_null()
        }
        /// [glScissorIndexed](http://docs.gl/gl4/glScissorIndexed)(index, left, bottom, width, height)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ScissorIndexed(
            &self,
            index: GLuint,
            left: GLint,
            bottom: GLint,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ScissorIndexed({:?}, {:?}, {:?}, {:?}, {:?});",
                    index,
                    left,
                    bottom,
                    width,
                    height
                );
            }
            let out = call_atomic_ptr_5arg(
                "glScissorIndexed",
                &self.glScissorIndexed_p,
                index,
                left,
                bottom,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glScissorIndexed");
            }
            out
        }

        pub unsafe fn ScissorIndexed_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glScissorIndexed\0",
                &self.glScissorIndexed_p,
            )
        }
        #[inline]

        pub fn ScissorIndexed_is_loaded(&self) -> bool {
            !self.glScissorIndexed_p.load(RELAX).is_null()
        }
        /// [glScissorIndexedv](http://docs.gl/gl4/glScissorIndexedv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ScissorIndexedv(&self, index: GLuint, v: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ScissorIndexedv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glScissorIndexedv", &self.glScissorIndexedv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glScissorIndexedv");
            }
            out
        }

        pub unsafe fn ScissorIndexedv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glScissorIndexedv\0",
                &self.glScissorIndexedv_p,
            )
        }
        #[inline]

        pub fn ScissorIndexedv_is_loaded(&self) -> bool {
            !self.glScissorIndexedv_p.load(RELAX).is_null()
        }
        /// [glShaderBinary](http://docs.gl/gl4/glShaderBinary)(count, shaders, binaryFormat, binary, length)
        /// * `shaders` len: count
        /// * `shaders` class: shader
        /// * `binaryFormat` group: ShaderBinaryFormat
        /// * `binary` len: length
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ShaderBinary(
            &self,
            count: GLsizei,
            shaders: *const GLuint,
            binaryFormat: GLenum,
            binary: *const c_void,
            length: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ShaderBinary({:?}, {:p}, {:#X}, {:p}, {:?});",
                    count,
                    shaders,
                    binaryFormat,
                    binary,
                    length
                );
            }
            let out = call_atomic_ptr_5arg(
                "glShaderBinary",
                &self.glShaderBinary_p,
                count,
                shaders,
                binaryFormat,
                binary,
                length,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glShaderBinary");
            }
            out
        }

        pub unsafe fn ShaderBinary_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glShaderBinary\0",
                &self.glShaderBinary_p,
            )
        }
        #[inline]

        pub fn ShaderBinary_is_loaded(&self) -> bool {
            !self.glShaderBinary_p.load(RELAX).is_null()
        }
        /// [glShaderSource](http://docs.gl/gl4/glShaderSource)(shader, count, string, length)
        /// * `shader` class: shader
        /// * `string` len: count
        /// * `length` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ShaderSource(
            &self,
            shader: GLuint,
            count: GLsizei,
            string: *const *const GLchar,
            length: *const GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ShaderSource({:?}, {:?}, {:p}, {:p});",
                    shader,
                    count,
                    string,
                    length
                );
            }
            let out = call_atomic_ptr_4arg(
                "glShaderSource",
                &self.glShaderSource_p,
                shader,
                count,
                string,
                length,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glShaderSource");
            }
            out
        }

        pub unsafe fn ShaderSource_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glShaderSource\0",
                &self.glShaderSource_p,
            )
        }
        #[inline]

        pub fn ShaderSource_is_loaded(&self) -> bool {
            !self.glShaderSource_p.load(RELAX).is_null()
        }
        /// [glShaderStorageBlockBinding](http://docs.gl/gl4/glShaderStorageBlockBinding)(program, storageBlockIndex, storageBlockBinding)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ShaderStorageBlockBinding(
            &self,
            program: GLuint,
            storageBlockIndex: GLuint,
            storageBlockBinding: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ShaderStorageBlockBinding({:?}, {:?}, {:?});",
                    program,
                    storageBlockIndex,
                    storageBlockBinding
                );
            }
            let out = call_atomic_ptr_3arg(
                "glShaderStorageBlockBinding",
                &self.glShaderStorageBlockBinding_p,
                program,
                storageBlockIndex,
                storageBlockBinding,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glShaderStorageBlockBinding");
            }
            out
        }

        pub unsafe fn ShaderStorageBlockBinding_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glShaderStorageBlockBinding\0",
                &self.glShaderStorageBlockBinding_p,
            )
        }
        #[inline]

        pub fn ShaderStorageBlockBinding_is_loaded(&self) -> bool {
            !self.glShaderStorageBlockBinding_p.load(RELAX).is_null()
        }
        /// [glSpecializeShader](http://docs.gl/gl4/glSpecializeShader)(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue)
        /// * `shader` class: shader
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn SpecializeShader(
            &self,
            shader: GLuint,
            pEntryPoint: *const GLchar,
            numSpecializationConstants: GLuint,
            pConstantIndex: *const GLuint,
            pConstantValue: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.SpecializeShader({:?}, {:p}, {:?}, {:p}, {:p});",
                    shader,
                    pEntryPoint,
                    numSpecializationConstants,
                    pConstantIndex,
                    pConstantValue
                );
            }
            let out = call_atomic_ptr_5arg(
                "glSpecializeShader",
                &self.glSpecializeShader_p,
                shader,
                pEntryPoint,
                numSpecializationConstants,
                pConstantIndex,
                pConstantValue,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glSpecializeShader");
            }
            out
        }

        pub unsafe fn SpecializeShader_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glSpecializeShader\0",
                &self.glSpecializeShader_p,
            )
        }
        #[inline]

        pub fn SpecializeShader_is_loaded(&self) -> bool {
            !self.glSpecializeShader_p.load(RELAX).is_null()
        }
        /// [glStencilFunc](http://docs.gl/gl4/glStencilFunc)(func, ref_, mask)
        /// * `func` group: StencilFunction
        /// * `ref_` group: StencilValue
        /// * `mask` group: MaskedStencilValue
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn StencilFunc(&self, func: GLenum, ref_: GLint, mask: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.StencilFunc({:#X}, {:?}, {:?});",
                    func,
                    ref_,
                    mask
                );
            }
            let out =
                call_atomic_ptr_3arg("glStencilFunc", &self.glStencilFunc_p, func, ref_, mask);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glStencilFunc");
            }
            out
        }

        pub unsafe fn StencilFunc_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glStencilFunc\0", &self.glStencilFunc_p)
        }
        #[inline]

        pub fn StencilFunc_is_loaded(&self) -> bool {
            !self.glStencilFunc_p.load(RELAX).is_null()
        }
        /// [glStencilFuncSeparate](http://docs.gl/gl4/glStencilFuncSeparate)(face, func, ref_, mask)
        /// * `face` group: StencilFaceDirection
        /// * `func` group: StencilFunction
        /// * `ref_` group: StencilValue
        /// * `mask` group: MaskedStencilValue
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn StencilFuncSeparate(
            &self,
            face: GLenum,
            func: GLenum,
            ref_: GLint,
            mask: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.StencilFuncSeparate({:#X}, {:#X}, {:?}, {:?});",
                    face,
                    func,
                    ref_,
                    mask
                );
            }
            let out = call_atomic_ptr_4arg(
                "glStencilFuncSeparate",
                &self.glStencilFuncSeparate_p,
                face,
                func,
                ref_,
                mask,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glStencilFuncSeparate");
            }
            out
        }

        pub unsafe fn StencilFuncSeparate_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glStencilFuncSeparate\0",
                &self.glStencilFuncSeparate_p,
            )
        }
        #[inline]

        pub fn StencilFuncSeparate_is_loaded(&self) -> bool {
            !self.glStencilFuncSeparate_p.load(RELAX).is_null()
        }
        /// [glStencilMask](http://docs.gl/gl4/glStencilMask)(mask)
        /// * `mask` group: MaskedStencilValue
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn StencilMask(&self, mask: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.StencilMask({:?});", mask);
            }
            let out = call_atomic_ptr_1arg("glStencilMask", &self.glStencilMask_p, mask);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glStencilMask");
            }
            out
        }

        pub unsafe fn StencilMask_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glStencilMask\0", &self.glStencilMask_p)
        }
        #[inline]

        pub fn StencilMask_is_loaded(&self) -> bool {
            !self.glStencilMask_p.load(RELAX).is_null()
        }
        /// [glStencilMaskSeparate](http://docs.gl/gl4/glStencilMaskSeparate)(face, mask)
        /// * `face` group: StencilFaceDirection
        /// * `mask` group: MaskedStencilValue
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn StencilMaskSeparate(&self, face: GLenum, mask: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.StencilMaskSeparate({:#X}, {:?});", face, mask);
            }
            let out = call_atomic_ptr_2arg(
                "glStencilMaskSeparate",
                &self.glStencilMaskSeparate_p,
                face,
                mask,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glStencilMaskSeparate");
            }
            out
        }

        pub unsafe fn StencilMaskSeparate_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glStencilMaskSeparate\0",
                &self.glStencilMaskSeparate_p,
            )
        }
        #[inline]

        pub fn StencilMaskSeparate_is_loaded(&self) -> bool {
            !self.glStencilMaskSeparate_p.load(RELAX).is_null()
        }
        /// [glStencilOp](http://docs.gl/gl4/glStencilOp)(fail, zfail, zpass)
        /// * `fail` group: StencilOp
        /// * `zfail` group: StencilOp
        /// * `zpass` group: StencilOp
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn StencilOp(&self, fail: GLenum, zfail: GLenum, zpass: GLenum) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.StencilOp({:#X}, {:#X}, {:#X});",
                    fail,
                    zfail,
                    zpass
                );
            }
            let out = call_atomic_ptr_3arg("glStencilOp", &self.glStencilOp_p, fail, zfail, zpass);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glStencilOp");
            }
            out
        }

        pub unsafe fn StencilOp_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glStencilOp\0", &self.glStencilOp_p)
        }
        #[inline]

        pub fn StencilOp_is_loaded(&self) -> bool {
            !self.glStencilOp_p.load(RELAX).is_null()
        }
        /// [glStencilOpSeparate](http://docs.gl/gl4/glStencilOpSeparate)(face, sfail, dpfail, dppass)
        /// * `face` group: StencilFaceDirection
        /// * `sfail` group: StencilOp
        /// * `dpfail` group: StencilOp
        /// * `dppass` group: StencilOp
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn StencilOpSeparate(
            &self,
            face: GLenum,
            sfail: GLenum,
            dpfail: GLenum,
            dppass: GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.StencilOpSeparate({:#X}, {:#X}, {:#X}, {:#X});",
                    face,
                    sfail,
                    dpfail,
                    dppass
                );
            }
            let out = call_atomic_ptr_4arg(
                "glStencilOpSeparate",
                &self.glStencilOpSeparate_p,
                face,
                sfail,
                dpfail,
                dppass,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glStencilOpSeparate");
            }
            out
        }

        pub unsafe fn StencilOpSeparate_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glStencilOpSeparate\0",
                &self.glStencilOpSeparate_p,
            )
        }
        #[inline]

        pub fn StencilOpSeparate_is_loaded(&self) -> bool {
            !self.glStencilOpSeparate_p.load(RELAX).is_null()
        }
        /// [glTexBuffer](http://docs.gl/gl4/glTexBuffer)(target, internalformat, buffer)
        /// * `target` group: TextureTarget
        /// * `internalformat` group: SizedInternalFormat
        /// * `buffer` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexBuffer(&self, target: GLenum, internalformat: GLenum, buffer: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexBuffer({:#X}, {:#X}, {:?});",
                    target,
                    internalformat,
                    buffer
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTexBuffer",
                &self.glTexBuffer_p,
                target,
                internalformat,
                buffer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexBuffer");
            }
            out
        }

        pub unsafe fn TexBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glTexBuffer\0", &self.glTexBuffer_p)
        }
        #[inline]

        pub fn TexBuffer_is_loaded(&self) -> bool {
            !self.glTexBuffer_p.load(RELAX).is_null()
        }
        /// [glTexBufferRange](http://docs.gl/gl4/glTexBufferRange)(target, internalformat, buffer, offset, size)
        /// * `target` group: TextureTarget
        /// * `internalformat` group: SizedInternalFormat
        /// * `buffer` class: buffer
        /// * `offset` group: BufferOffset
        /// * `size` group: BufferSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexBufferRange(
            &self,
            target: GLenum,
            internalformat: GLenum,
            buffer: GLuint,
            offset: GLintptr,
            size: GLsizeiptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexBufferRange({:#X}, {:#X}, {:?}, {:?}, {:?});",
                    target,
                    internalformat,
                    buffer,
                    offset,
                    size
                );
            }
            let out = call_atomic_ptr_5arg(
                "glTexBufferRange",
                &self.glTexBufferRange_p,
                target,
                internalformat,
                buffer,
                offset,
                size,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexBufferRange");
            }
            out
        }

        pub unsafe fn TexBufferRange_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexBufferRange\0",
                &self.glTexBufferRange_p,
            )
        }
        #[inline]

        pub fn TexBufferRange_is_loaded(&self) -> bool {
            !self.glTexBufferRange_p.load(RELAX).is_null()
        }
        /// [glTexImage1D](http://docs.gl/gl4/glTexImage1D)(target, level, internalformat, width, border, format, type_, pixels)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `internalformat` group: InternalFormat
        /// * `border` group: CheckedInt32
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `pixels` len: COMPSIZE(format,type,width)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexImage1D(
            &self,
            target: GLenum,
            level: GLint,
            internalformat: GLint,
            width: GLsizei,
            border: GLint,
            format: GLenum,
            type_: GLenum,
            pixels: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexImage1D({:#X}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                    target,
                    level,
                    internalformat,
                    width,
                    border,
                    format,
                    type_,
                    pixels
                );
            }
            let out = call_atomic_ptr_8arg(
                "glTexImage1D",
                &self.glTexImage1D_p,
                target,
                level,
                internalformat,
                width,
                border,
                format,
                type_,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexImage1D");
            }
            out
        }

        pub unsafe fn TexImage1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glTexImage1D\0", &self.glTexImage1D_p)
        }
        #[inline]

        pub fn TexImage1D_is_loaded(&self) -> bool {
            !self.glTexImage1D_p.load(RELAX).is_null()
        }
        /// [glTexImage2D](http://docs.gl/gl4/glTexImage2D)(target, level, internalformat, width, height, border, format, type_, pixels)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `internalformat` group: InternalFormat
        /// * `border` group: CheckedInt32
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `pixels` len: COMPSIZE(format,type,width,height)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexImage2D(
            &self,
            target: GLenum,
            level: GLint,
            internalformat: GLint,
            width: GLsizei,
            height: GLsizei,
            border: GLint,
            format: GLenum,
            type_: GLenum,
            pixels: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.TexImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, height, border, format, type_, pixels);
            }
            let out = call_atomic_ptr_9arg(
                "glTexImage2D",
                &self.glTexImage2D_p,
                target,
                level,
                internalformat,
                width,
                height,
                border,
                format,
                type_,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexImage2D");
            }
            out
        }

        pub unsafe fn TexImage2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glTexImage2D\0", &self.glTexImage2D_p)
        }
        #[inline]

        pub fn TexImage2D_is_loaded(&self) -> bool {
            !self.glTexImage2D_p.load(RELAX).is_null()
        }
        /// [glTexImage2DMultisample](http://docs.gl/gl4/glTexImage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations)
        /// * `target` group: TextureTarget
        /// * `internalformat` group: InternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexImage2DMultisample(
            &self,
            target: GLenum,
            samples: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
            fixedsamplelocations: GLboolean,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexImage2DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});",
                    target,
                    samples,
                    internalformat,
                    width,
                    height,
                    fixedsamplelocations
                );
            }
            let out = call_atomic_ptr_6arg(
                "glTexImage2DMultisample",
                &self.glTexImage2DMultisample_p,
                target,
                samples,
                internalformat,
                width,
                height,
                fixedsamplelocations,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexImage2DMultisample");
            }
            out
        }

        pub unsafe fn TexImage2DMultisample_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexImage2DMultisample\0",
                &self.glTexImage2DMultisample_p,
            )
        }
        #[inline]

        pub fn TexImage2DMultisample_is_loaded(&self) -> bool {
            !self.glTexImage2DMultisample_p.load(RELAX).is_null()
        }
        /// [glTexImage3D](http://docs.gl/gl4/glTexImage3D)(target, level, internalformat, width, height, depth, border, format, type_, pixels)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `internalformat` group: InternalFormat
        /// * `border` group: CheckedInt32
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `pixels` len: COMPSIZE(format,type,width,height,depth)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexImage3D(
            &self,
            target: GLenum,
            level: GLint,
            internalformat: GLint,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            border: GLint,
            format: GLenum,
            type_: GLenum,
            pixels: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.TexImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, height, depth, border, format, type_, pixels);
            }
            let out = call_atomic_ptr_10arg(
                "glTexImage3D",
                &self.glTexImage3D_p,
                target,
                level,
                internalformat,
                width,
                height,
                depth,
                border,
                format,
                type_,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexImage3D");
            }
            out
        }

        pub unsafe fn TexImage3D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glTexImage3D\0", &self.glTexImage3D_p)
        }
        #[inline]

        pub fn TexImage3D_is_loaded(&self) -> bool {
            !self.glTexImage3D_p.load(RELAX).is_null()
        }
        /// [glTexImage3DMultisample](http://docs.gl/gl4/glTexImage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)
        /// * `target` group: TextureTarget
        /// * `internalformat` group: InternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexImage3DMultisample(
            &self,
            target: GLenum,
            samples: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            fixedsamplelocations: GLboolean,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexImage3DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});",
                    target,
                    samples,
                    internalformat,
                    width,
                    height,
                    depth,
                    fixedsamplelocations
                );
            }
            let out = call_atomic_ptr_7arg(
                "glTexImage3DMultisample",
                &self.glTexImage3DMultisample_p,
                target,
                samples,
                internalformat,
                width,
                height,
                depth,
                fixedsamplelocations,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexImage3DMultisample");
            }
            out
        }

        pub unsafe fn TexImage3DMultisample_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexImage3DMultisample\0",
                &self.glTexImage3DMultisample_p,
            )
        }
        #[inline]

        pub fn TexImage3DMultisample_is_loaded(&self) -> bool {
            !self.glTexImage3DMultisample_p.load(RELAX).is_null()
        }
        /// [glTexParameterIiv](http://docs.gl/gl4/glTexParameter)(target, pname, params)
        /// * `target` group: TextureTarget
        /// * `pname` group: TextureParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexParameterIiv(&self, target: GLenum, pname: GLenum, params: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexParameterIiv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTexParameterIiv",
                &self.glTexParameterIiv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexParameterIiv");
            }
            out
        }

        pub unsafe fn TexParameterIiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexParameterIiv\0",
                &self.glTexParameterIiv_p,
            )
        }
        #[inline]

        pub fn TexParameterIiv_is_loaded(&self) -> bool {
            !self.glTexParameterIiv_p.load(RELAX).is_null()
        }
        /// [glTexParameterIuiv](http://docs.gl/gl4/glTexParameter)(target, pname, params)
        /// * `target` group: TextureTarget
        /// * `pname` group: TextureParameterName
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexParameterIuiv(
            &self,
            target: GLenum,
            pname: GLenum,
            params: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexParameterIuiv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTexParameterIuiv",
                &self.glTexParameterIuiv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexParameterIuiv");
            }
            out
        }

        pub unsafe fn TexParameterIuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexParameterIuiv\0",
                &self.glTexParameterIuiv_p,
            )
        }
        #[inline]

        pub fn TexParameterIuiv_is_loaded(&self) -> bool {
            !self.glTexParameterIuiv_p.load(RELAX).is_null()
        }
        /// [glTexParameterf](http://docs.gl/gl4/glTexParameter)(target, pname, param)
        /// * `target` group: TextureTarget
        /// * `pname` group: TextureParameterName
        /// * `param` group: CheckedFloat32
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexParameterf(&self, target: GLenum, pname: GLenum, param: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexParameterf({:#X}, {:#X}, {:?});",
                    target,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTexParameterf",
                &self.glTexParameterf_p,
                target,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexParameterf");
            }
            out
        }

        pub unsafe fn TexParameterf_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexParameterf\0",
                &self.glTexParameterf_p,
            )
        }
        #[inline]

        pub fn TexParameterf_is_loaded(&self) -> bool {
            !self.glTexParameterf_p.load(RELAX).is_null()
        }
        /// [glTexParameterfv](http://docs.gl/gl4/glTexParameter)(target, pname, params)
        /// * `target` group: TextureTarget
        /// * `pname` group: TextureParameterName
        /// * `params` group: CheckedFloat32
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexParameterfv(&self, target: GLenum, pname: GLenum, params: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexParameterfv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTexParameterfv",
                &self.glTexParameterfv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexParameterfv");
            }
            out
        }

        pub unsafe fn TexParameterfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexParameterfv\0",
                &self.glTexParameterfv_p,
            )
        }
        #[inline]

        pub fn TexParameterfv_is_loaded(&self) -> bool {
            !self.glTexParameterfv_p.load(RELAX).is_null()
        }
        /// [glTexParameteri](http://docs.gl/gl4/glTexParameter)(target, pname, param)
        /// * `target` group: TextureTarget
        /// * `pname` group: TextureParameterName
        /// * `param` group: CheckedInt32
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexParameteri(&self, target: GLenum, pname: GLenum, param: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexParameteri({:#X}, {:#X}, {:?});",
                    target,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTexParameteri",
                &self.glTexParameteri_p,
                target,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexParameteri");
            }
            out
        }

        pub unsafe fn TexParameteri_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexParameteri\0",
                &self.glTexParameteri_p,
            )
        }
        #[inline]

        pub fn TexParameteri_is_loaded(&self) -> bool {
            !self.glTexParameteri_p.load(RELAX).is_null()
        }
        /// [glTexParameteriv](http://docs.gl/gl4/glTexParameter)(target, pname, params)
        /// * `target` group: TextureTarget
        /// * `pname` group: TextureParameterName
        /// * `params` group: CheckedInt32
        /// * `params` len: COMPSIZE(pname)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexParameteriv(&self, target: GLenum, pname: GLenum, params: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexParameteriv({:#X}, {:#X}, {:p});",
                    target,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTexParameteriv",
                &self.glTexParameteriv_p,
                target,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexParameteriv");
            }
            out
        }

        pub unsafe fn TexParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexParameteriv\0",
                &self.glTexParameteriv_p,
            )
        }
        #[inline]

        pub fn TexParameteriv_is_loaded(&self) -> bool {
            !self.glTexParameteriv_p.load(RELAX).is_null()
        }
        /// [glTexStorage1D](http://docs.gl/gl4/glTexStorage1D)(target, levels, internalformat, width)
        /// * `target` group: TextureTarget
        /// * `internalformat` group: SizedInternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexStorage1D(
            &self,
            target: GLenum,
            levels: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexStorage1D({:#X}, {:?}, {:#X}, {:?});",
                    target,
                    levels,
                    internalformat,
                    width
                );
            }
            let out = call_atomic_ptr_4arg(
                "glTexStorage1D",
                &self.glTexStorage1D_p,
                target,
                levels,
                internalformat,
                width,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexStorage1D");
            }
            out
        }

        pub unsafe fn TexStorage1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexStorage1D\0",
                &self.glTexStorage1D_p,
            )
        }
        #[inline]

        pub fn TexStorage1D_is_loaded(&self) -> bool {
            !self.glTexStorage1D_p.load(RELAX).is_null()
        }
        /// [glTexStorage2D](http://docs.gl/gl4/glTexStorage2D)(target, levels, internalformat, width, height)
        /// * `target` group: TextureTarget
        /// * `internalformat` group: SizedInternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexStorage2D(
            &self,
            target: GLenum,
            levels: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexStorage2D({:#X}, {:?}, {:#X}, {:?}, {:?});",
                    target,
                    levels,
                    internalformat,
                    width,
                    height
                );
            }
            let out = call_atomic_ptr_5arg(
                "glTexStorage2D",
                &self.glTexStorage2D_p,
                target,
                levels,
                internalformat,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexStorage2D");
            }
            out
        }

        pub unsafe fn TexStorage2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexStorage2D\0",
                &self.glTexStorage2D_p,
            )
        }
        #[inline]

        pub fn TexStorage2D_is_loaded(&self) -> bool {
            !self.glTexStorage2D_p.load(RELAX).is_null()
        }
        /// [glTexStorage2DMultisample](http://docs.gl/gl4/glTexStorage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations)
        /// * `target` group: TextureTarget
        /// * `internalformat` group: SizedInternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexStorage2DMultisample(
            &self,
            target: GLenum,
            samples: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
            fixedsamplelocations: GLboolean,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexStorage2DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});",
                    target,
                    samples,
                    internalformat,
                    width,
                    height,
                    fixedsamplelocations
                );
            }
            let out = call_atomic_ptr_6arg(
                "glTexStorage2DMultisample",
                &self.glTexStorage2DMultisample_p,
                target,
                samples,
                internalformat,
                width,
                height,
                fixedsamplelocations,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexStorage2DMultisample");
            }
            out
        }

        pub unsafe fn TexStorage2DMultisample_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexStorage2DMultisample\0",
                &self.glTexStorage2DMultisample_p,
            )
        }
        #[inline]

        pub fn TexStorage2DMultisample_is_loaded(&self) -> bool {
            !self.glTexStorage2DMultisample_p.load(RELAX).is_null()
        }
        /// [glTexStorage3D](http://docs.gl/gl4/glTexStorage3D)(target, levels, internalformat, width, height, depth)
        /// * `target` group: TextureTarget
        /// * `internalformat` group: SizedInternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexStorage3D(
            &self,
            target: GLenum,
            levels: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexStorage3D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});",
                    target,
                    levels,
                    internalformat,
                    width,
                    height,
                    depth
                );
            }
            let out = call_atomic_ptr_6arg(
                "glTexStorage3D",
                &self.glTexStorage3D_p,
                target,
                levels,
                internalformat,
                width,
                height,
                depth,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexStorage3D");
            }
            out
        }

        pub unsafe fn TexStorage3D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexStorage3D\0",
                &self.glTexStorage3D_p,
            )
        }
        #[inline]

        pub fn TexStorage3D_is_loaded(&self) -> bool {
            !self.glTexStorage3D_p.load(RELAX).is_null()
        }
        /// [glTexStorage3DMultisample](http://docs.gl/gl4/glTexStorage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)
        /// * `target` group: TextureTarget
        /// * `internalformat` group: SizedInternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexStorage3DMultisample(
            &self,
            target: GLenum,
            samples: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            fixedsamplelocations: GLboolean,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.TexStorage3DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, depth, fixedsamplelocations);
            }
            let out = call_atomic_ptr_7arg(
                "glTexStorage3DMultisample",
                &self.glTexStorage3DMultisample_p,
                target,
                samples,
                internalformat,
                width,
                height,
                depth,
                fixedsamplelocations,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexStorage3DMultisample");
            }
            out
        }

        pub unsafe fn TexStorage3DMultisample_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexStorage3DMultisample\0",
                &self.glTexStorage3DMultisample_p,
            )
        }
        #[inline]

        pub fn TexStorage3DMultisample_is_loaded(&self) -> bool {
            !self.glTexStorage3DMultisample_p.load(RELAX).is_null()
        }
        /// [glTexSubImage1D](http://docs.gl/gl4/glTexSubImage1D)(target, level, xoffset, width, format, type_, pixels)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `xoffset` group: CheckedInt32
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `pixels` len: COMPSIZE(format,type,width)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexSubImage1D(
            &self,
            target: GLenum,
            level: GLint,
            xoffset: GLint,
            width: GLsizei,
            format: GLenum,
            type_: GLenum,
            pixels: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                    target,
                    level,
                    xoffset,
                    width,
                    format,
                    type_,
                    pixels
                );
            }
            let out = call_atomic_ptr_7arg(
                "glTexSubImage1D",
                &self.glTexSubImage1D_p,
                target,
                level,
                xoffset,
                width,
                format,
                type_,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexSubImage1D");
            }
            out
        }

        pub unsafe fn TexSubImage1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexSubImage1D\0",
                &self.glTexSubImage1D_p,
            )
        }
        #[inline]

        pub fn TexSubImage1D_is_loaded(&self) -> bool {
            !self.glTexSubImage1D_p.load(RELAX).is_null()
        }
        /// [glTexSubImage2D](http://docs.gl/gl4/glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type_, pixels)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `xoffset` group: CheckedInt32
        /// * `yoffset` group: CheckedInt32
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `pixels` len: COMPSIZE(format,type,width,height)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexSubImage2D(
            &self,
            target: GLenum,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            format: GLenum,
            type_: GLenum,
            pixels: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.TexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, yoffset, width, height, format, type_, pixels);
            }
            let out = call_atomic_ptr_9arg(
                "glTexSubImage2D",
                &self.glTexSubImage2D_p,
                target,
                level,
                xoffset,
                yoffset,
                width,
                height,
                format,
                type_,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexSubImage2D");
            }
            out
        }

        pub unsafe fn TexSubImage2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexSubImage2D\0",
                &self.glTexSubImage2D_p,
            )
        }
        #[inline]

        pub fn TexSubImage2D_is_loaded(&self) -> bool {
            !self.glTexSubImage2D_p.load(RELAX).is_null()
        }
        /// [glTexSubImage3D](http://docs.gl/gl4/glTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)
        /// * `target` group: TextureTarget
        /// * `level` group: CheckedInt32
        /// * `xoffset` group: CheckedInt32
        /// * `yoffset` group: CheckedInt32
        /// * `zoffset` group: CheckedInt32
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        /// * `pixels` len: COMPSIZE(format,type,width,height,depth)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TexSubImage3D(
            &self,
            target: GLenum,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            zoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            format: GLenum,
            type_: GLenum,
            pixels: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.TexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels);
            }
            let out = call_atomic_ptr_11arg(
                "glTexSubImage3D",
                &self.glTexSubImage3D_p,
                target,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                format,
                type_,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTexSubImage3D");
            }
            out
        }

        pub unsafe fn TexSubImage3D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTexSubImage3D\0",
                &self.glTexSubImage3D_p,
            )
        }
        #[inline]

        pub fn TexSubImage3D_is_loaded(&self) -> bool {
            !self.glTexSubImage3D_p.load(RELAX).is_null()
        }
        /// [glTextureBarrier](http://docs.gl/gl4/glTextureBarrier)()
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureBarrier(&self) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.TextureBarrier();",);
            }
            let out = call_atomic_ptr_0arg("glTextureBarrier", &self.glTextureBarrier_p);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureBarrier");
            }
            out
        }

        pub unsafe fn TextureBarrier_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureBarrier\0",
                &self.glTextureBarrier_p,
            )
        }
        #[inline]

        pub fn TextureBarrier_is_loaded(&self) -> bool {
            !self.glTextureBarrier_p.load(RELAX).is_null()
        }
        /// [glTextureBuffer](http://docs.gl/gl4/glTextureBuffer)(texture, internalformat, buffer)
        /// * `texture` class: texture
        /// * `internalformat` group: SizedInternalFormat
        /// * `buffer` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureBuffer(
            &self,
            texture: GLuint,
            internalformat: GLenum,
            buffer: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureBuffer({:?}, {:#X}, {:?});",
                    texture,
                    internalformat,
                    buffer
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTextureBuffer",
                &self.glTextureBuffer_p,
                texture,
                internalformat,
                buffer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureBuffer");
            }
            out
        }

        pub unsafe fn TextureBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureBuffer\0",
                &self.glTextureBuffer_p,
            )
        }
        #[inline]

        pub fn TextureBuffer_is_loaded(&self) -> bool {
            !self.glTextureBuffer_p.load(RELAX).is_null()
        }
        /// [glTextureBufferRange](http://docs.gl/gl4/glTextureBufferRange)(texture, internalformat, buffer, offset, size)
        /// * `texture` class: texture
        /// * `internalformat` group: SizedInternalFormat
        /// * `buffer` class: buffer
        /// * `size` group: BufferSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureBufferRange(
            &self,
            texture: GLuint,
            internalformat: GLenum,
            buffer: GLuint,
            offset: GLintptr,
            size: GLsizeiptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureBufferRange({:?}, {:#X}, {:?}, {:?}, {:?});",
                    texture,
                    internalformat,
                    buffer,
                    offset,
                    size
                );
            }
            let out = call_atomic_ptr_5arg(
                "glTextureBufferRange",
                &self.glTextureBufferRange_p,
                texture,
                internalformat,
                buffer,
                offset,
                size,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureBufferRange");
            }
            out
        }

        pub unsafe fn TextureBufferRange_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureBufferRange\0",
                &self.glTextureBufferRange_p,
            )
        }
        #[inline]

        pub fn TextureBufferRange_is_loaded(&self) -> bool {
            !self.glTextureBufferRange_p.load(RELAX).is_null()
        }
        /// [glTextureParameterIiv](http://docs.gl/gl4/glTextureParameter)(texture, pname, params)
        /// * `texture` class: texture
        /// * `pname` group: TextureParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureParameterIiv(
            &self,
            texture: GLuint,
            pname: GLenum,
            params: *const GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureParameterIiv({:?}, {:#X}, {:p});",
                    texture,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTextureParameterIiv",
                &self.glTextureParameterIiv_p,
                texture,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureParameterIiv");
            }
            out
        }

        pub unsafe fn TextureParameterIiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureParameterIiv\0",
                &self.glTextureParameterIiv_p,
            )
        }
        #[inline]

        pub fn TextureParameterIiv_is_loaded(&self) -> bool {
            !self.glTextureParameterIiv_p.load(RELAX).is_null()
        }
        /// [glTextureParameterIuiv](http://docs.gl/gl4/glTextureParameter)(texture, pname, params)
        /// * `texture` class: texture
        /// * `pname` group: TextureParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureParameterIuiv(
            &self,
            texture: GLuint,
            pname: GLenum,
            params: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureParameterIuiv({:?}, {:#X}, {:p});",
                    texture,
                    pname,
                    params
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTextureParameterIuiv",
                &self.glTextureParameterIuiv_p,
                texture,
                pname,
                params,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureParameterIuiv");
            }
            out
        }

        pub unsafe fn TextureParameterIuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureParameterIuiv\0",
                &self.glTextureParameterIuiv_p,
            )
        }
        #[inline]

        pub fn TextureParameterIuiv_is_loaded(&self) -> bool {
            !self.glTextureParameterIuiv_p.load(RELAX).is_null()
        }
        /// [glTextureParameterf](http://docs.gl/gl4/glTextureParameter)(texture, pname, param)
        /// * `texture` class: texture
        /// * `pname` group: TextureParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureParameterf(&self, texture: GLuint, pname: GLenum, param: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureParameterf({:?}, {:#X}, {:?});",
                    texture,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTextureParameterf",
                &self.glTextureParameterf_p,
                texture,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureParameterf");
            }
            out
        }

        pub unsafe fn TextureParameterf_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureParameterf\0",
                &self.glTextureParameterf_p,
            )
        }
        #[inline]

        pub fn TextureParameterf_is_loaded(&self) -> bool {
            !self.glTextureParameterf_p.load(RELAX).is_null()
        }
        /// [glTextureParameterfv](http://docs.gl/gl4/glTextureParameter)(texture, pname, param)
        /// * `texture` class: texture
        /// * `pname` group: TextureParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureParameterfv(
            &self,
            texture: GLuint,
            pname: GLenum,
            param: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureParameterfv({:?}, {:#X}, {:p});",
                    texture,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTextureParameterfv",
                &self.glTextureParameterfv_p,
                texture,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureParameterfv");
            }
            out
        }

        pub unsafe fn TextureParameterfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureParameterfv\0",
                &self.glTextureParameterfv_p,
            )
        }
        #[inline]

        pub fn TextureParameterfv_is_loaded(&self) -> bool {
            !self.glTextureParameterfv_p.load(RELAX).is_null()
        }
        /// [glTextureParameteri](http://docs.gl/gl4/glTextureParameter)(texture, pname, param)
        /// * `texture` class: texture
        /// * `pname` group: TextureParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureParameteri(&self, texture: GLuint, pname: GLenum, param: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureParameteri({:?}, {:#X}, {:?});",
                    texture,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTextureParameteri",
                &self.glTextureParameteri_p,
                texture,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureParameteri");
            }
            out
        }

        pub unsafe fn TextureParameteri_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureParameteri\0",
                &self.glTextureParameteri_p,
            )
        }
        #[inline]

        pub fn TextureParameteri_is_loaded(&self) -> bool {
            !self.glTextureParameteri_p.load(RELAX).is_null()
        }
        /// [glTextureParameteriv](http://docs.gl/gl4/glTextureParameter)(texture, pname, param)
        /// * `texture` class: texture
        /// * `pname` group: TextureParameterName
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureParameteriv(
            &self,
            texture: GLuint,
            pname: GLenum,
            param: *const GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureParameteriv({:?}, {:#X}, {:p});",
                    texture,
                    pname,
                    param
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTextureParameteriv",
                &self.glTextureParameteriv_p,
                texture,
                pname,
                param,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureParameteriv");
            }
            out
        }

        pub unsafe fn TextureParameteriv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureParameteriv\0",
                &self.glTextureParameteriv_p,
            )
        }
        #[inline]

        pub fn TextureParameteriv_is_loaded(&self) -> bool {
            !self.glTextureParameteriv_p.load(RELAX).is_null()
        }
        /// [glTextureStorage1D](http://docs.gl/gl4/glTextureStorage1D)(texture, levels, internalformat, width)
        /// * `texture` class: texture
        /// * `internalformat` group: SizedInternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureStorage1D(
            &self,
            texture: GLuint,
            levels: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureStorage1D({:?}, {:?}, {:#X}, {:?});",
                    texture,
                    levels,
                    internalformat,
                    width
                );
            }
            let out = call_atomic_ptr_4arg(
                "glTextureStorage1D",
                &self.glTextureStorage1D_p,
                texture,
                levels,
                internalformat,
                width,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureStorage1D");
            }
            out
        }

        pub unsafe fn TextureStorage1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureStorage1D\0",
                &self.glTextureStorage1D_p,
            )
        }
        #[inline]

        pub fn TextureStorage1D_is_loaded(&self) -> bool {
            !self.glTextureStorage1D_p.load(RELAX).is_null()
        }
        /// [glTextureStorage2D](http://docs.gl/gl4/glTextureStorage2D)(texture, levels, internalformat, width, height)
        /// * `texture` class: texture
        /// * `internalformat` group: SizedInternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureStorage2D(
            &self,
            texture: GLuint,
            levels: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureStorage2D({:?}, {:?}, {:#X}, {:?}, {:?});",
                    texture,
                    levels,
                    internalformat,
                    width,
                    height
                );
            }
            let out = call_atomic_ptr_5arg(
                "glTextureStorage2D",
                &self.glTextureStorage2D_p,
                texture,
                levels,
                internalformat,
                width,
                height,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureStorage2D");
            }
            out
        }

        pub unsafe fn TextureStorage2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureStorage2D\0",
                &self.glTextureStorage2D_p,
            )
        }
        #[inline]

        pub fn TextureStorage2D_is_loaded(&self) -> bool {
            !self.glTextureStorage2D_p.load(RELAX).is_null()
        }
        /// [glTextureStorage2DMultisample](http://docs.gl/gl4/glTextureStorage2DMultisample)(texture, samples, internalformat, width, height, fixedsamplelocations)
        /// * `texture` class: texture
        /// * `internalformat` group: SizedInternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureStorage2DMultisample(
            &self,
            texture: GLuint,
            samples: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
            fixedsamplelocations: GLboolean,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureStorage2DMultisample({:?}, {:?}, {:#X}, {:?}, {:?}, {:?});",
                    texture,
                    samples,
                    internalformat,
                    width,
                    height,
                    fixedsamplelocations
                );
            }
            let out = call_atomic_ptr_6arg(
                "glTextureStorage2DMultisample",
                &self.glTextureStorage2DMultisample_p,
                texture,
                samples,
                internalformat,
                width,
                height,
                fixedsamplelocations,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureStorage2DMultisample");
            }
            out
        }

        pub unsafe fn TextureStorage2DMultisample_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureStorage2DMultisample\0",
                &self.glTextureStorage2DMultisample_p,
            )
        }
        #[inline]

        pub fn TextureStorage2DMultisample_is_loaded(&self) -> bool {
            !self.glTextureStorage2DMultisample_p.load(RELAX).is_null()
        }
        /// [glTextureStorage3D](http://docs.gl/gl4/glTextureStorage3D)(texture, levels, internalformat, width, height, depth)
        /// * `texture` class: texture
        /// * `internalformat` group: SizedInternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureStorage3D(
            &self,
            texture: GLuint,
            levels: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureStorage3D({:?}, {:?}, {:#X}, {:?}, {:?}, {:?});",
                    texture,
                    levels,
                    internalformat,
                    width,
                    height,
                    depth
                );
            }
            let out = call_atomic_ptr_6arg(
                "glTextureStorage3D",
                &self.glTextureStorage3D_p,
                texture,
                levels,
                internalformat,
                width,
                height,
                depth,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureStorage3D");
            }
            out
        }

        pub unsafe fn TextureStorage3D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureStorage3D\0",
                &self.glTextureStorage3D_p,
            )
        }
        #[inline]

        pub fn TextureStorage3D_is_loaded(&self) -> bool {
            !self.glTextureStorage3D_p.load(RELAX).is_null()
        }
        /// [glTextureStorage3DMultisample](http://docs.gl/gl4/glTextureStorage3DMultisample)(texture, samples, internalformat, width, height, depth, fixedsamplelocations)
        /// * `texture` class: texture
        /// * `internalformat` group: SizedInternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureStorage3DMultisample(
            &self,
            texture: GLuint,
            samples: GLsizei,
            internalformat: GLenum,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            fixedsamplelocations: GLboolean,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.TextureStorage3DMultisample({:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", texture, samples, internalformat, width, height, depth, fixedsamplelocations);
            }
            let out = call_atomic_ptr_7arg(
                "glTextureStorage3DMultisample",
                &self.glTextureStorage3DMultisample_p,
                texture,
                samples,
                internalformat,
                width,
                height,
                depth,
                fixedsamplelocations,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureStorage3DMultisample");
            }
            out
        }

        pub unsafe fn TextureStorage3DMultisample_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureStorage3DMultisample\0",
                &self.glTextureStorage3DMultisample_p,
            )
        }
        #[inline]

        pub fn TextureStorage3DMultisample_is_loaded(&self) -> bool {
            !self.glTextureStorage3DMultisample_p.load(RELAX).is_null()
        }
        /// [glTextureSubImage1D](http://docs.gl/gl4/glTextureSubImage1D)(texture, level, xoffset, width, format, type_, pixels)
        /// * `texture` class: texture
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureSubImage1D(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            width: GLsizei,
            format: GLenum,
            type_: GLenum,
            pixels: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureSubImage1D({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                    texture,
                    level,
                    xoffset,
                    width,
                    format,
                    type_,
                    pixels
                );
            }
            let out = call_atomic_ptr_7arg(
                "glTextureSubImage1D",
                &self.glTextureSubImage1D_p,
                texture,
                level,
                xoffset,
                width,
                format,
                type_,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureSubImage1D");
            }
            out
        }

        pub unsafe fn TextureSubImage1D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureSubImage1D\0",
                &self.glTextureSubImage1D_p,
            )
        }
        #[inline]

        pub fn TextureSubImage1D_is_loaded(&self) -> bool {
            !self.glTextureSubImage1D_p.load(RELAX).is_null()
        }
        /// [glTextureSubImage2D](http://docs.gl/gl4/glTextureSubImage2D)(texture, level, xoffset, yoffset, width, height, format, type_, pixels)
        /// * `texture` class: texture
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureSubImage2D(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            format: GLenum,
            type_: GLenum,
            pixels: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.TextureSubImage2D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", texture, level, xoffset, yoffset, width, height, format, type_, pixels);
            }
            let out = call_atomic_ptr_9arg(
                "glTextureSubImage2D",
                &self.glTextureSubImage2D_p,
                texture,
                level,
                xoffset,
                yoffset,
                width,
                height,
                format,
                type_,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureSubImage2D");
            }
            out
        }

        pub unsafe fn TextureSubImage2D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureSubImage2D\0",
                &self.glTextureSubImage2D_p,
            )
        }
        #[inline]

        pub fn TextureSubImage2D_is_loaded(&self) -> bool {
            !self.glTextureSubImage2D_p.load(RELAX).is_null()
        }
        /// [glTextureSubImage3D](http://docs.gl/gl4/glTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)
        /// * `texture` class: texture
        /// * `format` group: PixelFormat
        /// * `type_` group: PixelType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureSubImage3D(
            &self,
            texture: GLuint,
            level: GLint,
            xoffset: GLint,
            yoffset: GLint,
            zoffset: GLint,
            width: GLsizei,
            height: GLsizei,
            depth: GLsizei,
            format: GLenum,
            type_: GLenum,
            pixels: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.TextureSubImage3D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels);
            }
            let out = call_atomic_ptr_11arg(
                "glTextureSubImage3D",
                &self.glTextureSubImage3D_p,
                texture,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                format,
                type_,
                pixels,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureSubImage3D");
            }
            out
        }

        pub unsafe fn TextureSubImage3D_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTextureSubImage3D\0",
                &self.glTextureSubImage3D_p,
            )
        }
        #[inline]

        pub fn TextureSubImage3D_is_loaded(&self) -> bool {
            !self.glTextureSubImage3D_p.load(RELAX).is_null()
        }
        /// [glTextureView](http://docs.gl/gl4/glTextureView)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)
        /// * `texture` class: texture
        /// * `target` group: TextureTarget
        /// * `origtexture` class: texture
        /// * `internalformat` group: SizedInternalFormat
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TextureView(
            &self,
            texture: GLuint,
            target: GLenum,
            origtexture: GLuint,
            internalformat: GLenum,
            minlevel: GLuint,
            numlevels: GLuint,
            minlayer: GLuint,
            numlayers: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TextureView({:?}, {:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});",
                    texture,
                    target,
                    origtexture,
                    internalformat,
                    minlevel,
                    numlevels,
                    minlayer,
                    numlayers
                );
            }
            let out = call_atomic_ptr_8arg(
                "glTextureView",
                &self.glTextureView_p,
                texture,
                target,
                origtexture,
                internalformat,
                minlevel,
                numlevels,
                minlayer,
                numlayers,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTextureView");
            }
            out
        }

        pub unsafe fn TextureView_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glTextureView\0", &self.glTextureView_p)
        }
        #[inline]

        pub fn TextureView_is_loaded(&self) -> bool {
            !self.glTextureView_p.load(RELAX).is_null()
        }
        /// [glTransformFeedbackBufferBase](http://docs.gl/gl4/glTransformFeedbackBufferBase)(xfb, index, buffer)
        /// * `xfb` class: transform feedback
        /// * `buffer` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TransformFeedbackBufferBase(
            &self,
            xfb: GLuint,
            index: GLuint,
            buffer: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TransformFeedbackBufferBase({:?}, {:?}, {:?});",
                    xfb,
                    index,
                    buffer
                );
            }
            let out = call_atomic_ptr_3arg(
                "glTransformFeedbackBufferBase",
                &self.glTransformFeedbackBufferBase_p,
                xfb,
                index,
                buffer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTransformFeedbackBufferBase");
            }
            out
        }

        pub unsafe fn TransformFeedbackBufferBase_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTransformFeedbackBufferBase\0",
                &self.glTransformFeedbackBufferBase_p,
            )
        }
        #[inline]

        pub fn TransformFeedbackBufferBase_is_loaded(&self) -> bool {
            !self.glTransformFeedbackBufferBase_p.load(RELAX).is_null()
        }
        /// [glTransformFeedbackBufferRange](http://docs.gl/gl4/glTransformFeedbackBufferRange)(xfb, index, buffer, offset, size)
        /// * `xfb` class: transform feedback
        /// * `buffer` class: buffer
        /// * `size` group: BufferSize
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TransformFeedbackBufferRange(
            &self,
            xfb: GLuint,
            index: GLuint,
            buffer: GLuint,
            offset: GLintptr,
            size: GLsizeiptr,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TransformFeedbackBufferRange({:?}, {:?}, {:?}, {:?}, {:?});",
                    xfb,
                    index,
                    buffer,
                    offset,
                    size
                );
            }
            let out = call_atomic_ptr_5arg(
                "glTransformFeedbackBufferRange",
                &self.glTransformFeedbackBufferRange_p,
                xfb,
                index,
                buffer,
                offset,
                size,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTransformFeedbackBufferRange");
            }
            out
        }

        pub unsafe fn TransformFeedbackBufferRange_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTransformFeedbackBufferRange\0",
                &self.glTransformFeedbackBufferRange_p,
            )
        }
        #[inline]

        pub fn TransformFeedbackBufferRange_is_loaded(&self) -> bool {
            !self.glTransformFeedbackBufferRange_p.load(RELAX).is_null()
        }
        /// [glTransformFeedbackVaryings](http://docs.gl/gl4/glTransformFeedbackVaryings)(program, count, varyings, bufferMode)
        /// * `program` class: program
        /// * `varyings` len: count
        /// * `bufferMode` group: TransformFeedbackBufferMode
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn TransformFeedbackVaryings(
            &self,
            program: GLuint,
            count: GLsizei,
            varyings: *const *const GLchar,
            bufferMode: GLenum,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.TransformFeedbackVaryings({:?}, {:?}, {:p}, {:#X});",
                    program,
                    count,
                    varyings,
                    bufferMode
                );
            }
            let out = call_atomic_ptr_4arg(
                "glTransformFeedbackVaryings",
                &self.glTransformFeedbackVaryings_p,
                program,
                count,
                varyings,
                bufferMode,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glTransformFeedbackVaryings");
            }
            out
        }

        pub unsafe fn TransformFeedbackVaryings_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glTransformFeedbackVaryings\0",
                &self.glTransformFeedbackVaryings_p,
            )
        }
        #[inline]

        pub fn TransformFeedbackVaryings_is_loaded(&self) -> bool {
            !self.glTransformFeedbackVaryings_p.load(RELAX).is_null()
        }
        /// [glUniform1d](http://docs.gl/gl4/glUniform1d)(location, x)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform1d(&self, location: GLint, x: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Uniform1d({:?}, {:?});", location, x);
            }
            let out = call_atomic_ptr_2arg("glUniform1d", &self.glUniform1d_p, location, x);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform1d");
            }
            out
        }

        pub unsafe fn Uniform1d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1d\0", &self.glUniform1d_p)
        }
        #[inline]

        pub fn Uniform1d_is_loaded(&self) -> bool {
            !self.glUniform1d_p.load(RELAX).is_null()
        }
        /// [glUniform1dv](http://docs.gl/gl4/glUniform1dv)(location, count, value)
        /// * `value` len: count*1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform1dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform1dv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform1dv", &self.glUniform1dv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform1dv");
            }
            out
        }

        pub unsafe fn Uniform1dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1dv\0", &self.glUniform1dv_p)
        }
        #[inline]

        pub fn Uniform1dv_is_loaded(&self) -> bool {
            !self.glUniform1dv_p.load(RELAX).is_null()
        }
        /// [glUniform1f](http://docs.gl/gl4/glUniform)(location, v0)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform1f(&self, location: GLint, v0: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Uniform1f({:?}, {:?});", location, v0);
            }
            let out = call_atomic_ptr_2arg("glUniform1f", &self.glUniform1f_p, location, v0);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform1f");
            }
            out
        }

        pub unsafe fn Uniform1f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1f\0", &self.glUniform1f_p)
        }
        #[inline]

        pub fn Uniform1f_is_loaded(&self) -> bool {
            !self.glUniform1f_p.load(RELAX).is_null()
        }
        /// [glUniform1fv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform1fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform1fv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform1fv", &self.glUniform1fv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform1fv");
            }
            out
        }

        pub unsafe fn Uniform1fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1fv\0", &self.glUniform1fv_p)
        }
        #[inline]

        pub fn Uniform1fv_is_loaded(&self) -> bool {
            !self.glUniform1fv_p.load(RELAX).is_null()
        }
        /// [glUniform1i](http://docs.gl/gl4/glUniform)(location, v0)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform1i(&self, location: GLint, v0: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Uniform1i({:?}, {:?});", location, v0);
            }
            let out = call_atomic_ptr_2arg("glUniform1i", &self.glUniform1i_p, location, v0);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform1i");
            }
            out
        }

        pub unsafe fn Uniform1i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1i\0", &self.glUniform1i_p)
        }
        #[inline]

        pub fn Uniform1i_is_loaded(&self) -> bool {
            !self.glUniform1i_p.load(RELAX).is_null()
        }
        /// [glUniform1iv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform1iv(&self, location: GLint, count: GLsizei, value: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform1iv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform1iv", &self.glUniform1iv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform1iv");
            }
            out
        }

        pub unsafe fn Uniform1iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1iv\0", &self.glUniform1iv_p)
        }
        #[inline]

        pub fn Uniform1iv_is_loaded(&self) -> bool {
            !self.glUniform1iv_p.load(RELAX).is_null()
        }
        /// [glUniform1ui](http://docs.gl/gl4/glUniform)(location, v0)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform1ui(&self, location: GLint, v0: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Uniform1ui({:?}, {:?});", location, v0);
            }
            let out = call_atomic_ptr_2arg("glUniform1ui", &self.glUniform1ui_p, location, v0);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform1ui");
            }
            out
        }

        pub unsafe fn Uniform1ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1ui\0", &self.glUniform1ui_p)
        }
        #[inline]

        pub fn Uniform1ui_is_loaded(&self) -> bool {
            !self.glUniform1ui_p.load(RELAX).is_null()
        }
        /// [glUniform1uiv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform1uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform1uiv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_3arg(
                "glUniform1uiv",
                &self.glUniform1uiv_p,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform1uiv");
            }
            out
        }

        pub unsafe fn Uniform1uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1uiv\0", &self.glUniform1uiv_p)
        }
        #[inline]

        pub fn Uniform1uiv_is_loaded(&self) -> bool {
            !self.glUniform1uiv_p.load(RELAX).is_null()
        }
        /// [glUniform2d](http://docs.gl/gl4/glUniform2d)(location, x, y)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform2d(&self, location: GLint, x: GLdouble, y: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Uniform2d({:?}, {:?}, {:?});", location, x, y);
            }
            let out = call_atomic_ptr_3arg("glUniform2d", &self.glUniform2d_p, location, x, y);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform2d");
            }
            out
        }

        pub unsafe fn Uniform2d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2d\0", &self.glUniform2d_p)
        }
        #[inline]

        pub fn Uniform2d_is_loaded(&self) -> bool {
            !self.glUniform2d_p.load(RELAX).is_null()
        }
        /// [glUniform2dv](http://docs.gl/gl4/glUniform2dv)(location, count, value)
        /// * `value` len: count*2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform2dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform2dv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform2dv", &self.glUniform2dv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform2dv");
            }
            out
        }

        pub unsafe fn Uniform2dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2dv\0", &self.glUniform2dv_p)
        }
        #[inline]

        pub fn Uniform2dv_is_loaded(&self) -> bool {
            !self.glUniform2dv_p.load(RELAX).is_null()
        }
        /// [glUniform2f](http://docs.gl/gl4/glUniform)(location, v0, v1)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform2f(&self, location: GLint, v0: GLfloat, v1: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Uniform2f({:?}, {:?}, {:?});", location, v0, v1);
            }
            let out = call_atomic_ptr_3arg("glUniform2f", &self.glUniform2f_p, location, v0, v1);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform2f");
            }
            out
        }

        pub unsafe fn Uniform2f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2f\0", &self.glUniform2f_p)
        }
        #[inline]

        pub fn Uniform2f_is_loaded(&self) -> bool {
            !self.glUniform2f_p.load(RELAX).is_null()
        }
        /// [glUniform2fv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform2fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform2fv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform2fv", &self.glUniform2fv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform2fv");
            }
            out
        }

        pub unsafe fn Uniform2fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2fv\0", &self.glUniform2fv_p)
        }
        #[inline]

        pub fn Uniform2fv_is_loaded(&self) -> bool {
            !self.glUniform2fv_p.load(RELAX).is_null()
        }
        /// [glUniform2i](http://docs.gl/gl4/glUniform)(location, v0, v1)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform2i(&self, location: GLint, v0: GLint, v1: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Uniform2i({:?}, {:?}, {:?});", location, v0, v1);
            }
            let out = call_atomic_ptr_3arg("glUniform2i", &self.glUniform2i_p, location, v0, v1);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform2i");
            }
            out
        }

        pub unsafe fn Uniform2i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2i\0", &self.glUniform2i_p)
        }
        #[inline]

        pub fn Uniform2i_is_loaded(&self) -> bool {
            !self.glUniform2i_p.load(RELAX).is_null()
        }
        /// [glUniform2iv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform2iv(&self, location: GLint, count: GLsizei, value: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform2iv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform2iv", &self.glUniform2iv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform2iv");
            }
            out
        }

        pub unsafe fn Uniform2iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2iv\0", &self.glUniform2iv_p)
        }
        #[inline]

        pub fn Uniform2iv_is_loaded(&self) -> bool {
            !self.glUniform2iv_p.load(RELAX).is_null()
        }
        /// [glUniform2ui](http://docs.gl/gl4/glUniform)(location, v0, v1)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform2ui(&self, location: GLint, v0: GLuint, v1: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.Uniform2ui({:?}, {:?}, {:?});", location, v0, v1);
            }
            let out = call_atomic_ptr_3arg("glUniform2ui", &self.glUniform2ui_p, location, v0, v1);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform2ui");
            }
            out
        }

        pub unsafe fn Uniform2ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2ui\0", &self.glUniform2ui_p)
        }
        #[inline]

        pub fn Uniform2ui_is_loaded(&self) -> bool {
            !self.glUniform2ui_p.load(RELAX).is_null()
        }
        /// [glUniform2uiv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform2uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform2uiv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_3arg(
                "glUniform2uiv",
                &self.glUniform2uiv_p,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform2uiv");
            }
            out
        }

        pub unsafe fn Uniform2uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2uiv\0", &self.glUniform2uiv_p)
        }
        #[inline]

        pub fn Uniform2uiv_is_loaded(&self) -> bool {
            !self.glUniform2uiv_p.load(RELAX).is_null()
        }
        /// [glUniform3d](http://docs.gl/gl4/glUniform3d)(location, x, y, z)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform3d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform3d({:?}, {:?}, {:?}, {:?});",
                    location,
                    x,
                    y,
                    z
                );
            }
            let out = call_atomic_ptr_4arg("glUniform3d", &self.glUniform3d_p, location, x, y, z);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform3d");
            }
            out
        }

        pub unsafe fn Uniform3d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3d\0", &self.glUniform3d_p)
        }
        #[inline]

        pub fn Uniform3d_is_loaded(&self) -> bool {
            !self.glUniform3d_p.load(RELAX).is_null()
        }
        /// [glUniform3dv](http://docs.gl/gl4/glUniform3dv)(location, count, value)
        /// * `value` len: count*3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform3dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform3dv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform3dv", &self.glUniform3dv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform3dv");
            }
            out
        }

        pub unsafe fn Uniform3dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3dv\0", &self.glUniform3dv_p)
        }
        #[inline]

        pub fn Uniform3dv_is_loaded(&self) -> bool {
            !self.glUniform3dv_p.load(RELAX).is_null()
        }
        /// [glUniform3f](http://docs.gl/gl4/glUniform)(location, v0, v1, v2)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform3f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform3f({:?}, {:?}, {:?}, {:?});",
                    location,
                    v0,
                    v1,
                    v2
                );
            }
            let out =
                call_atomic_ptr_4arg("glUniform3f", &self.glUniform3f_p, location, v0, v1, v2);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform3f");
            }
            out
        }

        pub unsafe fn Uniform3f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3f\0", &self.glUniform3f_p)
        }
        #[inline]

        pub fn Uniform3f_is_loaded(&self) -> bool {
            !self.glUniform3f_p.load(RELAX).is_null()
        }
        /// [glUniform3fv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform3fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform3fv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform3fv", &self.glUniform3fv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform3fv");
            }
            out
        }

        pub unsafe fn Uniform3fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3fv\0", &self.glUniform3fv_p)
        }
        #[inline]

        pub fn Uniform3fv_is_loaded(&self) -> bool {
            !self.glUniform3fv_p.load(RELAX).is_null()
        }
        /// [glUniform3i](http://docs.gl/gl4/glUniform)(location, v0, v1, v2)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform3i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform3i({:?}, {:?}, {:?}, {:?});",
                    location,
                    v0,
                    v1,
                    v2
                );
            }
            let out =
                call_atomic_ptr_4arg("glUniform3i", &self.glUniform3i_p, location, v0, v1, v2);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform3i");
            }
            out
        }

        pub unsafe fn Uniform3i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3i\0", &self.glUniform3i_p)
        }
        #[inline]

        pub fn Uniform3i_is_loaded(&self) -> bool {
            !self.glUniform3i_p.load(RELAX).is_null()
        }
        /// [glUniform3iv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform3iv(&self, location: GLint, count: GLsizei, value: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform3iv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform3iv", &self.glUniform3iv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform3iv");
            }
            out
        }

        pub unsafe fn Uniform3iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3iv\0", &self.glUniform3iv_p)
        }
        #[inline]

        pub fn Uniform3iv_is_loaded(&self) -> bool {
            !self.glUniform3iv_p.load(RELAX).is_null()
        }
        /// [glUniform3ui](http://docs.gl/gl4/glUniform)(location, v0, v1, v2)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform3ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform3ui({:?}, {:?}, {:?}, {:?});",
                    location,
                    v0,
                    v1,
                    v2
                );
            }
            let out =
                call_atomic_ptr_4arg("glUniform3ui", &self.glUniform3ui_p, location, v0, v1, v2);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform3ui");
            }
            out
        }

        pub unsafe fn Uniform3ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3ui\0", &self.glUniform3ui_p)
        }
        #[inline]

        pub fn Uniform3ui_is_loaded(&self) -> bool {
            !self.glUniform3ui_p.load(RELAX).is_null()
        }
        /// [glUniform3uiv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform3uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform3uiv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_3arg(
                "glUniform3uiv",
                &self.glUniform3uiv_p,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform3uiv");
            }
            out
        }

        pub unsafe fn Uniform3uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3uiv\0", &self.glUniform3uiv_p)
        }
        #[inline]

        pub fn Uniform3uiv_is_loaded(&self) -> bool {
            !self.glUniform3uiv_p.load(RELAX).is_null()
        }
        /// [glUniform4d](http://docs.gl/gl4/glUniform4d)(location, x, y, z, w)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform4d(
            &self,
            location: GLint,
            x: GLdouble,
            y: GLdouble,
            z: GLdouble,
            w: GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform4d({:?}, {:?}, {:?}, {:?}, {:?});",
                    location,
                    x,
                    y,
                    z,
                    w
                );
            }
            let out =
                call_atomic_ptr_5arg("glUniform4d", &self.glUniform4d_p, location, x, y, z, w);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform4d");
            }
            out
        }

        pub unsafe fn Uniform4d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4d\0", &self.glUniform4d_p)
        }
        #[inline]

        pub fn Uniform4d_is_loaded(&self) -> bool {
            !self.glUniform4d_p.load(RELAX).is_null()
        }
        /// [glUniform4dv](http://docs.gl/gl4/glUniform4dv)(location, count, value)
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform4dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform4dv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform4dv", &self.glUniform4dv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform4dv");
            }
            out
        }

        pub unsafe fn Uniform4dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4dv\0", &self.glUniform4dv_p)
        }
        #[inline]

        pub fn Uniform4dv_is_loaded(&self) -> bool {
            !self.glUniform4dv_p.load(RELAX).is_null()
        }
        /// [glUniform4f](http://docs.gl/gl4/glUniform)(location, v0, v1, v2, v3)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform4f(
            &self,
            location: GLint,
            v0: GLfloat,
            v1: GLfloat,
            v2: GLfloat,
            v3: GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform4f({:?}, {:?}, {:?}, {:?}, {:?});",
                    location,
                    v0,
                    v1,
                    v2,
                    v3
                );
            }
            let out =
                call_atomic_ptr_5arg("glUniform4f", &self.glUniform4f_p, location, v0, v1, v2, v3);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform4f");
            }
            out
        }

        pub unsafe fn Uniform4f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4f\0", &self.glUniform4f_p)
        }
        #[inline]

        pub fn Uniform4f_is_loaded(&self) -> bool {
            !self.glUniform4f_p.load(RELAX).is_null()
        }
        /// [glUniform4fv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform4fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform4fv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform4fv", &self.glUniform4fv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform4fv");
            }
            out
        }

        pub unsafe fn Uniform4fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4fv\0", &self.glUniform4fv_p)
        }
        #[inline]

        pub fn Uniform4fv_is_loaded(&self) -> bool {
            !self.glUniform4fv_p.load(RELAX).is_null()
        }
        /// [glUniform4i](http://docs.gl/gl4/glUniform)(location, v0, v1, v2, v3)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform4i(
            &self,
            location: GLint,
            v0: GLint,
            v1: GLint,
            v2: GLint,
            v3: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform4i({:?}, {:?}, {:?}, {:?}, {:?});",
                    location,
                    v0,
                    v1,
                    v2,
                    v3
                );
            }
            let out =
                call_atomic_ptr_5arg("glUniform4i", &self.glUniform4i_p, location, v0, v1, v2, v3);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform4i");
            }
            out
        }

        pub unsafe fn Uniform4i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4i\0", &self.glUniform4i_p)
        }
        #[inline]

        pub fn Uniform4i_is_loaded(&self) -> bool {
            !self.glUniform4i_p.load(RELAX).is_null()
        }
        /// [glUniform4iv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform4iv(&self, location: GLint, count: GLsizei, value: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform4iv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out =
                call_atomic_ptr_3arg("glUniform4iv", &self.glUniform4iv_p, location, count, value);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform4iv");
            }
            out
        }

        pub unsafe fn Uniform4iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4iv\0", &self.glUniform4iv_p)
        }
        #[inline]

        pub fn Uniform4iv_is_loaded(&self) -> bool {
            !self.glUniform4iv_p.load(RELAX).is_null()
        }
        /// [glUniform4ui](http://docs.gl/gl4/glUniform)(location, v0, v1, v2, v3)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform4ui(
            &self,
            location: GLint,
            v0: GLuint,
            v1: GLuint,
            v2: GLuint,
            v3: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform4ui({:?}, {:?}, {:?}, {:?}, {:?});",
                    location,
                    v0,
                    v1,
                    v2,
                    v3
                );
            }
            let out = call_atomic_ptr_5arg(
                "glUniform4ui",
                &self.glUniform4ui_p,
                location,
                v0,
                v1,
                v2,
                v3,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform4ui");
            }
            out
        }

        pub unsafe fn Uniform4ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4ui\0", &self.glUniform4ui_p)
        }
        #[inline]

        pub fn Uniform4ui_is_loaded(&self) -> bool {
            !self.glUniform4ui_p.load(RELAX).is_null()
        }
        /// [glUniform4uiv](http://docs.gl/gl4/glUniform)(location, count, value)
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Uniform4uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Uniform4uiv({:?}, {:?}, {:p});",
                    location,
                    count,
                    value
                );
            }
            let out = call_atomic_ptr_3arg(
                "glUniform4uiv",
                &self.glUniform4uiv_p,
                location,
                count,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniform4uiv");
            }
            out
        }

        pub unsafe fn Uniform4uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4uiv\0", &self.glUniform4uiv_p)
        }
        #[inline]

        pub fn Uniform4uiv_is_loaded(&self) -> bool {
            !self.glUniform4uiv_p.load(RELAX).is_null()
        }
        /// [glUniformBlockBinding](http://docs.gl/gl4/glUniformBlockBinding)(program, uniformBlockIndex, uniformBlockBinding)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformBlockBinding(
            &self,
            program: GLuint,
            uniformBlockIndex: GLuint,
            uniformBlockBinding: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformBlockBinding({:?}, {:?}, {:?});",
                    program,
                    uniformBlockIndex,
                    uniformBlockBinding
                );
            }
            let out = call_atomic_ptr_3arg(
                "glUniformBlockBinding",
                &self.glUniformBlockBinding_p,
                program,
                uniformBlockIndex,
                uniformBlockBinding,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformBlockBinding");
            }
            out
        }

        pub unsafe fn UniformBlockBinding_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformBlockBinding\0",
                &self.glUniformBlockBinding_p,
            )
        }
        #[inline]

        pub fn UniformBlockBinding_is_loaded(&self) -> bool {
            !self.glUniformBlockBinding_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix2dv](http://docs.gl/gl4/glUniformMatrix2dv)(location, count, transpose, value)
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix2dv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix2dv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix2dv",
                &self.glUniformMatrix2dv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix2dv");
            }
            out
        }

        pub unsafe fn UniformMatrix2dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix2dv\0",
                &self.glUniformMatrix2dv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix2dv_is_loaded(&self) -> bool {
            !self.glUniformMatrix2dv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix2fv](http://docs.gl/gl4/glUniform)(location, count, transpose, value)
        /// * `value` len: count*4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix2fv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix2fv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix2fv",
                &self.glUniformMatrix2fv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix2fv");
            }
            out
        }

        pub unsafe fn UniformMatrix2fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix2fv\0",
                &self.glUniformMatrix2fv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix2fv_is_loaded(&self) -> bool {
            !self.glUniformMatrix2fv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix2x3dv](http://docs.gl/gl4/glUniformMatrix2x3dv)(location, count, transpose, value)
        /// * `value` len: count*6
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix2x3dv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix2x3dv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix2x3dv",
                &self.glUniformMatrix2x3dv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix2x3dv");
            }
            out
        }

        pub unsafe fn UniformMatrix2x3dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix2x3dv\0",
                &self.glUniformMatrix2x3dv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix2x3dv_is_loaded(&self) -> bool {
            !self.glUniformMatrix2x3dv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix2x3fv](http://docs.gl/gl4/glUniform)(location, count, transpose, value)
        /// * `value` len: count*6
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix2x3fv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix2x3fv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix2x3fv",
                &self.glUniformMatrix2x3fv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix2x3fv");
            }
            out
        }

        pub unsafe fn UniformMatrix2x3fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix2x3fv\0",
                &self.glUniformMatrix2x3fv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix2x3fv_is_loaded(&self) -> bool {
            !self.glUniformMatrix2x3fv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix2x4dv](http://docs.gl/gl4/glUniformMatrix2x4dv)(location, count, transpose, value)
        /// * `value` len: count*8
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix2x4dv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix2x4dv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix2x4dv",
                &self.glUniformMatrix2x4dv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix2x4dv");
            }
            out
        }

        pub unsafe fn UniformMatrix2x4dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix2x4dv\0",
                &self.glUniformMatrix2x4dv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix2x4dv_is_loaded(&self) -> bool {
            !self.glUniformMatrix2x4dv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix2x4fv](http://docs.gl/gl4/glUniform)(location, count, transpose, value)
        /// * `value` len: count*8
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix2x4fv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix2x4fv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix2x4fv",
                &self.glUniformMatrix2x4fv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix2x4fv");
            }
            out
        }

        pub unsafe fn UniformMatrix2x4fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix2x4fv\0",
                &self.glUniformMatrix2x4fv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix2x4fv_is_loaded(&self) -> bool {
            !self.glUniformMatrix2x4fv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix3dv](http://docs.gl/gl4/glUniformMatrix3dv)(location, count, transpose, value)
        /// * `value` len: count*9
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix3dv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix3dv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix3dv",
                &self.glUniformMatrix3dv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix3dv");
            }
            out
        }

        pub unsafe fn UniformMatrix3dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix3dv\0",
                &self.glUniformMatrix3dv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix3dv_is_loaded(&self) -> bool {
            !self.glUniformMatrix3dv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix3fv](http://docs.gl/gl4/glUniform)(location, count, transpose, value)
        /// * `value` len: count*9
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix3fv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix3fv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix3fv",
                &self.glUniformMatrix3fv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix3fv");
            }
            out
        }

        pub unsafe fn UniformMatrix3fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix3fv\0",
                &self.glUniformMatrix3fv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix3fv_is_loaded(&self) -> bool {
            !self.glUniformMatrix3fv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix3x2dv](http://docs.gl/gl4/glUniformMatrix3x2dv)(location, count, transpose, value)
        /// * `value` len: count*6
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix3x2dv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix3x2dv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix3x2dv",
                &self.glUniformMatrix3x2dv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix3x2dv");
            }
            out
        }

        pub unsafe fn UniformMatrix3x2dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix3x2dv\0",
                &self.glUniformMatrix3x2dv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix3x2dv_is_loaded(&self) -> bool {
            !self.glUniformMatrix3x2dv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix3x2fv](http://docs.gl/gl4/glUniform)(location, count, transpose, value)
        /// * `value` len: count*6
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix3x2fv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix3x2fv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix3x2fv",
                &self.glUniformMatrix3x2fv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix3x2fv");
            }
            out
        }

        pub unsafe fn UniformMatrix3x2fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix3x2fv\0",
                &self.glUniformMatrix3x2fv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix3x2fv_is_loaded(&self) -> bool {
            !self.glUniformMatrix3x2fv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix3x4dv](http://docs.gl/gl4/glUniformMatrix3x4dv)(location, count, transpose, value)
        /// * `value` len: count*12
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix3x4dv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix3x4dv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix3x4dv",
                &self.glUniformMatrix3x4dv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix3x4dv");
            }
            out
        }

        pub unsafe fn UniformMatrix3x4dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix3x4dv\0",
                &self.glUniformMatrix3x4dv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix3x4dv_is_loaded(&self) -> bool {
            !self.glUniformMatrix3x4dv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix3x4fv](http://docs.gl/gl4/glUniform)(location, count, transpose, value)
        /// * `value` len: count*12
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix3x4fv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix3x4fv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix3x4fv",
                &self.glUniformMatrix3x4fv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix3x4fv");
            }
            out
        }

        pub unsafe fn UniformMatrix3x4fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix3x4fv\0",
                &self.glUniformMatrix3x4fv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix3x4fv_is_loaded(&self) -> bool {
            !self.glUniformMatrix3x4fv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix4dv](http://docs.gl/gl4/glUniformMatrix4dv)(location, count, transpose, value)
        /// * `value` len: count*16
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix4dv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix4dv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix4dv",
                &self.glUniformMatrix4dv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix4dv");
            }
            out
        }

        pub unsafe fn UniformMatrix4dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix4dv\0",
                &self.glUniformMatrix4dv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix4dv_is_loaded(&self) -> bool {
            !self.glUniformMatrix4dv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix4fv](http://docs.gl/gl4/glUniform)(location, count, transpose, value)
        /// * `value` len: count*16
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix4fv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix4fv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix4fv",
                &self.glUniformMatrix4fv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix4fv");
            }
            out
        }

        pub unsafe fn UniformMatrix4fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix4fv\0",
                &self.glUniformMatrix4fv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix4fv_is_loaded(&self) -> bool {
            !self.glUniformMatrix4fv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix4x2dv](http://docs.gl/gl4/glUniformMatrix4x2dv)(location, count, transpose, value)
        /// * `value` len: count*8
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix4x2dv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix4x2dv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix4x2dv",
                &self.glUniformMatrix4x2dv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix4x2dv");
            }
            out
        }

        pub unsafe fn UniformMatrix4x2dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix4x2dv\0",
                &self.glUniformMatrix4x2dv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix4x2dv_is_loaded(&self) -> bool {
            !self.glUniformMatrix4x2dv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix4x2fv](http://docs.gl/gl4/glUniform)(location, count, transpose, value)
        /// * `value` len: count*8
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix4x2fv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix4x2fv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix4x2fv",
                &self.glUniformMatrix4x2fv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix4x2fv");
            }
            out
        }

        pub unsafe fn UniformMatrix4x2fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix4x2fv\0",
                &self.glUniformMatrix4x2fv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix4x2fv_is_loaded(&self) -> bool {
            !self.glUniformMatrix4x2fv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix4x3dv](http://docs.gl/gl4/glUniformMatrix4x3dv)(location, count, transpose, value)
        /// * `value` len: count*12
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix4x3dv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix4x3dv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix4x3dv",
                &self.glUniformMatrix4x3dv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix4x3dv");
            }
            out
        }

        pub unsafe fn UniformMatrix4x3dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix4x3dv\0",
                &self.glUniformMatrix4x3dv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix4x3dv_is_loaded(&self) -> bool {
            !self.glUniformMatrix4x3dv_p.load(RELAX).is_null()
        }
        /// [glUniformMatrix4x3fv](http://docs.gl/gl4/glUniform)(location, count, transpose, value)
        /// * `value` len: count*12
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformMatrix4x3fv(
            &self,
            location: GLint,
            count: GLsizei,
            transpose: GLboolean,
            value: *const GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformMatrix4x3fv({:?}, {:?}, {:?}, {:p});",
                    location,
                    count,
                    transpose,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glUniformMatrix4x3fv",
                &self.glUniformMatrix4x3fv_p,
                location,
                count,
                transpose,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformMatrix4x3fv");
            }
            out
        }

        pub unsafe fn UniformMatrix4x3fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformMatrix4x3fv\0",
                &self.glUniformMatrix4x3fv_p,
            )
        }
        #[inline]

        pub fn UniformMatrix4x3fv_is_loaded(&self) -> bool {
            !self.glUniformMatrix4x3fv_p.load(RELAX).is_null()
        }
        /// [glUniformSubroutinesuiv](http://docs.gl/gl4/glUniformSubroutines)(shadertype, count, indices)
        /// * `shadertype` group: ShaderType
        /// * `indices` len: count
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UniformSubroutinesuiv(
            &self,
            shadertype: GLenum,
            count: GLsizei,
            indices: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UniformSubroutinesuiv({:#X}, {:?}, {:p});",
                    shadertype,
                    count,
                    indices
                );
            }
            let out = call_atomic_ptr_3arg(
                "glUniformSubroutinesuiv",
                &self.glUniformSubroutinesuiv_p,
                shadertype,
                count,
                indices,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUniformSubroutinesuiv");
            }
            out
        }

        pub unsafe fn UniformSubroutinesuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUniformSubroutinesuiv\0",
                &self.glUniformSubroutinesuiv_p,
            )
        }
        #[inline]

        pub fn UniformSubroutinesuiv_is_loaded(&self) -> bool {
            !self.glUniformSubroutinesuiv_p.load(RELAX).is_null()
        }
        /// [glUnmapBuffer](http://docs.gl/gl4/glUnmapBuffer)(target)
        /// * `target` group: BufferTargetARB
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UnmapBuffer(&self, target: GLenum) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.UnmapBuffer({:#X});", target);
            }
            let out = call_atomic_ptr_1arg("glUnmapBuffer", &self.glUnmapBuffer_p, target);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUnmapBuffer");
            }
            out
        }

        pub unsafe fn UnmapBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUnmapBuffer\0", &self.glUnmapBuffer_p)
        }
        #[inline]

        pub fn UnmapBuffer_is_loaded(&self) -> bool {
            !self.glUnmapBuffer_p.load(RELAX).is_null()
        }
        /// [glUnmapNamedBuffer](http://docs.gl/gl4/glUnmapNamedBuffer)(buffer)
        /// * `buffer` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UnmapNamedBuffer(&self, buffer: GLuint) -> GLboolean {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.UnmapNamedBuffer({:?});", buffer);
            }
            let out =
                call_atomic_ptr_1arg("glUnmapNamedBuffer", &self.glUnmapNamedBuffer_p, buffer);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUnmapNamedBuffer");
            }
            out
        }

        pub unsafe fn UnmapNamedBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUnmapNamedBuffer\0",
                &self.glUnmapNamedBuffer_p,
            )
        }
        #[inline]

        pub fn UnmapNamedBuffer_is_loaded(&self) -> bool {
            !self.glUnmapNamedBuffer_p.load(RELAX).is_null()
        }
        /// [glUseProgram](http://docs.gl/gl4/glUseProgram)(program)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UseProgram(&self, program: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.UseProgram({:?});", program);
            }
            let out = call_atomic_ptr_1arg("glUseProgram", &self.glUseProgram_p, program);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUseProgram");
            }
            out
        }

        pub unsafe fn UseProgram_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glUseProgram\0", &self.glUseProgram_p)
        }
        #[inline]

        pub fn UseProgram_is_loaded(&self) -> bool {
            !self.glUseProgram_p.load(RELAX).is_null()
        }
        /// [glUseProgramStages](http://docs.gl/gl4/glUseProgramStages)(pipeline, stages, program)
        /// * `pipeline` class: program pipeline
        /// * `stages` group: UseProgramStageMask
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn UseProgramStages(
            &self,
            pipeline: GLuint,
            stages: GLbitfield,
            program: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.UseProgramStages({:?}, {:?}, {:?});",
                    pipeline,
                    stages,
                    program
                );
            }
            let out = call_atomic_ptr_3arg(
                "glUseProgramStages",
                &self.glUseProgramStages_p,
                pipeline,
                stages,
                program,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glUseProgramStages");
            }
            out
        }

        pub unsafe fn UseProgramStages_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glUseProgramStages\0",
                &self.glUseProgramStages_p,
            )
        }
        #[inline]

        pub fn UseProgramStages_is_loaded(&self) -> bool {
            !self.glUseProgramStages_p.load(RELAX).is_null()
        }
        /// [glValidateProgram](http://docs.gl/gl4/glValidateProgram)(program)
        /// * `program` class: program
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ValidateProgram(&self, program: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ValidateProgram({:?});", program);
            }
            let out = call_atomic_ptr_1arg("glValidateProgram", &self.glValidateProgram_p, program);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glValidateProgram");
            }
            out
        }

        pub unsafe fn ValidateProgram_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glValidateProgram\0",
                &self.glValidateProgram_p,
            )
        }
        #[inline]

        pub fn ValidateProgram_is_loaded(&self) -> bool {
            !self.glValidateProgram_p.load(RELAX).is_null()
        }
        /// [glValidateProgramPipeline](http://docs.gl/gl4/glValidateProgramPipeline)(pipeline)
        /// * `pipeline` class: program pipeline
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ValidateProgramPipeline(&self, pipeline: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ValidateProgramPipeline({:?});", pipeline);
            }
            let out = call_atomic_ptr_1arg(
                "glValidateProgramPipeline",
                &self.glValidateProgramPipeline_p,
                pipeline,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glValidateProgramPipeline");
            }
            out
        }

        pub unsafe fn ValidateProgramPipeline_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glValidateProgramPipeline\0",
                &self.glValidateProgramPipeline_p,
            )
        }
        #[inline]

        pub fn ValidateProgramPipeline_is_loaded(&self) -> bool {
            !self.glValidateProgramPipeline_p.load(RELAX).is_null()
        }
        /// [glVertexArrayAttribBinding](http://docs.gl/gl4/glVertexArrayAttribBinding)(vaobj, attribindex, bindingindex)
        /// * `vaobj` class: vertex array
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexArrayAttribBinding(
            &self,
            vaobj: GLuint,
            attribindex: GLuint,
            bindingindex: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexArrayAttribBinding({:?}, {:?}, {:?});",
                    vaobj,
                    attribindex,
                    bindingindex
                );
            }
            let out = call_atomic_ptr_3arg(
                "glVertexArrayAttribBinding",
                &self.glVertexArrayAttribBinding_p,
                vaobj,
                attribindex,
                bindingindex,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexArrayAttribBinding");
            }
            out
        }

        pub unsafe fn VertexArrayAttribBinding_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexArrayAttribBinding\0",
                &self.glVertexArrayAttribBinding_p,
            )
        }
        #[inline]

        pub fn VertexArrayAttribBinding_is_loaded(&self) -> bool {
            !self.glVertexArrayAttribBinding_p.load(RELAX).is_null()
        }
        /// [glVertexArrayAttribFormat](http://docs.gl/gl4/glVertexArrayAttribFormat)(vaobj, attribindex, size, type_, normalized, relativeoffset)
        /// * `vaobj` class: vertex array
        /// * `type_` group: VertexAttribType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexArrayAttribFormat(
            &self,
            vaobj: GLuint,
            attribindex: GLuint,
            size: GLint,
            type_: GLenum,
            normalized: GLboolean,
            relativeoffset: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexArrayAttribFormat({:?}, {:?}, {:?}, {:#X}, {:?}, {:?});",
                    vaobj,
                    attribindex,
                    size,
                    type_,
                    normalized,
                    relativeoffset
                );
            }
            let out = call_atomic_ptr_6arg(
                "glVertexArrayAttribFormat",
                &self.glVertexArrayAttribFormat_p,
                vaobj,
                attribindex,
                size,
                type_,
                normalized,
                relativeoffset,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexArrayAttribFormat");
            }
            out
        }

        pub unsafe fn VertexArrayAttribFormat_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexArrayAttribFormat\0",
                &self.glVertexArrayAttribFormat_p,
            )
        }
        #[inline]

        pub fn VertexArrayAttribFormat_is_loaded(&self) -> bool {
            !self.glVertexArrayAttribFormat_p.load(RELAX).is_null()
        }
        /// [glVertexArrayAttribIFormat](http://docs.gl/gl4/glVertexArrayAttribIFormat)(vaobj, attribindex, size, type_, relativeoffset)
        /// * `vaobj` class: vertex array
        /// * `type_` group: VertexAttribIType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexArrayAttribIFormat(
            &self,
            vaobj: GLuint,
            attribindex: GLuint,
            size: GLint,
            type_: GLenum,
            relativeoffset: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexArrayAttribIFormat({:?}, {:?}, {:?}, {:#X}, {:?});",
                    vaobj,
                    attribindex,
                    size,
                    type_,
                    relativeoffset
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexArrayAttribIFormat",
                &self.glVertexArrayAttribIFormat_p,
                vaobj,
                attribindex,
                size,
                type_,
                relativeoffset,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexArrayAttribIFormat");
            }
            out
        }

        pub unsafe fn VertexArrayAttribIFormat_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexArrayAttribIFormat\0",
                &self.glVertexArrayAttribIFormat_p,
            )
        }
        #[inline]

        pub fn VertexArrayAttribIFormat_is_loaded(&self) -> bool {
            !self.glVertexArrayAttribIFormat_p.load(RELAX).is_null()
        }
        /// [glVertexArrayAttribLFormat](http://docs.gl/gl4/glVertexArrayAttribLFormat)(vaobj, attribindex, size, type_, relativeoffset)
        /// * `vaobj` class: vertex array
        /// * `type_` group: VertexAttribLType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexArrayAttribLFormat(
            &self,
            vaobj: GLuint,
            attribindex: GLuint,
            size: GLint,
            type_: GLenum,
            relativeoffset: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexArrayAttribLFormat({:?}, {:?}, {:?}, {:#X}, {:?});",
                    vaobj,
                    attribindex,
                    size,
                    type_,
                    relativeoffset
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexArrayAttribLFormat",
                &self.glVertexArrayAttribLFormat_p,
                vaobj,
                attribindex,
                size,
                type_,
                relativeoffset,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexArrayAttribLFormat");
            }
            out
        }

        pub unsafe fn VertexArrayAttribLFormat_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexArrayAttribLFormat\0",
                &self.glVertexArrayAttribLFormat_p,
            )
        }
        #[inline]

        pub fn VertexArrayAttribLFormat_is_loaded(&self) -> bool {
            !self.glVertexArrayAttribLFormat_p.load(RELAX).is_null()
        }
        /// [glVertexArrayBindingDivisor](http://docs.gl/gl4/glVertexArrayBindingDivisor)(vaobj, bindingindex, divisor)
        /// * `vaobj` class: vertex array
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexArrayBindingDivisor(
            &self,
            vaobj: GLuint,
            bindingindex: GLuint,
            divisor: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexArrayBindingDivisor({:?}, {:?}, {:?});",
                    vaobj,
                    bindingindex,
                    divisor
                );
            }
            let out = call_atomic_ptr_3arg(
                "glVertexArrayBindingDivisor",
                &self.glVertexArrayBindingDivisor_p,
                vaobj,
                bindingindex,
                divisor,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexArrayBindingDivisor");
            }
            out
        }

        pub unsafe fn VertexArrayBindingDivisor_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexArrayBindingDivisor\0",
                &self.glVertexArrayBindingDivisor_p,
            )
        }
        #[inline]

        pub fn VertexArrayBindingDivisor_is_loaded(&self) -> bool {
            !self.glVertexArrayBindingDivisor_p.load(RELAX).is_null()
        }
        /// [glVertexArrayElementBuffer](http://docs.gl/gl4/glVertexArrayElementBuffer)(vaobj, buffer)
        /// * `vaobj` class: vertex array
        /// * `buffer` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexArrayElementBuffer(&self, vaobj: GLuint, buffer: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexArrayElementBuffer({:?}, {:?});",
                    vaobj,
                    buffer
                );
            }
            let out = call_atomic_ptr_2arg(
                "glVertexArrayElementBuffer",
                &self.glVertexArrayElementBuffer_p,
                vaobj,
                buffer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexArrayElementBuffer");
            }
            out
        }

        pub unsafe fn VertexArrayElementBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexArrayElementBuffer\0",
                &self.glVertexArrayElementBuffer_p,
            )
        }
        #[inline]

        pub fn VertexArrayElementBuffer_is_loaded(&self) -> bool {
            !self.glVertexArrayElementBuffer_p.load(RELAX).is_null()
        }
        /// [glVertexArrayVertexBuffer](http://docs.gl/gl4/glVertexArrayVertexBuffer)(vaobj, bindingindex, buffer, offset, stride)
        /// * `vaobj` class: vertex array
        /// * `buffer` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexArrayVertexBuffer(
            &self,
            vaobj: GLuint,
            bindingindex: GLuint,
            buffer: GLuint,
            offset: GLintptr,
            stride: GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexArrayVertexBuffer({:?}, {:?}, {:?}, {:?}, {:?});",
                    vaobj,
                    bindingindex,
                    buffer,
                    offset,
                    stride
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexArrayVertexBuffer",
                &self.glVertexArrayVertexBuffer_p,
                vaobj,
                bindingindex,
                buffer,
                offset,
                stride,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexArrayVertexBuffer");
            }
            out
        }

        pub unsafe fn VertexArrayVertexBuffer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexArrayVertexBuffer\0",
                &self.glVertexArrayVertexBuffer_p,
            )
        }
        #[inline]

        pub fn VertexArrayVertexBuffer_is_loaded(&self) -> bool {
            !self.glVertexArrayVertexBuffer_p.load(RELAX).is_null()
        }
        /// [glVertexArrayVertexBuffers](http://docs.gl/gl4/glVertexArrayVertexBuffers)(vaobj, first, count, buffers, offsets, strides)
        /// * `vaobj` class: vertex array
        /// * `buffers` class: buffer
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexArrayVertexBuffers(
            &self,
            vaobj: GLuint,
            first: GLuint,
            count: GLsizei,
            buffers: *const GLuint,
            offsets: *const GLintptr,
            strides: *const GLsizei,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexArrayVertexBuffers({:?}, {:?}, {:?}, {:p}, {:p}, {:p});",
                    vaobj,
                    first,
                    count,
                    buffers,
                    offsets,
                    strides
                );
            }
            let out = call_atomic_ptr_6arg(
                "glVertexArrayVertexBuffers",
                &self.glVertexArrayVertexBuffers_p,
                vaobj,
                first,
                count,
                buffers,
                offsets,
                strides,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexArrayVertexBuffers");
            }
            out
        }

        pub unsafe fn VertexArrayVertexBuffers_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexArrayVertexBuffers\0",
                &self.glVertexArrayVertexBuffers_p,
            )
        }
        #[inline]

        pub fn VertexArrayVertexBuffers_is_loaded(&self) -> bool {
            !self.glVertexArrayVertexBuffers_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib1d](http://docs.gl/gl4/glVertexAttrib1d)(index, x)
        /// * vector equivalent: [`glVertexAttrib1dv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib1d(&self, index: GLuint, x: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib1d({:?}, {:?});", index, x);
            }
            let out = call_atomic_ptr_2arg("glVertexAttrib1d", &self.glVertexAttrib1d_p, index, x);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib1d");
            }
            out
        }

        pub unsafe fn VertexAttrib1d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib1d\0",
                &self.glVertexAttrib1d_p,
            )
        }
        #[inline]

        pub fn VertexAttrib1d_is_loaded(&self) -> bool {
            !self.glVertexAttrib1d_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib1dv](http://docs.gl/gl4/glVertexAttrib1dv)(index, v)
        /// * `v` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib1dv(&self, index: GLuint, v: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib1dv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib1dv", &self.glVertexAttrib1dv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib1dv");
            }
            out
        }

        pub unsafe fn VertexAttrib1dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib1dv\0",
                &self.glVertexAttrib1dv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib1dv_is_loaded(&self) -> bool {
            !self.glVertexAttrib1dv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib1f](http://docs.gl/gl4/glVertexAttrib)(index, x)
        /// * vector equivalent: [`glVertexAttrib1fv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib1f(&self, index: GLuint, x: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib1f({:?}, {:?});", index, x);
            }
            let out = call_atomic_ptr_2arg("glVertexAttrib1f", &self.glVertexAttrib1f_p, index, x);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib1f");
            }
            out
        }

        pub unsafe fn VertexAttrib1f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib1f\0",
                &self.glVertexAttrib1f_p,
            )
        }
        #[inline]

        pub fn VertexAttrib1f_is_loaded(&self) -> bool {
            !self.glVertexAttrib1f_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib1fv](http://docs.gl/gl4/glVertexAttrib)(index, v)
        /// * `v` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib1fv(&self, index: GLuint, v: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib1fv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib1fv", &self.glVertexAttrib1fv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib1fv");
            }
            out
        }

        pub unsafe fn VertexAttrib1fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib1fv\0",
                &self.glVertexAttrib1fv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib1fv_is_loaded(&self) -> bool {
            !self.glVertexAttrib1fv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib1s](http://docs.gl/gl4/glVertexAttrib1s)(index, x)
        /// * vector equivalent: [`glVertexAttrib1sv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib1s(&self, index: GLuint, x: GLshort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib1s({:?}, {:?});", index, x);
            }
            let out = call_atomic_ptr_2arg("glVertexAttrib1s", &self.glVertexAttrib1s_p, index, x);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib1s");
            }
            out
        }

        pub unsafe fn VertexAttrib1s_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib1s\0",
                &self.glVertexAttrib1s_p,
            )
        }
        #[inline]

        pub fn VertexAttrib1s_is_loaded(&self) -> bool {
            !self.glVertexAttrib1s_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib1sv](http://docs.gl/gl4/glVertexAttrib1sv)(index, v)
        /// * `v` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib1sv(&self, index: GLuint, v: *const GLshort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib1sv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib1sv", &self.glVertexAttrib1sv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib1sv");
            }
            out
        }

        pub unsafe fn VertexAttrib1sv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib1sv\0",
                &self.glVertexAttrib1sv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib1sv_is_loaded(&self) -> bool {
            !self.glVertexAttrib1sv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib2d](http://docs.gl/gl4/glVertexAttrib2d)(index, x, y)
        /// * vector equivalent: [`glVertexAttrib2dv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib2d(&self, index: GLuint, x: GLdouble, y: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib2d({:?}, {:?}, {:?});", index, x, y);
            }
            let out =
                call_atomic_ptr_3arg("glVertexAttrib2d", &self.glVertexAttrib2d_p, index, x, y);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib2d");
            }
            out
        }

        pub unsafe fn VertexAttrib2d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib2d\0",
                &self.glVertexAttrib2d_p,
            )
        }
        #[inline]

        pub fn VertexAttrib2d_is_loaded(&self) -> bool {
            !self.glVertexAttrib2d_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib2dv](http://docs.gl/gl4/glVertexAttrib2dv)(index, v)
        /// * `v` len: 2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib2dv(&self, index: GLuint, v: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib2dv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib2dv", &self.glVertexAttrib2dv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib2dv");
            }
            out
        }

        pub unsafe fn VertexAttrib2dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib2dv\0",
                &self.glVertexAttrib2dv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib2dv_is_loaded(&self) -> bool {
            !self.glVertexAttrib2dv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib2f](http://docs.gl/gl4/glVertexAttrib)(index, x, y)
        /// * vector equivalent: [`glVertexAttrib2fv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib2f(&self, index: GLuint, x: GLfloat, y: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib2f({:?}, {:?}, {:?});", index, x, y);
            }
            let out =
                call_atomic_ptr_3arg("glVertexAttrib2f", &self.glVertexAttrib2f_p, index, x, y);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib2f");
            }
            out
        }

        pub unsafe fn VertexAttrib2f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib2f\0",
                &self.glVertexAttrib2f_p,
            )
        }
        #[inline]

        pub fn VertexAttrib2f_is_loaded(&self) -> bool {
            !self.glVertexAttrib2f_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib2fv](http://docs.gl/gl4/glVertexAttrib)(index, v)
        /// * `v` len: 2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib2fv(&self, index: GLuint, v: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib2fv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib2fv", &self.glVertexAttrib2fv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib2fv");
            }
            out
        }

        pub unsafe fn VertexAttrib2fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib2fv\0",
                &self.glVertexAttrib2fv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib2fv_is_loaded(&self) -> bool {
            !self.glVertexAttrib2fv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib2s](http://docs.gl/gl4/glVertexAttrib2s)(index, x, y)
        /// * vector equivalent: [`glVertexAttrib2sv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib2s(&self, index: GLuint, x: GLshort, y: GLshort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib2s({:?}, {:?}, {:?});", index, x, y);
            }
            let out =
                call_atomic_ptr_3arg("glVertexAttrib2s", &self.glVertexAttrib2s_p, index, x, y);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib2s");
            }
            out
        }

        pub unsafe fn VertexAttrib2s_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib2s\0",
                &self.glVertexAttrib2s_p,
            )
        }
        #[inline]

        pub fn VertexAttrib2s_is_loaded(&self) -> bool {
            !self.glVertexAttrib2s_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib2sv](http://docs.gl/gl4/glVertexAttrib2sv)(index, v)
        /// * `v` len: 2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib2sv(&self, index: GLuint, v: *const GLshort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib2sv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib2sv", &self.glVertexAttrib2sv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib2sv");
            }
            out
        }

        pub unsafe fn VertexAttrib2sv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib2sv\0",
                &self.glVertexAttrib2sv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib2sv_is_loaded(&self) -> bool {
            !self.glVertexAttrib2sv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib3d](http://docs.gl/gl4/glVertexAttrib3d)(index, x, y, z)
        /// * vector equivalent: [`glVertexAttrib3dv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttrib3d({:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z
                );
            }
            let out =
                call_atomic_ptr_4arg("glVertexAttrib3d", &self.glVertexAttrib3d_p, index, x, y, z);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib3d");
            }
            out
        }

        pub unsafe fn VertexAttrib3d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib3d\0",
                &self.glVertexAttrib3d_p,
            )
        }
        #[inline]

        pub fn VertexAttrib3d_is_loaded(&self) -> bool {
            !self.glVertexAttrib3d_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib3dv](http://docs.gl/gl4/glVertexAttrib3dv)(index, v)
        /// * `v` len: 3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib3dv(&self, index: GLuint, v: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib3dv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib3dv", &self.glVertexAttrib3dv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib3dv");
            }
            out
        }

        pub unsafe fn VertexAttrib3dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib3dv\0",
                &self.glVertexAttrib3dv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib3dv_is_loaded(&self) -> bool {
            !self.glVertexAttrib3dv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib3f](http://docs.gl/gl4/glVertexAttrib)(index, x, y, z)
        /// * vector equivalent: [`glVertexAttrib3fv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib3f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttrib3f({:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z
                );
            }
            let out =
                call_atomic_ptr_4arg("glVertexAttrib3f", &self.glVertexAttrib3f_p, index, x, y, z);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib3f");
            }
            out
        }

        pub unsafe fn VertexAttrib3f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib3f\0",
                &self.glVertexAttrib3f_p,
            )
        }
        #[inline]

        pub fn VertexAttrib3f_is_loaded(&self) -> bool {
            !self.glVertexAttrib3f_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib3fv](http://docs.gl/gl4/glVertexAttrib)(index, v)
        /// * `v` len: 3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib3fv(&self, index: GLuint, v: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib3fv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib3fv", &self.glVertexAttrib3fv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib3fv");
            }
            out
        }

        pub unsafe fn VertexAttrib3fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib3fv\0",
                &self.glVertexAttrib3fv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib3fv_is_loaded(&self) -> bool {
            !self.glVertexAttrib3fv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib3s](http://docs.gl/gl4/glVertexAttrib3s)(index, x, y, z)
        /// * vector equivalent: [`glVertexAttrib3sv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib3s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttrib3s({:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z
                );
            }
            let out =
                call_atomic_ptr_4arg("glVertexAttrib3s", &self.glVertexAttrib3s_p, index, x, y, z);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib3s");
            }
            out
        }

        pub unsafe fn VertexAttrib3s_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib3s\0",
                &self.glVertexAttrib3s_p,
            )
        }
        #[inline]

        pub fn VertexAttrib3s_is_loaded(&self) -> bool {
            !self.glVertexAttrib3s_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib3sv](http://docs.gl/gl4/glVertexAttrib3sv)(index, v)
        /// * `v` len: 3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib3sv(&self, index: GLuint, v: *const GLshort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib3sv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib3sv", &self.glVertexAttrib3sv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib3sv");
            }
            out
        }

        pub unsafe fn VertexAttrib3sv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib3sv\0",
                &self.glVertexAttrib3sv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib3sv_is_loaded(&self) -> bool {
            !self.glVertexAttrib3sv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4Nbv](http://docs.gl/gl4/glVertexAttrib4Nbv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4Nbv(&self, index: GLuint, v: *const GLbyte) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4Nbv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4Nbv", &self.glVertexAttrib4Nbv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4Nbv");
            }
            out
        }

        pub unsafe fn VertexAttrib4Nbv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4Nbv\0",
                &self.glVertexAttrib4Nbv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4Nbv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4Nbv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4Niv](http://docs.gl/gl4/glVertexAttrib4N)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4Niv(&self, index: GLuint, v: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4Niv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4Niv", &self.glVertexAttrib4Niv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4Niv");
            }
            out
        }

        pub unsafe fn VertexAttrib4Niv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4Niv\0",
                &self.glVertexAttrib4Niv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4Niv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4Niv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4Nsv](http://docs.gl/gl4/glVertexAttrib4Nsv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4Nsv(&self, index: GLuint, v: *const GLshort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4Nsv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4Nsv", &self.glVertexAttrib4Nsv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4Nsv");
            }
            out
        }

        pub unsafe fn VertexAttrib4Nsv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4Nsv\0",
                &self.glVertexAttrib4Nsv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4Nsv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4Nsv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4Nub](http://docs.gl/gl4/glVertexAttrib4Nub)(index, x, y, z, w)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4Nub(
            &self,
            index: GLuint,
            x: GLubyte,
            y: GLubyte,
            z: GLubyte,
            w: GLubyte,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttrib4Nub({:?}, {:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z,
                    w
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexAttrib4Nub",
                &self.glVertexAttrib4Nub_p,
                index,
                x,
                y,
                z,
                w,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4Nub");
            }
            out
        }

        pub unsafe fn VertexAttrib4Nub_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4Nub\0",
                &self.glVertexAttrib4Nub_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4Nub_is_loaded(&self) -> bool {
            !self.glVertexAttrib4Nub_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4Nubv](http://docs.gl/gl4/glVertexAttrib4Nubv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4Nubv(&self, index: GLuint, v: *const GLubyte) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4Nubv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4Nubv", &self.glVertexAttrib4Nubv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4Nubv");
            }
            out
        }

        pub unsafe fn VertexAttrib4Nubv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4Nubv\0",
                &self.glVertexAttrib4Nubv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4Nubv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4Nubv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4Nuiv](http://docs.gl/gl4/glVertexAttrib4N)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4Nuiv(&self, index: GLuint, v: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4Nuiv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4Nuiv", &self.glVertexAttrib4Nuiv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4Nuiv");
            }
            out
        }

        pub unsafe fn VertexAttrib4Nuiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4Nuiv\0",
                &self.glVertexAttrib4Nuiv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4Nuiv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4Nuiv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4Nusv](http://docs.gl/gl4/glVertexAttrib4Nusv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4Nusv(&self, index: GLuint, v: *const GLushort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4Nusv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4Nusv", &self.glVertexAttrib4Nusv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4Nusv");
            }
            out
        }

        pub unsafe fn VertexAttrib4Nusv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4Nusv\0",
                &self.glVertexAttrib4Nusv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4Nusv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4Nusv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4bv](http://docs.gl/gl4/glVertexAttrib4bv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4bv(&self, index: GLuint, v: *const GLbyte) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4bv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4bv", &self.glVertexAttrib4bv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4bv");
            }
            out
        }

        pub unsafe fn VertexAttrib4bv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4bv\0",
                &self.glVertexAttrib4bv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4bv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4bv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4d](http://docs.gl/gl4/glVertexAttrib4d)(index, x, y, z, w)
        /// * vector equivalent: [`glVertexAttrib4dv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4d(
            &self,
            index: GLuint,
            x: GLdouble,
            y: GLdouble,
            z: GLdouble,
            w: GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttrib4d({:?}, {:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z,
                    w
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexAttrib4d",
                &self.glVertexAttrib4d_p,
                index,
                x,
                y,
                z,
                w,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4d");
            }
            out
        }

        pub unsafe fn VertexAttrib4d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4d\0",
                &self.glVertexAttrib4d_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4d_is_loaded(&self) -> bool {
            !self.glVertexAttrib4d_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4dv](http://docs.gl/gl4/glVertexAttrib4dv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4dv(&self, index: GLuint, v: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4dv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4dv", &self.glVertexAttrib4dv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4dv");
            }
            out
        }

        pub unsafe fn VertexAttrib4dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4dv\0",
                &self.glVertexAttrib4dv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4dv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4dv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4f](http://docs.gl/gl4/glVertexAttrib)(index, x, y, z, w)
        /// * vector equivalent: [`glVertexAttrib4fv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4f(
            &self,
            index: GLuint,
            x: GLfloat,
            y: GLfloat,
            z: GLfloat,
            w: GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttrib4f({:?}, {:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z,
                    w
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexAttrib4f",
                &self.glVertexAttrib4f_p,
                index,
                x,
                y,
                z,
                w,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4f");
            }
            out
        }

        pub unsafe fn VertexAttrib4f_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4f\0",
                &self.glVertexAttrib4f_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4f_is_loaded(&self) -> bool {
            !self.glVertexAttrib4f_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4fv](http://docs.gl/gl4/glVertexAttrib)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4fv(&self, index: GLuint, v: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4fv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4fv", &self.glVertexAttrib4fv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4fv");
            }
            out
        }

        pub unsafe fn VertexAttrib4fv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4fv\0",
                &self.glVertexAttrib4fv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4fv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4fv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4iv](http://docs.gl/gl4/glVertexAttrib)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4iv(&self, index: GLuint, v: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4iv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4iv", &self.glVertexAttrib4iv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4iv");
            }
            out
        }

        pub unsafe fn VertexAttrib4iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4iv\0",
                &self.glVertexAttrib4iv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4iv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4iv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4s](http://docs.gl/gl4/glVertexAttrib4s)(index, x, y, z, w)
        /// * vector equivalent: [`glVertexAttrib4sv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4s(
            &self,
            index: GLuint,
            x: GLshort,
            y: GLshort,
            z: GLshort,
            w: GLshort,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttrib4s({:?}, {:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z,
                    w
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexAttrib4s",
                &self.glVertexAttrib4s_p,
                index,
                x,
                y,
                z,
                w,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4s");
            }
            out
        }

        pub unsafe fn VertexAttrib4s_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4s\0",
                &self.glVertexAttrib4s_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4s_is_loaded(&self) -> bool {
            !self.glVertexAttrib4s_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4sv](http://docs.gl/gl4/glVertexAttrib4sv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4sv(&self, index: GLuint, v: *const GLshort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4sv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4sv", &self.glVertexAttrib4sv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4sv");
            }
            out
        }

        pub unsafe fn VertexAttrib4sv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4sv\0",
                &self.glVertexAttrib4sv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4sv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4sv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4ubv](http://docs.gl/gl4/glVertexAttrib4ubv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4ubv(&self, index: GLuint, v: *const GLubyte) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4ubv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4ubv", &self.glVertexAttrib4ubv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4ubv");
            }
            out
        }

        pub unsafe fn VertexAttrib4ubv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4ubv\0",
                &self.glVertexAttrib4ubv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4ubv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4ubv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4uiv](http://docs.gl/gl4/glVertexAttrib)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4uiv(&self, index: GLuint, v: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4uiv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4uiv", &self.glVertexAttrib4uiv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4uiv");
            }
            out
        }

        pub unsafe fn VertexAttrib4uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4uiv\0",
                &self.glVertexAttrib4uiv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4uiv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4uiv_p.load(RELAX).is_null()
        }
        /// [glVertexAttrib4usv](http://docs.gl/gl4/glVertexAttrib4usv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttrib4usv(&self, index: GLuint, v: *const GLushort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttrib4usv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttrib4usv", &self.glVertexAttrib4usv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttrib4usv");
            }
            out
        }

        pub unsafe fn VertexAttrib4usv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttrib4usv\0",
                &self.glVertexAttrib4usv_p,
            )
        }
        #[inline]

        pub fn VertexAttrib4usv_is_loaded(&self) -> bool {
            !self.glVertexAttrib4usv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribBinding](http://docs.gl/gl4/glVertexAttribBinding)(attribindex, bindingindex)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribBinding(&self, attribindex: GLuint, bindingindex: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribBinding({:?}, {:?});",
                    attribindex,
                    bindingindex
                );
            }
            let out = call_atomic_ptr_2arg(
                "glVertexAttribBinding",
                &self.glVertexAttribBinding_p,
                attribindex,
                bindingindex,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribBinding");
            }
            out
        }

        pub unsafe fn VertexAttribBinding_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribBinding\0",
                &self.glVertexAttribBinding_p,
            )
        }
        #[inline]

        pub fn VertexAttribBinding_is_loaded(&self) -> bool {
            !self.glVertexAttribBinding_p.load(RELAX).is_null()
        }
        /// [glVertexAttribDivisor](http://docs.gl/gl4/glVertexAttribDivisor)(index, divisor)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribDivisor(&self, index: GLuint, divisor: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribDivisor({:?}, {:?});",
                    index,
                    divisor
                );
            }
            let out = call_atomic_ptr_2arg(
                "glVertexAttribDivisor",
                &self.glVertexAttribDivisor_p,
                index,
                divisor,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribDivisor");
            }
            out
        }

        pub unsafe fn VertexAttribDivisor_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribDivisor\0",
                &self.glVertexAttribDivisor_p,
            )
        }
        #[inline]

        pub fn VertexAttribDivisor_is_loaded(&self) -> bool {
            !self.glVertexAttribDivisor_p.load(RELAX).is_null()
        }
        /// [glVertexAttribFormat](http://docs.gl/gl4/glVertexAttribFormat)(attribindex, size, type_, normalized, relativeoffset)
        /// * `type_` group: VertexAttribType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribFormat(
            &self,
            attribindex: GLuint,
            size: GLint,
            type_: GLenum,
            normalized: GLboolean,
            relativeoffset: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribFormat({:?}, {:?}, {:#X}, {:?}, {:?});",
                    attribindex,
                    size,
                    type_,
                    normalized,
                    relativeoffset
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexAttribFormat",
                &self.glVertexAttribFormat_p,
                attribindex,
                size,
                type_,
                normalized,
                relativeoffset,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribFormat");
            }
            out
        }

        pub unsafe fn VertexAttribFormat_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribFormat\0",
                &self.glVertexAttribFormat_p,
            )
        }
        #[inline]

        pub fn VertexAttribFormat_is_loaded(&self) -> bool {
            !self.glVertexAttribFormat_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI1i](http://docs.gl/gl4/glVertexAttribI)(index, x)
        /// * vector equivalent: [`glVertexAttribI1iv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI1i(&self, index: GLuint, x: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI1i({:?}, {:?});", index, x);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI1i", &self.glVertexAttribI1i_p, index, x);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI1i");
            }
            out
        }

        pub unsafe fn VertexAttribI1i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI1i\0",
                &self.glVertexAttribI1i_p,
            )
        }
        #[inline]

        pub fn VertexAttribI1i_is_loaded(&self) -> bool {
            !self.glVertexAttribI1i_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI1iv](http://docs.gl/gl4/glVertexAttribI)(index, v)
        /// * `v` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI1iv(&self, index: GLuint, v: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI1iv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI1iv", &self.glVertexAttribI1iv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI1iv");
            }
            out
        }

        pub unsafe fn VertexAttribI1iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI1iv\0",
                &self.glVertexAttribI1iv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI1iv_is_loaded(&self) -> bool {
            !self.glVertexAttribI1iv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI1ui](http://docs.gl/gl4/glVertexAttribI)(index, x)
        /// * vector equivalent: [`glVertexAttribI1uiv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI1ui(&self, index: GLuint, x: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI1ui({:?}, {:?});", index, x);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI1ui", &self.glVertexAttribI1ui_p, index, x);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI1ui");
            }
            out
        }

        pub unsafe fn VertexAttribI1ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI1ui\0",
                &self.glVertexAttribI1ui_p,
            )
        }
        #[inline]

        pub fn VertexAttribI1ui_is_loaded(&self) -> bool {
            !self.glVertexAttribI1ui_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI1uiv](http://docs.gl/gl4/glVertexAttribI)(index, v)
        /// * `v` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI1uiv(&self, index: GLuint, v: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI1uiv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI1uiv", &self.glVertexAttribI1uiv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI1uiv");
            }
            out
        }

        pub unsafe fn VertexAttribI1uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI1uiv\0",
                &self.glVertexAttribI1uiv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI1uiv_is_loaded(&self) -> bool {
            !self.glVertexAttribI1uiv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI2i](http://docs.gl/gl4/glVertexAttribI)(index, x, y)
        /// * vector equivalent: [`glVertexAttribI2iv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI2i(&self, index: GLuint, x: GLint, y: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI2i({:?}, {:?}, {:?});", index, x, y);
            }
            let out =
                call_atomic_ptr_3arg("glVertexAttribI2i", &self.glVertexAttribI2i_p, index, x, y);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI2i");
            }
            out
        }

        pub unsafe fn VertexAttribI2i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI2i\0",
                &self.glVertexAttribI2i_p,
            )
        }
        #[inline]

        pub fn VertexAttribI2i_is_loaded(&self) -> bool {
            !self.glVertexAttribI2i_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI2iv](http://docs.gl/gl4/glVertexAttribI)(index, v)
        /// * `v` len: 2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI2iv(&self, index: GLuint, v: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI2iv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI2iv", &self.glVertexAttribI2iv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI2iv");
            }
            out
        }

        pub unsafe fn VertexAttribI2iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI2iv\0",
                &self.glVertexAttribI2iv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI2iv_is_loaded(&self) -> bool {
            !self.glVertexAttribI2iv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI2ui](http://docs.gl/gl4/glVertexAttribI)(index, x, y)
        /// * vector equivalent: [`glVertexAttribI2uiv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI2ui(&self, index: GLuint, x: GLuint, y: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribI2ui({:?}, {:?}, {:?});",
                    index,
                    x,
                    y
                );
            }
            let out = call_atomic_ptr_3arg(
                "glVertexAttribI2ui",
                &self.glVertexAttribI2ui_p,
                index,
                x,
                y,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI2ui");
            }
            out
        }

        pub unsafe fn VertexAttribI2ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI2ui\0",
                &self.glVertexAttribI2ui_p,
            )
        }
        #[inline]

        pub fn VertexAttribI2ui_is_loaded(&self) -> bool {
            !self.glVertexAttribI2ui_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI2uiv](http://docs.gl/gl4/glVertexAttribI)(index, v)
        /// * `v` len: 2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI2uiv(&self, index: GLuint, v: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI2uiv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI2uiv", &self.glVertexAttribI2uiv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI2uiv");
            }
            out
        }

        pub unsafe fn VertexAttribI2uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI2uiv\0",
                &self.glVertexAttribI2uiv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI2uiv_is_loaded(&self) -> bool {
            !self.glVertexAttribI2uiv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI3i](http://docs.gl/gl4/glVertexAttribI)(index, x, y, z)
        /// * vector equivalent: [`glVertexAttribI3iv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI3i(&self, index: GLuint, x: GLint, y: GLint, z: GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribI3i({:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribI3i",
                &self.glVertexAttribI3i_p,
                index,
                x,
                y,
                z,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI3i");
            }
            out
        }

        pub unsafe fn VertexAttribI3i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI3i\0",
                &self.glVertexAttribI3i_p,
            )
        }
        #[inline]

        pub fn VertexAttribI3i_is_loaded(&self) -> bool {
            !self.glVertexAttribI3i_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI3iv](http://docs.gl/gl4/glVertexAttribI)(index, v)
        /// * `v` len: 3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI3iv(&self, index: GLuint, v: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI3iv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI3iv", &self.glVertexAttribI3iv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI3iv");
            }
            out
        }

        pub unsafe fn VertexAttribI3iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI3iv\0",
                &self.glVertexAttribI3iv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI3iv_is_loaded(&self) -> bool {
            !self.glVertexAttribI3iv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI3ui](http://docs.gl/gl4/glVertexAttribI)(index, x, y, z)
        /// * vector equivalent: [`glVertexAttribI3uiv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI3ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribI3ui({:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribI3ui",
                &self.glVertexAttribI3ui_p,
                index,
                x,
                y,
                z,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI3ui");
            }
            out
        }

        pub unsafe fn VertexAttribI3ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI3ui\0",
                &self.glVertexAttribI3ui_p,
            )
        }
        #[inline]

        pub fn VertexAttribI3ui_is_loaded(&self) -> bool {
            !self.glVertexAttribI3ui_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI3uiv](http://docs.gl/gl4/glVertexAttribI)(index, v)
        /// * `v` len: 3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI3uiv(&self, index: GLuint, v: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI3uiv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI3uiv", &self.glVertexAttribI3uiv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI3uiv");
            }
            out
        }

        pub unsafe fn VertexAttribI3uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI3uiv\0",
                &self.glVertexAttribI3uiv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI3uiv_is_loaded(&self) -> bool {
            !self.glVertexAttribI3uiv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI4bv](http://docs.gl/gl4/glVertexAttribI4bv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI4bv(&self, index: GLuint, v: *const GLbyte) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI4bv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI4bv", &self.glVertexAttribI4bv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI4bv");
            }
            out
        }

        pub unsafe fn VertexAttribI4bv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI4bv\0",
                &self.glVertexAttribI4bv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI4bv_is_loaded(&self) -> bool {
            !self.glVertexAttribI4bv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI4i](http://docs.gl/gl4/glVertexAttribI)(index, x, y, z, w)
        /// * vector equivalent: [`glVertexAttribI4iv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI4i(
            &self,
            index: GLuint,
            x: GLint,
            y: GLint,
            z: GLint,
            w: GLint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribI4i({:?}, {:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z,
                    w
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexAttribI4i",
                &self.glVertexAttribI4i_p,
                index,
                x,
                y,
                z,
                w,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI4i");
            }
            out
        }

        pub unsafe fn VertexAttribI4i_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI4i\0",
                &self.glVertexAttribI4i_p,
            )
        }
        #[inline]

        pub fn VertexAttribI4i_is_loaded(&self) -> bool {
            !self.glVertexAttribI4i_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI4iv](http://docs.gl/gl4/glVertexAttrib)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI4iv(&self, index: GLuint, v: *const GLint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI4iv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI4iv", &self.glVertexAttribI4iv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI4iv");
            }
            out
        }

        pub unsafe fn VertexAttribI4iv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI4iv\0",
                &self.glVertexAttribI4iv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI4iv_is_loaded(&self) -> bool {
            !self.glVertexAttribI4iv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI4sv](http://docs.gl/gl4/glVertexAttribI4sv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI4sv(&self, index: GLuint, v: *const GLshort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI4sv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI4sv", &self.glVertexAttribI4sv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI4sv");
            }
            out
        }

        pub unsafe fn VertexAttribI4sv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI4sv\0",
                &self.glVertexAttribI4sv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI4sv_is_loaded(&self) -> bool {
            !self.glVertexAttribI4sv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI4ubv](http://docs.gl/gl4/glVertexAttribI4ubv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI4ubv(&self, index: GLuint, v: *const GLubyte) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI4ubv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI4ubv", &self.glVertexAttribI4ubv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI4ubv");
            }
            out
        }

        pub unsafe fn VertexAttribI4ubv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI4ubv\0",
                &self.glVertexAttribI4ubv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI4ubv_is_loaded(&self) -> bool {
            !self.glVertexAttribI4ubv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI4ui](http://docs.gl/gl4/glVertexAttrib)(index, x, y, z, w)
        /// * vector equivalent: [`glVertexAttribI4uiv`]
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI4ui(
            &self,
            index: GLuint,
            x: GLuint,
            y: GLuint,
            z: GLuint,
            w: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribI4ui({:?}, {:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z,
                    w
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexAttribI4ui",
                &self.glVertexAttribI4ui_p,
                index,
                x,
                y,
                z,
                w,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI4ui");
            }
            out
        }

        pub unsafe fn VertexAttribI4ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI4ui\0",
                &self.glVertexAttribI4ui_p,
            )
        }
        #[inline]

        pub fn VertexAttribI4ui_is_loaded(&self) -> bool {
            !self.glVertexAttribI4ui_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI4uiv](http://docs.gl/gl4/glVertexAttrib)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI4uiv(&self, index: GLuint, v: *const GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI4uiv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI4uiv", &self.glVertexAttribI4uiv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI4uiv");
            }
            out
        }

        pub unsafe fn VertexAttribI4uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI4uiv\0",
                &self.glVertexAttribI4uiv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI4uiv_is_loaded(&self) -> bool {
            !self.glVertexAttribI4uiv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribI4usv](http://docs.gl/gl4/glVertexAttribI4usv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribI4usv(&self, index: GLuint, v: *const GLushort) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribI4usv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribI4usv", &self.glVertexAttribI4usv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribI4usv");
            }
            out
        }

        pub unsafe fn VertexAttribI4usv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribI4usv\0",
                &self.glVertexAttribI4usv_p,
            )
        }
        #[inline]

        pub fn VertexAttribI4usv_is_loaded(&self) -> bool {
            !self.glVertexAttribI4usv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribIFormat](http://docs.gl/gl4/glVertexAttribIFormat)(attribindex, size, type_, relativeoffset)
        /// * `type_` group: VertexAttribIType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribIFormat(
            &self,
            attribindex: GLuint,
            size: GLint,
            type_: GLenum,
            relativeoffset: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribIFormat({:?}, {:?}, {:#X}, {:?});",
                    attribindex,
                    size,
                    type_,
                    relativeoffset
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribIFormat",
                &self.glVertexAttribIFormat_p,
                attribindex,
                size,
                type_,
                relativeoffset,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribIFormat");
            }
            out
        }

        pub unsafe fn VertexAttribIFormat_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribIFormat\0",
                &self.glVertexAttribIFormat_p,
            )
        }
        #[inline]

        pub fn VertexAttribIFormat_is_loaded(&self) -> bool {
            !self.glVertexAttribIFormat_p.load(RELAX).is_null()
        }
        /// [glVertexAttribIPointer](http://docs.gl/gl4/glVertexAttribPointer)(index, size, type_, stride, pointer)
        /// * `type_` group: VertexAttribIType
        /// * `pointer` len: COMPSIZE(size,type,stride)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribIPointer(
            &self,
            index: GLuint,
            size: GLint,
            type_: GLenum,
            stride: GLsizei,
            pointer: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribIPointer({:?}, {:?}, {:#X}, {:?}, {:p});",
                    index,
                    size,
                    type_,
                    stride,
                    pointer
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexAttribIPointer",
                &self.glVertexAttribIPointer_p,
                index,
                size,
                type_,
                stride,
                pointer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribIPointer");
            }
            out
        }

        pub unsafe fn VertexAttribIPointer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribIPointer\0",
                &self.glVertexAttribIPointer_p,
            )
        }
        #[inline]

        pub fn VertexAttribIPointer_is_loaded(&self) -> bool {
            !self.glVertexAttribIPointer_p.load(RELAX).is_null()
        }
        /// [glVertexAttribL1d](http://docs.gl/gl4/glVertexAttribL1d)(index, x)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribL1d(&self, index: GLuint, x: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribL1d({:?}, {:?});", index, x);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribL1d", &self.glVertexAttribL1d_p, index, x);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribL1d");
            }
            out
        }

        pub unsafe fn VertexAttribL1d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribL1d\0",
                &self.glVertexAttribL1d_p,
            )
        }
        #[inline]

        pub fn VertexAttribL1d_is_loaded(&self) -> bool {
            !self.glVertexAttribL1d_p.load(RELAX).is_null()
        }
        /// [glVertexAttribL1dv](http://docs.gl/gl4/glVertexAttribL1dv)(index, v)
        /// * `v` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribL1dv(&self, index: GLuint, v: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribL1dv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribL1dv", &self.glVertexAttribL1dv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribL1dv");
            }
            out
        }

        pub unsafe fn VertexAttribL1dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribL1dv\0",
                &self.glVertexAttribL1dv_p,
            )
        }
        #[inline]

        pub fn VertexAttribL1dv_is_loaded(&self) -> bool {
            !self.glVertexAttribL1dv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribL2d](http://docs.gl/gl4/glVertexAttribL2d)(index, x, y)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribL2d(&self, index: GLuint, x: GLdouble, y: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribL2d({:?}, {:?}, {:?});", index, x, y);
            }
            let out =
                call_atomic_ptr_3arg("glVertexAttribL2d", &self.glVertexAttribL2d_p, index, x, y);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribL2d");
            }
            out
        }

        pub unsafe fn VertexAttribL2d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribL2d\0",
                &self.glVertexAttribL2d_p,
            )
        }
        #[inline]

        pub fn VertexAttribL2d_is_loaded(&self) -> bool {
            !self.glVertexAttribL2d_p.load(RELAX).is_null()
        }
        /// [glVertexAttribL2dv](http://docs.gl/gl4/glVertexAttribL2dv)(index, v)
        /// * `v` len: 2
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribL2dv(&self, index: GLuint, v: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribL2dv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribL2dv", &self.glVertexAttribL2dv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribL2dv");
            }
            out
        }

        pub unsafe fn VertexAttribL2dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribL2dv\0",
                &self.glVertexAttribL2dv_p,
            )
        }
        #[inline]

        pub fn VertexAttribL2dv_is_loaded(&self) -> bool {
            !self.glVertexAttribL2dv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribL3d](http://docs.gl/gl4/glVertexAttribL3d)(index, x, y, z)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribL3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribL3d({:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribL3d",
                &self.glVertexAttribL3d_p,
                index,
                x,
                y,
                z,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribL3d");
            }
            out
        }

        pub unsafe fn VertexAttribL3d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribL3d\0",
                &self.glVertexAttribL3d_p,
            )
        }
        #[inline]

        pub fn VertexAttribL3d_is_loaded(&self) -> bool {
            !self.glVertexAttribL3d_p.load(RELAX).is_null()
        }
        /// [glVertexAttribL3dv](http://docs.gl/gl4/glVertexAttribL3dv)(index, v)
        /// * `v` len: 3
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribL3dv(&self, index: GLuint, v: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribL3dv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribL3dv", &self.glVertexAttribL3dv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribL3dv");
            }
            out
        }

        pub unsafe fn VertexAttribL3dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribL3dv\0",
                &self.glVertexAttribL3dv_p,
            )
        }
        #[inline]

        pub fn VertexAttribL3dv_is_loaded(&self) -> bool {
            !self.glVertexAttribL3dv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribL4d](http://docs.gl/gl4/glVertexAttribL4d)(index, x, y, z, w)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribL4d(
            &self,
            index: GLuint,
            x: GLdouble,
            y: GLdouble,
            z: GLdouble,
            w: GLdouble,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribL4d({:?}, {:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    z,
                    w
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexAttribL4d",
                &self.glVertexAttribL4d_p,
                index,
                x,
                y,
                z,
                w,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribL4d");
            }
            out
        }

        pub unsafe fn VertexAttribL4d_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribL4d\0",
                &self.glVertexAttribL4d_p,
            )
        }
        #[inline]

        pub fn VertexAttribL4d_is_loaded(&self) -> bool {
            !self.glVertexAttribL4d_p.load(RELAX).is_null()
        }
        /// [glVertexAttribL4dv](http://docs.gl/gl4/glVertexAttribL4dv)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribL4dv(&self, index: GLuint, v: *const GLdouble) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.VertexAttribL4dv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glVertexAttribL4dv", &self.glVertexAttribL4dv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribL4dv");
            }
            out
        }

        pub unsafe fn VertexAttribL4dv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribL4dv\0",
                &self.glVertexAttribL4dv_p,
            )
        }
        #[inline]

        pub fn VertexAttribL4dv_is_loaded(&self) -> bool {
            !self.glVertexAttribL4dv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribLFormat](http://docs.gl/gl4/glVertexAttribLFormat)(attribindex, size, type_, relativeoffset)
        /// * `type_` group: VertexAttribLType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribLFormat(
            &self,
            attribindex: GLuint,
            size: GLint,
            type_: GLenum,
            relativeoffset: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribLFormat({:?}, {:?}, {:#X}, {:?});",
                    attribindex,
                    size,
                    type_,
                    relativeoffset
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribLFormat",
                &self.glVertexAttribLFormat_p,
                attribindex,
                size,
                type_,
                relativeoffset,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribLFormat");
            }
            out
        }

        pub unsafe fn VertexAttribLFormat_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribLFormat\0",
                &self.glVertexAttribLFormat_p,
            )
        }
        #[inline]

        pub fn VertexAttribLFormat_is_loaded(&self) -> bool {
            !self.glVertexAttribLFormat_p.load(RELAX).is_null()
        }
        /// [glVertexAttribLPointer](http://docs.gl/gl4/glVertexAttribLPointer)(index, size, type_, stride, pointer)
        /// * `type_` group: VertexAttribLType
        /// * `pointer` len: size
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribLPointer(
            &self,
            index: GLuint,
            size: GLint,
            type_: GLenum,
            stride: GLsizei,
            pointer: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribLPointer({:?}, {:?}, {:#X}, {:?}, {:p});",
                    index,
                    size,
                    type_,
                    stride,
                    pointer
                );
            }
            let out = call_atomic_ptr_5arg(
                "glVertexAttribLPointer",
                &self.glVertexAttribLPointer_p,
                index,
                size,
                type_,
                stride,
                pointer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribLPointer");
            }
            out
        }

        pub unsafe fn VertexAttribLPointer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribLPointer\0",
                &self.glVertexAttribLPointer_p,
            )
        }
        #[inline]

        pub fn VertexAttribLPointer_is_loaded(&self) -> bool {
            !self.glVertexAttribLPointer_p.load(RELAX).is_null()
        }
        /// [glVertexAttribP1ui](http://docs.gl/gl4/glVertexAttribP)(index, type_, normalized, value)
        /// * `type_` group: VertexAttribPointerType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribP1ui(
            &self,
            index: GLuint,
            type_: GLenum,
            normalized: GLboolean,
            value: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribP1ui({:?}, {:#X}, {:?}, {:?});",
                    index,
                    type_,
                    normalized,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribP1ui",
                &self.glVertexAttribP1ui_p,
                index,
                type_,
                normalized,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribP1ui");
            }
            out
        }

        pub unsafe fn VertexAttribP1ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribP1ui\0",
                &self.glVertexAttribP1ui_p,
            )
        }
        #[inline]

        pub fn VertexAttribP1ui_is_loaded(&self) -> bool {
            !self.glVertexAttribP1ui_p.load(RELAX).is_null()
        }
        /// [glVertexAttribP1uiv](http://docs.gl/gl4/glVertexAttribP)(index, type_, normalized, value)
        /// * `type_` group: VertexAttribPointerType
        /// * `value` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribP1uiv(
            &self,
            index: GLuint,
            type_: GLenum,
            normalized: GLboolean,
            value: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribP1uiv({:?}, {:#X}, {:?}, {:p});",
                    index,
                    type_,
                    normalized,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribP1uiv",
                &self.glVertexAttribP1uiv_p,
                index,
                type_,
                normalized,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribP1uiv");
            }
            out
        }

        pub unsafe fn VertexAttribP1uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribP1uiv\0",
                &self.glVertexAttribP1uiv_p,
            )
        }
        #[inline]

        pub fn VertexAttribP1uiv_is_loaded(&self) -> bool {
            !self.glVertexAttribP1uiv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribP2ui](http://docs.gl/gl4/glVertexAttribP)(index, type_, normalized, value)
        /// * `type_` group: VertexAttribPointerType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribP2ui(
            &self,
            index: GLuint,
            type_: GLenum,
            normalized: GLboolean,
            value: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribP2ui({:?}, {:#X}, {:?}, {:?});",
                    index,
                    type_,
                    normalized,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribP2ui",
                &self.glVertexAttribP2ui_p,
                index,
                type_,
                normalized,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribP2ui");
            }
            out
        }

        pub unsafe fn VertexAttribP2ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribP2ui\0",
                &self.glVertexAttribP2ui_p,
            )
        }
        #[inline]

        pub fn VertexAttribP2ui_is_loaded(&self) -> bool {
            !self.glVertexAttribP2ui_p.load(RELAX).is_null()
        }
        /// [glVertexAttribP2uiv](http://docs.gl/gl4/glVertexAttribP)(index, type_, normalized, value)
        /// * `type_` group: VertexAttribPointerType
        /// * `value` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribP2uiv(
            &self,
            index: GLuint,
            type_: GLenum,
            normalized: GLboolean,
            value: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribP2uiv({:?}, {:#X}, {:?}, {:p});",
                    index,
                    type_,
                    normalized,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribP2uiv",
                &self.glVertexAttribP2uiv_p,
                index,
                type_,
                normalized,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribP2uiv");
            }
            out
        }

        pub unsafe fn VertexAttribP2uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribP2uiv\0",
                &self.glVertexAttribP2uiv_p,
            )
        }
        #[inline]

        pub fn VertexAttribP2uiv_is_loaded(&self) -> bool {
            !self.glVertexAttribP2uiv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribP3ui](http://docs.gl/gl4/glVertexAttribP)(index, type_, normalized, value)
        /// * `type_` group: VertexAttribPointerType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribP3ui(
            &self,
            index: GLuint,
            type_: GLenum,
            normalized: GLboolean,
            value: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribP3ui({:?}, {:#X}, {:?}, {:?});",
                    index,
                    type_,
                    normalized,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribP3ui",
                &self.glVertexAttribP3ui_p,
                index,
                type_,
                normalized,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribP3ui");
            }
            out
        }

        pub unsafe fn VertexAttribP3ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribP3ui\0",
                &self.glVertexAttribP3ui_p,
            )
        }
        #[inline]

        pub fn VertexAttribP3ui_is_loaded(&self) -> bool {
            !self.glVertexAttribP3ui_p.load(RELAX).is_null()
        }
        /// [glVertexAttribP3uiv](http://docs.gl/gl4/glVertexAttribP)(index, type_, normalized, value)
        /// * `type_` group: VertexAttribPointerType
        /// * `value` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribP3uiv(
            &self,
            index: GLuint,
            type_: GLenum,
            normalized: GLboolean,
            value: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribP3uiv({:?}, {:#X}, {:?}, {:p});",
                    index,
                    type_,
                    normalized,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribP3uiv",
                &self.glVertexAttribP3uiv_p,
                index,
                type_,
                normalized,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribP3uiv");
            }
            out
        }

        pub unsafe fn VertexAttribP3uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribP3uiv\0",
                &self.glVertexAttribP3uiv_p,
            )
        }
        #[inline]

        pub fn VertexAttribP3uiv_is_loaded(&self) -> bool {
            !self.glVertexAttribP3uiv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribP4ui](http://docs.gl/gl4/glVertexAttribP)(index, type_, normalized, value)
        /// * `type_` group: VertexAttribPointerType
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribP4ui(
            &self,
            index: GLuint,
            type_: GLenum,
            normalized: GLboolean,
            value: GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribP4ui({:?}, {:#X}, {:?}, {:?});",
                    index,
                    type_,
                    normalized,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribP4ui",
                &self.glVertexAttribP4ui_p,
                index,
                type_,
                normalized,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribP4ui");
            }
            out
        }

        pub unsafe fn VertexAttribP4ui_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribP4ui\0",
                &self.glVertexAttribP4ui_p,
            )
        }
        #[inline]

        pub fn VertexAttribP4ui_is_loaded(&self) -> bool {
            !self.glVertexAttribP4ui_p.load(RELAX).is_null()
        }
        /// [glVertexAttribP4uiv](http://docs.gl/gl4/glVertexAttribP)(index, type_, normalized, value)
        /// * `type_` group: VertexAttribPointerType
        /// * `value` len: 1
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribP4uiv(
            &self,
            index: GLuint,
            type_: GLenum,
            normalized: GLboolean,
            value: *const GLuint,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribP4uiv({:?}, {:#X}, {:?}, {:p});",
                    index,
                    type_,
                    normalized,
                    value
                );
            }
            let out = call_atomic_ptr_4arg(
                "glVertexAttribP4uiv",
                &self.glVertexAttribP4uiv_p,
                index,
                type_,
                normalized,
                value,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribP4uiv");
            }
            out
        }

        pub unsafe fn VertexAttribP4uiv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribP4uiv\0",
                &self.glVertexAttribP4uiv_p,
            )
        }
        #[inline]

        pub fn VertexAttribP4uiv_is_loaded(&self) -> bool {
            !self.glVertexAttribP4uiv_p.load(RELAX).is_null()
        }
        /// [glVertexAttribPointer](http://docs.gl/gl4/glVertexAttribPointer)(index, size, type_, normalized, stride, pointer)
        /// * `type_` group: VertexAttribPointerType
        /// * `pointer` len: COMPSIZE(size,type,stride)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexAttribPointer(
            &self,
            index: GLuint,
            size: GLint,
            type_: GLenum,
            normalized: GLboolean,
            stride: GLsizei,
            pointer: *const c_void,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexAttribPointer({:?}, {:?}, {:#X}, {:?}, {:?}, {:p});",
                    index,
                    size,
                    type_,
                    normalized,
                    stride,
                    pointer
                );
            }
            let out = call_atomic_ptr_6arg(
                "glVertexAttribPointer",
                &self.glVertexAttribPointer_p,
                index,
                size,
                type_,
                normalized,
                stride,
                pointer,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexAttribPointer");
            }
            out
        }

        pub unsafe fn VertexAttribPointer_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexAttribPointer\0",
                &self.glVertexAttribPointer_p,
            )
        }
        #[inline]

        pub fn VertexAttribPointer_is_loaded(&self) -> bool {
            !self.glVertexAttribPointer_p.load(RELAX).is_null()
        }
        /// [glVertexBindingDivisor](http://docs.gl/gl4/glVertexBindingDivisor)(bindingindex, divisor)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn VertexBindingDivisor(&self, bindingindex: GLuint, divisor: GLuint) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.VertexBindingDivisor({:?}, {:?});",
                    bindingindex,
                    divisor
                );
            }
            let out = call_atomic_ptr_2arg(
                "glVertexBindingDivisor",
                &self.glVertexBindingDivisor_p,
                bindingindex,
                divisor,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glVertexBindingDivisor");
            }
            out
        }

        pub unsafe fn VertexBindingDivisor_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glVertexBindingDivisor\0",
                &self.glVertexBindingDivisor_p,
            )
        }
        #[inline]

        pub fn VertexBindingDivisor_is_loaded(&self) -> bool {
            !self.glVertexBindingDivisor_p.load(RELAX).is_null()
        }
        /// [glViewport](http://docs.gl/gl4/glViewport)(x, y, width, height)
        /// * `x` group: WinCoord
        /// * `y` group: WinCoord
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn Viewport(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.Viewport({:?}, {:?}, {:?}, {:?});",
                    x,
                    y,
                    width,
                    height
                );
            }
            let out = call_atomic_ptr_4arg("glViewport", &self.glViewport_p, x, y, width, height);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glViewport");
            }
            out
        }

        pub unsafe fn Viewport_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glViewport\0", &self.glViewport_p)
        }
        #[inline]

        pub fn Viewport_is_loaded(&self) -> bool {
            !self.glViewport_p.load(RELAX).is_null()
        }
        /// [glViewportArrayv](http://docs.gl/gl4/glViewportArrayv)(first, count, v)
        /// * `v` len: COMPSIZE(count)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ViewportArrayv(&self, first: GLuint, count: GLsizei, v: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ViewportArrayv({:?}, {:?}, {:p});",
                    first,
                    count,
                    v
                );
            }
            let out = call_atomic_ptr_3arg(
                "glViewportArrayv",
                &self.glViewportArrayv_p,
                first,
                count,
                v,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glViewportArrayv");
            }
            out
        }

        pub unsafe fn ViewportArrayv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glViewportArrayv\0",
                &self.glViewportArrayv_p,
            )
        }
        #[inline]

        pub fn ViewportArrayv_is_loaded(&self) -> bool {
            !self.glViewportArrayv_p.load(RELAX).is_null()
        }
        /// [glViewportIndexedf](http://docs.gl/gl4/glViewportIndexed)(index, x, y, w, h)
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ViewportIndexedf(
            &self,
            index: GLuint,
            x: GLfloat,
            y: GLfloat,
            w: GLfloat,
            h: GLfloat,
        ) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.ViewportIndexedf({:?}, {:?}, {:?}, {:?}, {:?});",
                    index,
                    x,
                    y,
                    w,
                    h
                );
            }
            let out = call_atomic_ptr_5arg(
                "glViewportIndexedf",
                &self.glViewportIndexedf_p,
                index,
                x,
                y,
                w,
                h,
            );
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glViewportIndexedf");
            }
            out
        }

        pub unsafe fn ViewportIndexedf_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glViewportIndexedf\0",
                &self.glViewportIndexedf_p,
            )
        }
        #[inline]

        pub fn ViewportIndexedf_is_loaded(&self) -> bool {
            !self.glViewportIndexedf_p.load(RELAX).is_null()
        }
        /// [glViewportIndexedfv](http://docs.gl/gl4/glViewportIndexed)(index, v)
        /// * `v` len: 4
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn ViewportIndexedfv(&self, index: GLuint, v: *const GLfloat) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!("calling gl.ViewportIndexedfv({:?}, {:p});", index, v);
            }
            let out =
                call_atomic_ptr_2arg("glViewportIndexedfv", &self.glViewportIndexedfv_p, index, v);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glViewportIndexedfv");
            }
            out
        }

        pub unsafe fn ViewportIndexedfv_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(
                get_proc_address,
                b"glViewportIndexedfv\0",
                &self.glViewportIndexedfv_p,
            )
        }
        #[inline]

        pub fn ViewportIndexedfv_is_loaded(&self) -> bool {
            !self.glViewportIndexedfv_p.load(RELAX).is_null()
        }
        /// [glWaitSync](http://docs.gl/gl4/glWaitSync)(sync, flags, timeout)
        /// * `sync` group: sync
        /// * `sync` class: sync
        /// * `flags` group: SyncBehaviorFlags
        #[cfg_attr(feature = "inline", inline)]
        #[cfg_attr(feature = "inline_always", inline(always))]
        pub unsafe fn WaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) {
            #[cfg(all(debug_assertions, feature = "trace-calls"))]
            {
                trace!(
                    "calling gl.WaitSync({:p}, {:?}, {:?});",
                    sync,
                    flags,
                    timeout
                );
            }
            let out = call_atomic_ptr_3arg("glWaitSync", &self.glWaitSync_p, sync, flags, timeout);
            #[cfg(all(debug_assertions, feature = "trace-errors"))]
            {
                self.automatic_glGetError("glWaitSync");
            }
            out
        }

        pub unsafe fn WaitSync_load_with_dyn(
            &self,
            get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
        ) -> bool {
            load_dyn_name_atomic_ptr(get_proc_address, b"glWaitSync\0", &self.glWaitSync_p)
        }
        #[inline]

        pub fn WaitSync_is_loaded(&self) -> bool {
            !self.glWaitSync_p.load(RELAX).is_null()
        }
    }
    /// This holds the many, many function pointers for GL.
    ///
    /// It's typically quite large (hundreds of pointers), depending on what API level and extensions you selected during the generation.
    #[repr(C)]
    pub struct GlFns {
        glActiveShaderProgram_p: APcv,
        glActiveTexture_p: APcv,
        glAttachShader_p: APcv,
        glBeginConditionalRender_p: APcv,
        glBeginQuery_p: APcv,
        glBeginQueryIndexed_p: APcv,
        glBeginTransformFeedback_p: APcv,
        glBindAttribLocation_p: APcv,
        glBindBuffer_p: APcv,
        glBindBufferBase_p: APcv,
        glBindBufferRange_p: APcv,
        glBindBuffersBase_p: APcv,
        glBindBuffersRange_p: APcv,
        glBindFragDataLocation_p: APcv,
        glBindFragDataLocationIndexed_p: APcv,
        glBindFramebuffer_p: APcv,
        glBindImageTexture_p: APcv,
        glBindImageTextures_p: APcv,
        glBindProgramPipeline_p: APcv,
        glBindRenderbuffer_p: APcv,
        glBindSampler_p: APcv,
        glBindSamplers_p: APcv,
        glBindTexture_p: APcv,
        glBindTextureUnit_p: APcv,
        glBindTextures_p: APcv,
        glBindTransformFeedback_p: APcv,
        glBindVertexArray_p: APcv,
        glBindVertexBuffer_p: APcv,
        glBindVertexBuffers_p: APcv,
        glBlendColor_p: APcv,
        glBlendEquation_p: APcv,
        glBlendEquationSeparate_p: APcv,
        glBlendEquationSeparatei_p: APcv,
        glBlendEquationi_p: APcv,
        glBlendFunc_p: APcv,
        glBlendFuncSeparate_p: APcv,
        glBlendFuncSeparatei_p: APcv,
        glBlendFunci_p: APcv,
        glBlitFramebuffer_p: APcv,
        glBlitNamedFramebuffer_p: APcv,
        glBufferData_p: APcv,
        glBufferStorage_p: APcv,
        glBufferSubData_p: APcv,
        glCheckFramebufferStatus_p: APcv,
        glCheckNamedFramebufferStatus_p: APcv,
        glClampColor_p: APcv,
        glClear_p: APcv,
        glClearBufferData_p: APcv,
        glClearBufferSubData_p: APcv,
        glClearBufferfi_p: APcv,
        glClearBufferfv_p: APcv,
        glClearBufferiv_p: APcv,
        glClearBufferuiv_p: APcv,
        glClearColor_p: APcv,
        glClearDepth_p: APcv,
        glClearDepthf_p: APcv,
        glClearNamedBufferData_p: APcv,
        glClearNamedBufferSubData_p: APcv,
        glClearNamedFramebufferfi_p: APcv,
        glClearNamedFramebufferfv_p: APcv,
        glClearNamedFramebufferiv_p: APcv,
        glClearNamedFramebufferuiv_p: APcv,
        glClearStencil_p: APcv,
        glClearTexImage_p: APcv,
        glClearTexSubImage_p: APcv,
        glClientWaitSync_p: APcv,
        glClipControl_p: APcv,
        glColorMask_p: APcv,
        glColorMaski_p: APcv,
        glCompileShader_p: APcv,
        glCompressedTexImage1D_p: APcv,
        glCompressedTexImage2D_p: APcv,
        glCompressedTexImage3D_p: APcv,
        glCompressedTexSubImage1D_p: APcv,
        glCompressedTexSubImage2D_p: APcv,
        glCompressedTexSubImage3D_p: APcv,
        glCompressedTextureSubImage1D_p: APcv,
        glCompressedTextureSubImage2D_p: APcv,
        glCompressedTextureSubImage3D_p: APcv,
        glCopyBufferSubData_p: APcv,
        glCopyImageSubData_p: APcv,
        glCopyNamedBufferSubData_p: APcv,
        glCopyTexImage1D_p: APcv,
        glCopyTexImage2D_p: APcv,
        glCopyTexSubImage1D_p: APcv,
        glCopyTexSubImage2D_p: APcv,
        glCopyTexSubImage3D_p: APcv,
        glCopyTextureSubImage1D_p: APcv,
        glCopyTextureSubImage2D_p: APcv,
        glCopyTextureSubImage3D_p: APcv,
        glCreateBuffers_p: APcv,
        glCreateFramebuffers_p: APcv,
        glCreateProgram_p: APcv,
        glCreateProgramPipelines_p: APcv,
        glCreateQueries_p: APcv,
        glCreateRenderbuffers_p: APcv,
        glCreateSamplers_p: APcv,
        glCreateShader_p: APcv,
        glCreateShaderProgramv_p: APcv,
        glCreateTextures_p: APcv,
        glCreateTransformFeedbacks_p: APcv,
        glCreateVertexArrays_p: APcv,
        glCullFace_p: APcv,
        glDebugMessageCallback_p: APcv,
        glDebugMessageControl_p: APcv,
        glDebugMessageInsert_p: APcv,
        glDeleteBuffers_p: APcv,
        glDeleteFramebuffers_p: APcv,
        glDeleteProgram_p: APcv,
        glDeleteProgramPipelines_p: APcv,
        glDeleteQueries_p: APcv,
        glDeleteRenderbuffers_p: APcv,
        glDeleteSamplers_p: APcv,
        glDeleteShader_p: APcv,
        glDeleteSync_p: APcv,
        glDeleteTextures_p: APcv,
        glDeleteTransformFeedbacks_p: APcv,
        glDeleteVertexArrays_p: APcv,
        glDepthFunc_p: APcv,
        glDepthMask_p: APcv,
        glDepthRange_p: APcv,
        glDepthRangeArrayv_p: APcv,
        glDepthRangeIndexed_p: APcv,
        glDepthRangef_p: APcv,
        glDetachShader_p: APcv,
        glDisable_p: APcv,
        glDisableVertexArrayAttrib_p: APcv,
        glDisableVertexAttribArray_p: APcv,
        glDisablei_p: APcv,
        glDispatchCompute_p: APcv,
        glDispatchComputeIndirect_p: APcv,
        glDrawArrays_p: APcv,
        glDrawArraysIndirect_p: APcv,
        glDrawArraysInstanced_p: APcv,
        glDrawArraysInstancedBaseInstance_p: APcv,
        glDrawBuffer_p: APcv,
        glDrawBuffers_p: APcv,
        glDrawElements_p: APcv,
        glDrawElementsBaseVertex_p: APcv,
        glDrawElementsIndirect_p: APcv,
        glDrawElementsInstanced_p: APcv,
        glDrawElementsInstancedBaseInstance_p: APcv,
        glDrawElementsInstancedBaseVertex_p: APcv,
        glDrawElementsInstancedBaseVertexBaseInstance_p: APcv,
        glDrawRangeElements_p: APcv,
        glDrawRangeElementsBaseVertex_p: APcv,
        glDrawTransformFeedback_p: APcv,
        glDrawTransformFeedbackInstanced_p: APcv,
        glDrawTransformFeedbackStream_p: APcv,
        glDrawTransformFeedbackStreamInstanced_p: APcv,
        glEnable_p: APcv,
        glEnableVertexArrayAttrib_p: APcv,
        glEnableVertexAttribArray_p: APcv,
        glEnablei_p: APcv,
        glEndConditionalRender_p: APcv,
        glEndQuery_p: APcv,
        glEndQueryIndexed_p: APcv,
        glEndTransformFeedback_p: APcv,
        glFenceSync_p: APcv,
        glFinish_p: APcv,
        glFlush_p: APcv,
        glFlushMappedBufferRange_p: APcv,
        glFlushMappedNamedBufferRange_p: APcv,
        glFramebufferParameteri_p: APcv,
        glFramebufferRenderbuffer_p: APcv,
        glFramebufferTexture_p: APcv,
        glFramebufferTexture1D_p: APcv,
        glFramebufferTexture2D_p: APcv,
        glFramebufferTexture3D_p: APcv,
        glFramebufferTextureLayer_p: APcv,
        glFrontFace_p: APcv,
        glGenBuffers_p: APcv,
        glGenFramebuffers_p: APcv,
        glGenProgramPipelines_p: APcv,
        glGenQueries_p: APcv,
        glGenRenderbuffers_p: APcv,
        glGenSamplers_p: APcv,
        glGenTextures_p: APcv,
        glGenTransformFeedbacks_p: APcv,
        glGenVertexArrays_p: APcv,
        glGenerateMipmap_p: APcv,
        glGenerateTextureMipmap_p: APcv,
        glGetActiveAtomicCounterBufferiv_p: APcv,
        glGetActiveAttrib_p: APcv,
        glGetActiveSubroutineName_p: APcv,
        glGetActiveSubroutineUniformName_p: APcv,
        glGetActiveSubroutineUniformiv_p: APcv,
        glGetActiveUniform_p: APcv,
        glGetActiveUniformBlockName_p: APcv,
        glGetActiveUniformBlockiv_p: APcv,
        glGetActiveUniformName_p: APcv,
        glGetActiveUniformsiv_p: APcv,
        glGetAttachedShaders_p: APcv,
        glGetAttribLocation_p: APcv,
        glGetBooleani_v_p: APcv,
        glGetBooleanv_p: APcv,
        glGetBufferParameteri64v_p: APcv,
        glGetBufferParameteriv_p: APcv,
        glGetBufferPointerv_p: APcv,
        glGetBufferSubData_p: APcv,
        glGetCompressedTexImage_p: APcv,
        glGetCompressedTextureImage_p: APcv,
        glGetCompressedTextureSubImage_p: APcv,
        glGetDebugMessageLog_p: APcv,
        glGetDoublei_v_p: APcv,
        glGetDoublev_p: APcv,
        glGetError_p: APcv,
        glGetFloati_v_p: APcv,
        glGetFloatv_p: APcv,
        glGetFragDataIndex_p: APcv,
        glGetFragDataLocation_p: APcv,
        glGetFramebufferAttachmentParameteriv_p: APcv,
        glGetFramebufferParameteriv_p: APcv,
        glGetGraphicsResetStatus_p: APcv,
        glGetInteger64i_v_p: APcv,
        glGetInteger64v_p: APcv,
        glGetIntegeri_v_p: APcv,
        glGetIntegerv_p: APcv,
        glGetInternalformati64v_p: APcv,
        glGetInternalformativ_p: APcv,
        glGetMultisamplefv_p: APcv,
        glGetNamedBufferParameteri64v_p: APcv,
        glGetNamedBufferParameteriv_p: APcv,
        glGetNamedBufferPointerv_p: APcv,
        glGetNamedBufferSubData_p: APcv,
        glGetNamedFramebufferAttachmentParameteriv_p: APcv,
        glGetNamedFramebufferParameteriv_p: APcv,
        glGetNamedRenderbufferParameteriv_p: APcv,
        glGetObjectLabel_p: APcv,
        glGetObjectPtrLabel_p: APcv,
        glGetPointerv_p: APcv,
        glGetProgramBinary_p: APcv,
        glGetProgramInfoLog_p: APcv,
        glGetProgramInterfaceiv_p: APcv,
        glGetProgramPipelineInfoLog_p: APcv,
        glGetProgramPipelineiv_p: APcv,
        glGetProgramResourceIndex_p: APcv,
        glGetProgramResourceLocation_p: APcv,
        glGetProgramResourceLocationIndex_p: APcv,
        glGetProgramResourceName_p: APcv,
        glGetProgramResourceiv_p: APcv,
        glGetProgramStageiv_p: APcv,
        glGetProgramiv_p: APcv,
        glGetQueryBufferObjecti64v_p: APcv,
        glGetQueryBufferObjectiv_p: APcv,
        glGetQueryBufferObjectui64v_p: APcv,
        glGetQueryBufferObjectuiv_p: APcv,
        glGetQueryIndexediv_p: APcv,
        glGetQueryObjecti64v_p: APcv,
        glGetQueryObjectiv_p: APcv,
        glGetQueryObjectui64v_p: APcv,
        glGetQueryObjectuiv_p: APcv,
        glGetQueryiv_p: APcv,
        glGetRenderbufferParameteriv_p: APcv,
        glGetSamplerParameterIiv_p: APcv,
        glGetSamplerParameterIuiv_p: APcv,
        glGetSamplerParameterfv_p: APcv,
        glGetSamplerParameteriv_p: APcv,
        glGetShaderInfoLog_p: APcv,
        glGetShaderPrecisionFormat_p: APcv,
        glGetShaderSource_p: APcv,
        glGetShaderiv_p: APcv,
        glGetString_p: APcv,
        glGetStringi_p: APcv,
        glGetSubroutineIndex_p: APcv,
        glGetSubroutineUniformLocation_p: APcv,
        glGetSynciv_p: APcv,
        glGetTexImage_p: APcv,
        glGetTexLevelParameterfv_p: APcv,
        glGetTexLevelParameteriv_p: APcv,
        glGetTexParameterIiv_p: APcv,
        glGetTexParameterIuiv_p: APcv,
        glGetTexParameterfv_p: APcv,
        glGetTexParameteriv_p: APcv,
        glGetTextureImage_p: APcv,
        glGetTextureLevelParameterfv_p: APcv,
        glGetTextureLevelParameteriv_p: APcv,
        glGetTextureParameterIiv_p: APcv,
        glGetTextureParameterIuiv_p: APcv,
        glGetTextureParameterfv_p: APcv,
        glGetTextureParameteriv_p: APcv,
        glGetTextureSubImage_p: APcv,
        glGetTransformFeedbackVarying_p: APcv,
        glGetTransformFeedbacki64_v_p: APcv,
        glGetTransformFeedbacki_v_p: APcv,
        glGetTransformFeedbackiv_p: APcv,
        glGetUniformBlockIndex_p: APcv,
        glGetUniformIndices_p: APcv,
        glGetUniformLocation_p: APcv,
        glGetUniformSubroutineuiv_p: APcv,
        glGetUniformdv_p: APcv,
        glGetUniformfv_p: APcv,
        glGetUniformiv_p: APcv,
        glGetUniformuiv_p: APcv,
        glGetVertexArrayIndexed64iv_p: APcv,
        glGetVertexArrayIndexediv_p: APcv,
        glGetVertexArrayiv_p: APcv,
        glGetVertexAttribIiv_p: APcv,
        glGetVertexAttribIuiv_p: APcv,
        glGetVertexAttribLdv_p: APcv,
        glGetVertexAttribPointerv_p: APcv,
        glGetVertexAttribdv_p: APcv,
        glGetVertexAttribfv_p: APcv,
        glGetVertexAttribiv_p: APcv,
        glGetnCompressedTexImage_p: APcv,
        glGetnTexImage_p: APcv,
        glGetnUniformdv_p: APcv,
        glGetnUniformfv_p: APcv,
        glGetnUniformiv_p: APcv,
        glGetnUniformuiv_p: APcv,
        glHint_p: APcv,
        glInvalidateBufferData_p: APcv,
        glInvalidateBufferSubData_p: APcv,
        glInvalidateFramebuffer_p: APcv,
        glInvalidateNamedFramebufferData_p: APcv,
        glInvalidateNamedFramebufferSubData_p: APcv,
        glInvalidateSubFramebuffer_p: APcv,
        glInvalidateTexImage_p: APcv,
        glInvalidateTexSubImage_p: APcv,
        glIsBuffer_p: APcv,
        glIsEnabled_p: APcv,
        glIsEnabledi_p: APcv,
        glIsFramebuffer_p: APcv,
        glIsProgram_p: APcv,
        glIsProgramPipeline_p: APcv,
        glIsQuery_p: APcv,
        glIsRenderbuffer_p: APcv,
        glIsSampler_p: APcv,
        glIsShader_p: APcv,
        glIsSync_p: APcv,
        glIsTexture_p: APcv,
        glIsTransformFeedback_p: APcv,
        glIsVertexArray_p: APcv,
        glLineWidth_p: APcv,
        glLinkProgram_p: APcv,
        glLogicOp_p: APcv,
        glMapBuffer_p: APcv,
        glMapBufferRange_p: APcv,
        glMapNamedBuffer_p: APcv,
        glMapNamedBufferRange_p: APcv,
        glMemoryBarrier_p: APcv,
        glMemoryBarrierByRegion_p: APcv,
        glMinSampleShading_p: APcv,
        glMultiDrawArrays_p: APcv,
        glMultiDrawArraysIndirect_p: APcv,
        glMultiDrawArraysIndirectCount_p: APcv,
        glMultiDrawElements_p: APcv,
        glMultiDrawElementsBaseVertex_p: APcv,
        glMultiDrawElementsIndirect_p: APcv,
        glMultiDrawElementsIndirectCount_p: APcv,
        glNamedBufferData_p: APcv,
        glNamedBufferStorage_p: APcv,
        glNamedBufferSubData_p: APcv,
        glNamedFramebufferDrawBuffer_p: APcv,
        glNamedFramebufferDrawBuffers_p: APcv,
        glNamedFramebufferParameteri_p: APcv,
        glNamedFramebufferReadBuffer_p: APcv,
        glNamedFramebufferRenderbuffer_p: APcv,
        glNamedFramebufferTexture_p: APcv,
        glNamedFramebufferTextureLayer_p: APcv,
        glNamedRenderbufferStorage_p: APcv,
        glNamedRenderbufferStorageMultisample_p: APcv,
        glObjectLabel_p: APcv,
        glObjectPtrLabel_p: APcv,
        glPatchParameterfv_p: APcv,
        glPatchParameteri_p: APcv,
        glPauseTransformFeedback_p: APcv,
        glPixelStoref_p: APcv,
        glPixelStorei_p: APcv,
        glPointParameterf_p: APcv,
        glPointParameterfv_p: APcv,
        glPointParameteri_p: APcv,
        glPointParameteriv_p: APcv,
        glPointSize_p: APcv,
        glPolygonMode_p: APcv,
        glPolygonOffset_p: APcv,
        glPolygonOffsetClamp_p: APcv,
        glPopDebugGroup_p: APcv,
        glPrimitiveRestartIndex_p: APcv,
        glProgramBinary_p: APcv,
        glProgramParameteri_p: APcv,
        glProgramUniform1d_p: APcv,
        glProgramUniform1dv_p: APcv,
        glProgramUniform1f_p: APcv,
        glProgramUniform1fv_p: APcv,
        glProgramUniform1i_p: APcv,
        glProgramUniform1iv_p: APcv,
        glProgramUniform1ui_p: APcv,
        glProgramUniform1uiv_p: APcv,
        glProgramUniform2d_p: APcv,
        glProgramUniform2dv_p: APcv,
        glProgramUniform2f_p: APcv,
        glProgramUniform2fv_p: APcv,
        glProgramUniform2i_p: APcv,
        glProgramUniform2iv_p: APcv,
        glProgramUniform2ui_p: APcv,
        glProgramUniform2uiv_p: APcv,
        glProgramUniform3d_p: APcv,
        glProgramUniform3dv_p: APcv,
        glProgramUniform3f_p: APcv,
        glProgramUniform3fv_p: APcv,
        glProgramUniform3i_p: APcv,
        glProgramUniform3iv_p: APcv,
        glProgramUniform3ui_p: APcv,
        glProgramUniform3uiv_p: APcv,
        glProgramUniform4d_p: APcv,
        glProgramUniform4dv_p: APcv,
        glProgramUniform4f_p: APcv,
        glProgramUniform4fv_p: APcv,
        glProgramUniform4i_p: APcv,
        glProgramUniform4iv_p: APcv,
        glProgramUniform4ui_p: APcv,
        glProgramUniform4uiv_p: APcv,
        glProgramUniformMatrix2dv_p: APcv,
        glProgramUniformMatrix2fv_p: APcv,
        glProgramUniformMatrix2x3dv_p: APcv,
        glProgramUniformMatrix2x3fv_p: APcv,
        glProgramUniformMatrix2x4dv_p: APcv,
        glProgramUniformMatrix2x4fv_p: APcv,
        glProgramUniformMatrix3dv_p: APcv,
        glProgramUniformMatrix3fv_p: APcv,
        glProgramUniformMatrix3x2dv_p: APcv,
        glProgramUniformMatrix3x2fv_p: APcv,
        glProgramUniformMatrix3x4dv_p: APcv,
        glProgramUniformMatrix3x4fv_p: APcv,
        glProgramUniformMatrix4dv_p: APcv,
        glProgramUniformMatrix4fv_p: APcv,
        glProgramUniformMatrix4x2dv_p: APcv,
        glProgramUniformMatrix4x2fv_p: APcv,
        glProgramUniformMatrix4x3dv_p: APcv,
        glProgramUniformMatrix4x3fv_p: APcv,
        glProvokingVertex_p: APcv,
        glPushDebugGroup_p: APcv,
        glQueryCounter_p: APcv,
        glReadBuffer_p: APcv,
        glReadPixels_p: APcv,
        glReadnPixels_p: APcv,
        glReleaseShaderCompiler_p: APcv,
        glRenderbufferStorage_p: APcv,
        glRenderbufferStorageMultisample_p: APcv,
        glResumeTransformFeedback_p: APcv,
        glSampleCoverage_p: APcv,
        glSampleMaski_p: APcv,
        glSamplerParameterIiv_p: APcv,
        glSamplerParameterIuiv_p: APcv,
        glSamplerParameterf_p: APcv,
        glSamplerParameterfv_p: APcv,
        glSamplerParameteri_p: APcv,
        glSamplerParameteriv_p: APcv,
        glScissor_p: APcv,
        glScissorArrayv_p: APcv,
        glScissorIndexed_p: APcv,
        glScissorIndexedv_p: APcv,
        glShaderBinary_p: APcv,
        glShaderSource_p: APcv,
        glShaderStorageBlockBinding_p: APcv,
        glSpecializeShader_p: APcv,
        glStencilFunc_p: APcv,
        glStencilFuncSeparate_p: APcv,
        glStencilMask_p: APcv,
        glStencilMaskSeparate_p: APcv,
        glStencilOp_p: APcv,
        glStencilOpSeparate_p: APcv,
        glTexBuffer_p: APcv,
        glTexBufferRange_p: APcv,
        glTexImage1D_p: APcv,
        glTexImage2D_p: APcv,
        glTexImage2DMultisample_p: APcv,
        glTexImage3D_p: APcv,
        glTexImage3DMultisample_p: APcv,
        glTexParameterIiv_p: APcv,
        glTexParameterIuiv_p: APcv,
        glTexParameterf_p: APcv,
        glTexParameterfv_p: APcv,
        glTexParameteri_p: APcv,
        glTexParameteriv_p: APcv,
        glTexStorage1D_p: APcv,
        glTexStorage2D_p: APcv,
        glTexStorage2DMultisample_p: APcv,
        glTexStorage3D_p: APcv,
        glTexStorage3DMultisample_p: APcv,
        glTexSubImage1D_p: APcv,
        glTexSubImage2D_p: APcv,
        glTexSubImage3D_p: APcv,
        glTextureBarrier_p: APcv,
        glTextureBuffer_p: APcv,
        glTextureBufferRange_p: APcv,
        glTextureParameterIiv_p: APcv,
        glTextureParameterIuiv_p: APcv,
        glTextureParameterf_p: APcv,
        glTextureParameterfv_p: APcv,
        glTextureParameteri_p: APcv,
        glTextureParameteriv_p: APcv,
        glTextureStorage1D_p: APcv,
        glTextureStorage2D_p: APcv,
        glTextureStorage2DMultisample_p: APcv,
        glTextureStorage3D_p: APcv,
        glTextureStorage3DMultisample_p: APcv,
        glTextureSubImage1D_p: APcv,
        glTextureSubImage2D_p: APcv,
        glTextureSubImage3D_p: APcv,
        glTextureView_p: APcv,
        glTransformFeedbackBufferBase_p: APcv,
        glTransformFeedbackBufferRange_p: APcv,
        glTransformFeedbackVaryings_p: APcv,
        glUniform1d_p: APcv,
        glUniform1dv_p: APcv,
        glUniform1f_p: APcv,
        glUniform1fv_p: APcv,
        glUniform1i_p: APcv,
        glUniform1iv_p: APcv,
        glUniform1ui_p: APcv,
        glUniform1uiv_p: APcv,
        glUniform2d_p: APcv,
        glUniform2dv_p: APcv,
        glUniform2f_p: APcv,
        glUniform2fv_p: APcv,
        glUniform2i_p: APcv,
        glUniform2iv_p: APcv,
        glUniform2ui_p: APcv,
        glUniform2uiv_p: APcv,
        glUniform3d_p: APcv,
        glUniform3dv_p: APcv,
        glUniform3f_p: APcv,
        glUniform3fv_p: APcv,
        glUniform3i_p: APcv,
        glUniform3iv_p: APcv,
        glUniform3ui_p: APcv,
        glUniform3uiv_p: APcv,
        glUniform4d_p: APcv,
        glUniform4dv_p: APcv,
        glUniform4f_p: APcv,
        glUniform4fv_p: APcv,
        glUniform4i_p: APcv,
        glUniform4iv_p: APcv,
        glUniform4ui_p: APcv,
        glUniform4uiv_p: APcv,
        glUniformBlockBinding_p: APcv,
        glUniformMatrix2dv_p: APcv,
        glUniformMatrix2fv_p: APcv,
        glUniformMatrix2x3dv_p: APcv,
        glUniformMatrix2x3fv_p: APcv,
        glUniformMatrix2x4dv_p: APcv,
        glUniformMatrix2x4fv_p: APcv,
        glUniformMatrix3dv_p: APcv,
        glUniformMatrix3fv_p: APcv,
        glUniformMatrix3x2dv_p: APcv,
        glUniformMatrix3x2fv_p: APcv,
        glUniformMatrix3x4dv_p: APcv,
        glUniformMatrix3x4fv_p: APcv,
        glUniformMatrix4dv_p: APcv,
        glUniformMatrix4fv_p: APcv,
        glUniformMatrix4x2dv_p: APcv,
        glUniformMatrix4x2fv_p: APcv,
        glUniformMatrix4x3dv_p: APcv,
        glUniformMatrix4x3fv_p: APcv,
        glUniformSubroutinesuiv_p: APcv,
        glUnmapBuffer_p: APcv,
        glUnmapNamedBuffer_p: APcv,
        glUseProgram_p: APcv,
        glUseProgramStages_p: APcv,
        glValidateProgram_p: APcv,
        glValidateProgramPipeline_p: APcv,
        glVertexArrayAttribBinding_p: APcv,
        glVertexArrayAttribFormat_p: APcv,
        glVertexArrayAttribIFormat_p: APcv,
        glVertexArrayAttribLFormat_p: APcv,
        glVertexArrayBindingDivisor_p: APcv,
        glVertexArrayElementBuffer_p: APcv,
        glVertexArrayVertexBuffer_p: APcv,
        glVertexArrayVertexBuffers_p: APcv,
        glVertexAttrib1d_p: APcv,
        glVertexAttrib1dv_p: APcv,
        glVertexAttrib1f_p: APcv,
        glVertexAttrib1fv_p: APcv,
        glVertexAttrib1s_p: APcv,
        glVertexAttrib1sv_p: APcv,
        glVertexAttrib2d_p: APcv,
        glVertexAttrib2dv_p: APcv,
        glVertexAttrib2f_p: APcv,
        glVertexAttrib2fv_p: APcv,
        glVertexAttrib2s_p: APcv,
        glVertexAttrib2sv_p: APcv,
        glVertexAttrib3d_p: APcv,
        glVertexAttrib3dv_p: APcv,
        glVertexAttrib3f_p: APcv,
        glVertexAttrib3fv_p: APcv,
        glVertexAttrib3s_p: APcv,
        glVertexAttrib3sv_p: APcv,
        glVertexAttrib4Nbv_p: APcv,
        glVertexAttrib4Niv_p: APcv,
        glVertexAttrib4Nsv_p: APcv,
        glVertexAttrib4Nub_p: APcv,
        glVertexAttrib4Nubv_p: APcv,
        glVertexAttrib4Nuiv_p: APcv,
        glVertexAttrib4Nusv_p: APcv,
        glVertexAttrib4bv_p: APcv,
        glVertexAttrib4d_p: APcv,
        glVertexAttrib4dv_p: APcv,
        glVertexAttrib4f_p: APcv,
        glVertexAttrib4fv_p: APcv,
        glVertexAttrib4iv_p: APcv,
        glVertexAttrib4s_p: APcv,
        glVertexAttrib4sv_p: APcv,
        glVertexAttrib4ubv_p: APcv,
        glVertexAttrib4uiv_p: APcv,
        glVertexAttrib4usv_p: APcv,
        glVertexAttribBinding_p: APcv,
        glVertexAttribDivisor_p: APcv,
        glVertexAttribFormat_p: APcv,
        glVertexAttribI1i_p: APcv,
        glVertexAttribI1iv_p: APcv,
        glVertexAttribI1ui_p: APcv,
        glVertexAttribI1uiv_p: APcv,
        glVertexAttribI2i_p: APcv,
        glVertexAttribI2iv_p: APcv,
        glVertexAttribI2ui_p: APcv,
        glVertexAttribI2uiv_p: APcv,
        glVertexAttribI3i_p: APcv,
        glVertexAttribI3iv_p: APcv,
        glVertexAttribI3ui_p: APcv,
        glVertexAttribI3uiv_p: APcv,
        glVertexAttribI4bv_p: APcv,
        glVertexAttribI4i_p: APcv,
        glVertexAttribI4iv_p: APcv,
        glVertexAttribI4sv_p: APcv,
        glVertexAttribI4ubv_p: APcv,
        glVertexAttribI4ui_p: APcv,
        glVertexAttribI4uiv_p: APcv,
        glVertexAttribI4usv_p: APcv,
        glVertexAttribIFormat_p: APcv,
        glVertexAttribIPointer_p: APcv,
        glVertexAttribL1d_p: APcv,
        glVertexAttribL1dv_p: APcv,
        glVertexAttribL2d_p: APcv,
        glVertexAttribL2dv_p: APcv,
        glVertexAttribL3d_p: APcv,
        glVertexAttribL3dv_p: APcv,
        glVertexAttribL4d_p: APcv,
        glVertexAttribL4dv_p: APcv,
        glVertexAttribLFormat_p: APcv,
        glVertexAttribLPointer_p: APcv,
        glVertexAttribP1ui_p: APcv,
        glVertexAttribP1uiv_p: APcv,
        glVertexAttribP2ui_p: APcv,
        glVertexAttribP2uiv_p: APcv,
        glVertexAttribP3ui_p: APcv,
        glVertexAttribP3uiv_p: APcv,
        glVertexAttribP4ui_p: APcv,
        glVertexAttribP4uiv_p: APcv,
        glVertexAttribPointer_p: APcv,
        glVertexBindingDivisor_p: APcv,
        glViewport_p: APcv,
        glViewportArrayv_p: APcv,
        glViewportIndexedf_p: APcv,
        glViewportIndexedfv_p: APcv,
        glWaitSync_p: APcv,
    }
    #[cfg(feature = "bytemuck")]
    unsafe impl bytemuck::Zeroable for GlFns {}
    impl core::fmt::Debug for GlFns {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            write!(f, "GlFns")
        }
    }
}
// end of module
